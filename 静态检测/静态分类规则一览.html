
<!-- saved from url=(0061)file:///D:/tmp/Administrator/parasoft/xtest/gendoc/index.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>启用规则</title></head>
<body bgcolor="white"><font face="Arial, Helvetica"><h1>启用规则</h1>
<ul>
<li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR.html">AUTOSAR C ++ 14编码指南 [AUTOSAR]</a></b>
<ul>
<li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A0_1_1.html">AUTOSAR A0-1-1 项目不应包含被给予随后不被使用值的非 volatile 变量实例 [AUTOSAR-A0_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A0_1_1-a.html">避免未使用的值 [AUTOSAR-A0_1_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A0_1_2.html">AUTOSAR A0-1-2 应使用有非 void 返回类型且不是重载运算符的函数返回的值 [AUTOSAR-A0_1_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A0_1_2-a.html">从不是重载运算符函数得到的非 void 类型的返回值应该始终被使用 [AUTOSAR-A0_1_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A0_1_3.html">AUTOSAR A0-1-3 应使用匿名命名空间中定义的每个函数，或有内部链接的静态函数或私有成员函数 [AUTOSAR-A0_1_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A0_1_3-a.html">每个定义的具有内部链接的函数应该至少被使用一次 [AUTOSAR-A0_1_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A0_1_4.html">AUTOSAR A0-1-4 非虚函数中不应有未使用的命名参数 [AUTOSAR-A0_1_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A0_1_4-a.html">消除未使用的参数 [AUTOSAR-A0_1_4-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A0_1_5.html">AUTOSAR A0-1-5 在虚函数和覆盖虚函数的所有函数的参数集中，不应存在未使用的命名参数 [AUTOSAR-A0_1_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A0_1_5-a.html">在虚函数中不应有未使用的命名参数 [AUTOSAR-A0_1_5-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A0_1_6.html">AUTOSAR A0-1-6 不应该有未使用的类型声明 [AUTOSAR-A0_1_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A0_1_6-a.html">项目不应包含未使用的类型声明 [AUTOSAR-A0_1_6-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A0_4_2.html">AUTOSAR A0-4-2 不应使用 long double 类型 [AUTOSAR-A0_4_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A0_4_2-a.html">不应使用 long double 型 [AUTOSAR-A0_4_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A0_4_4.html">AUTOSAR A0-4-4 使用数学函数时应检查范围、域和极点误差 [AUTOSAR-A0_4_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A0_4_4-a.html">验证传递给库函数的值 [AUTOSAR-A0_4_4-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A10_1_1.html">AUTOSAR A10-1-1 类不应从多个不是接口类的基类派生 [AUTOSAR-A10_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A10_1_1-a.html">要小心使用不是抽象接口的类的多重继承 [AUTOSAR-A10_1_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A10_2_1.html">AUTOSAR A10-2-1 非虚拟成员函数不得在派生类中重新定义 [AUTOSAR-A10_2_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A10_2_1-a.html">禁止对继承的非虚拟函数进行重定义 [AUTOSAR-A10_2_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A10_2_1-b.html">派生类里声明的成员函数不应该隐藏基类中声明的函数 [AUTOSAR-A10_2_1-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A10_3_1.html">AUTOSAR A10-3-1 虚函数声明应该恰好包含这三个说明符中的一个: [AUTOSAR-A10_3_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A10_3_1-a.html">在成员函数声明中,只应该指定 virtual,override 或 final 中的一个 [AUTOSAR-A10_3_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A10_3_2.html">AUTOSAR A10-3-2 每个重写虚函数都应使用 override 或 final 说明符声明 [AUTOSAR-A10_3_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A10_3_2-a.html">使用override关键字标识函数覆盖 [AUTOSAR-A10_3_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A10_3_3.html">AUTOSAR A10-3-3 虚拟函数不得引入 final 类 [AUTOSAR-A10_3_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A10_3_3-a.html">不要在final类中引入虚函数 [AUTOSAR-A10_3_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A10_3_5.html">AUTOSAR A10-3-5 用户定义的赋值运算符不能是虚拟的 [AUTOSAR-A10_3_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A10_3_5-a.html">用户定义的赋值操作符不应是 virtual 的 [AUTOSAR-A10_3_5-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A10_4_1.html">AUTOSAR A10-4-1 层次结构应该基于接口类 [AUTOSAR-A10_4_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A10_4_1-a.html">层次结构应该基于抽象类 [AUTOSAR-A10_4_1-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A11_0_1.html">AUTOSAR A11-0-1 非 POD 类型应该定义为类 [AUTOSAR-A11_0_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A11_0_1-a.html">非 POD 类型应定义为类 [AUTOSAR-A11_0_1-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A11_0_2.html">AUTOSAR A11-0-2 定义为 struct 的类型应该: (1) 只提供 public 数据成员, (2) 不提供任何特殊的成员函数或方法, (3) 不作为另一个结构或类的基位, (4) 不从另一个结构或类继承 [AUTOSAR-A11_0_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A11_0_2-a.html">struct 应该只包含公共数据成员，不应该是基或继承 [AUTOSAR-A11_0_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A11_3_1.html">AUTOSAR A11-3-1 不得使用 Friend 声明 [AUTOSAR-A11_3_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A11_3_1-a.html">避免使用友元(friend)机制 [AUTOSAR-A11_3_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_0_1.html">AUTOSAR A12-0-1 如果一个类通过 "=default", "=delete", 或用户提供的声明声明了一个复制或移动操作或析构函数, 那么这五个特殊成员函数中的所有其他函数也都应该声明 [AUTOSAR-A12_0_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_0_1-a.html">拷贝和析构函数必须一致 [AUTOSAR-A12_0_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_0_2.html">AUTOSAR A12-0-2 不应在对象上执行位操作和在内存中采用数据表示的操作 [AUTOSAR-A12_0_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_0_2-a.html">不要比较可能包含 C 标准库函数填充位的类对象 [AUTOSAR-A12_0_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_1_1.html">AUTOSAR A12-1-1 构造函数应显式初始化所有虚基类、所有直接非虚基类和所有非静态数据成员 [AUTOSAR-A12_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_1_1-a.html">一个类的所有构造函数应该显式地为它的所有直接基类和所有虚基类调用一个构造函数 [AUTOSAR-A12_1_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_1_1-b.html">所有成员变量都应该在构造函数中初始化 [AUTOSAR-A12_1_1-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_1_2.html">AUTOSAR A12-1-2 构造函数中的 NSDMI 和非静态成员的初始化器不能在同一类型中使用 [AUTOSAR-A12_1_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_1_2-a.html">有默认值的非静态成员不能在构造函数初始化列表中使用 [AUTOSAR-A12_1_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_1_3.html">AUTOSAR A12-1-3 如果所有用户定义的类构造器初始化数据成员时，使用的常量值在所有构造函数中都是相同的，则应使用 NSDMI 初始化数据成员 [AUTOSAR-A12_1_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_1_3-a.html">在所有构造函数中,使用相同常量值初始化数据成员的用户定义的构造函数应使用NSDMI进行初始化 [AUTOSAR-A12_1_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_1_4.html">AUTOSAR A12-1-4 所有可以使用基本类型的单个参数调用的构造函数都应显式声明 [AUTOSAR-A12_1_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_1_4-a.html">具有单一基本类型参数可调用的构造函数应该显式地声明 [AUTOSAR-A12_1_4-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_1_5.html">AUTOSAR A12-1-5 非常量成员的公共类初始化应由委托构造函数完成 [AUTOSAR-A12_1_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_1_5-a.html">使用授权的构造器减少代码重复 [AUTOSAR-A12_1_5-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_1_6.html">AUTOSAR A12-1-6 派生类不需要进一步显示初始化并要求所有基类中的构造器都应是使用可继承构造函数 [AUTOSAR-A12_1_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_1_6-a.html">析构类不需要进一步明确初始化，以及要求基类中的所有构造函数都应使用继承构造函数 [AUTOSAR-A12_1_6-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_4_1.html">AUTOSAR A12-4-1 基类的析构函数应该是公共虚拟的、公共覆盖的或受保护的非虚拟的 [AUTOSAR-A12_4_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_4_1-a.html">将基类型的析构函数设置为共有且虚拟的，或保护及非虚拟的 [AUTOSAR-A12_4_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_4_2.html">AUTOSAR A12-4-2 如果类的 public 析构函数是非虚拟的，则该类应该声明为 final [AUTOSAR-A12_4_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_4_2-a.html">如果类的 public 析构函数是非虚拟的，则该类应该声明为 final [AUTOSAR-A12_4_2-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_6_1.html">AUTOSAR A12-6-1 由构造函数初始化的所有类数据成员都应使用成员初始化器进行初始化 [AUTOSAR-A12_6_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_6_1-a.html">在构造函数中推荐使用初始化列表而非赋值 [AUTOSAR-A12_6_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_7_1.html">AUTOSAR A12-7-1 如果用户定义的特殊成员函数的行为与隐式定义的特殊成员函数相同, 则应定义为 "=default" 或者没有定义 [AUTOSAR-A12_7_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_7_1-a.html">如果行为等效，则定义特殊成员=default [AUTOSAR-A12_7_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_8_1.html">AUTOSAR A12-8-1 移动和复制构造函数应该移动和分别复制类的基类和数据成员, 没有任何副作用 [AUTOSAR-A12_8_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_8_1-a.html">拷贝构造函数应仅对其基类型及该类型的非静态成员进行初始化 [AUTOSAR-A12_8_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_8_3.html">AUTOSAR A12-8-3 不能读取访问从对象中移动的对象 [AUTOSAR-A12_8_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_8_3-a.html">不要依赖被移动对象的值 [AUTOSAR-A12_8_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_8_4.html">AUTOSAR A12-8-4 移动构造函数不应使用复制语义初始化其类成员和基类 [AUTOSAR-A12_8_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_8_4-a.html">Use std::move() on rvalue references and std::forward() on forwarding references [AUTOSAR-A12_8_4-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_8_5.html">AUTOSAR A12-8-5 复制赋值和移动赋值运算符应处理自身赋值 [AUTOSAR-A12_8_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_8_5-a.html">在operator=中检查对self的赋值 [AUTOSAR-A12_8_5-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_8_6.html">AUTOSAR A12-8-6 复制和移动构造函数以及复制赋值和移动赋值运算符在基类中应声明为 protected 或定义 '=delete' [AUTOSAR-A12_8_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_8_6-a.html">在基类中避免使用公共(public)拷贝构造函数和赋值运算符 [AUTOSAR-A12_8_6-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_8_7.html">AUTOSAR A12-8-7 赋值运算符应使用 ref-qualifier 声明  &amp; [AUTOSAR-A12_8_7]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A12_8_7-a.html">使用引用修饰符&amp;(ref-qualifier)来声明赋值运算符 [AUTOSAR-A12_8_7-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A13_1_2.html">AUTOSAR A13-1-2 用户定义的文字操作符的用户定义后缀应该以下划线和一个或多个字母开头 [AUTOSAR-A13_1_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A13_1_2-a.html">用户定义的文字操作符的后缀应该以下划线和一个或多个字母开头 [AUTOSAR-A13_1_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A13_1_3.html">AUTOSAR A13-1-3 用户定义的文字运算符只能执行传递参数的转换 [AUTOSAR-A13_1_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A13_1_3-a.html">用户定义的文字运算符只能执行传递参数的转换 [AUTOSAR-A13_1_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A13_2_1.html">AUTOSAR A13-2-1 赋值运算符应返回对 'this' 的引用。 [AUTOSAR-A13_2_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A13_2_1-a.html">赋值操作符返回一个 *this 指向的引用；使赋值操作符的返回类型是指向自身 class 类型的非 const 引用 [AUTOSAR-A13_2_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A13_2_2.html">AUTOSAR A13-2-2 二进制算术运算符和位运算符应返回 "prvalue" [AUTOSAR-A13_2_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A13_2_2-a.html">二进制算术运算符和位运算符应返回一个 'prvalue' [AUTOSAR-A13_2_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A13_2_3.html">AUTOSAR A13-2-3 关系运算符应返回布尔值 [AUTOSAR-A13_2_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A13_2_3-a.html">关系运算符应返回布尔值 [AUTOSAR-A13_2_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A13_3_1.html">AUTOSAR A13-3-1 包含 'forwarding reference' 的函数不应被重载 [AUTOSAR-A13_3_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A13_3_1-a.html">避免在转发引用上使用重载 [AUTOSAR-A13_3_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A13_5_1.html">AUTOSAR A13-5-1 如果 'operator[]' 要被非 const 版本重载，const 版本也应被实现 [AUTOSAR-A13_5_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A13_5_1-a.html">重载 [] 运算符函数时，必须同时实现const和非const版本 [AUTOSAR-A13_5_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A13_5_2.html">AUTOSAR A13-5-2 所有用户定义的转换运算符都应明确定义 [AUTOSAR-A13_5_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A13_5_2-a.html">自定义类型转换函数需要使用标识符标识 [AUTOSAR-A13_5_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A13_5_3.html">AUTOSAR A13-5-3 不应使用用户定义的转换操作符 [AUTOSAR-A13_5_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A13_5_3-a.html">不要使用用户自定义的转换函数 [AUTOSAR-A13_5_3-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A13_5_4.html">AUTOSAR A13-5-4 如果定义了两个相反的运算符, 则其中一个应根据另一个来定义 [AUTOSAR-A13_5_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A13_5_4-b.html">如果在一个类中定义了两个相对相等的操作符('=='，'!=')，则其中一个操作符应以另一个操作符的形式定义 [AUTOSAR-A13_5_4-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A13_5_5.html">AUTOSAR A13-5-5 比较运算符应该是非成员函数, 具有相同的参数类型 [AUTOSAR-A13_5_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A13_5_5-a.html">非成员操作符比成员操作符更支持混合形式的算术运算 [AUTOSAR-A13_5_5-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A13_6_1.html">AUTOSAR A13-6-1 数字序列分隔符 ' 只能用于以下情况: (1) 十进制，每3位; (2) 十六进制，每2位; (3) 二进制，每4位 [AUTOSAR-A13_6_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A13_6_1-a.html">数字序列分隔符 ' 只能与相应的数值类型匹配使用 [AUTOSAR-A13_6_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A14_5_1.html">AUTOSAR A14-5-1 模板构造函数不应参与对封闭类类型的单个参数的重载解析 [AUTOSAR-A14_5_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A14_5_1-a.html">当存在一个包含单个泛型参数的模板构造函数时，拷贝构造函数应该被声明 [AUTOSAR-A14_5_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A14_7_2.html">AUTOSAR A14-7-2 模板专门化应该作为用户定义的类型声明在与主模板 (2) 相同的文件 (1) 中，并为其声明专门化 [AUTOSAR-A14_7_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A14_7_2-a.html">模板专门化应声明在与主模板或用户定义类型相同的文件中，为其声明专门化 [AUTOSAR-A14_7_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A14_8_2.html">AUTOSAR A14-8-2 不应使用函数模板的显式专门化 [AUTOSAR-A14_8_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A14_8_2-a.html">重载函数模板不应该明确专用 [AUTOSAR-A14_8_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_0_2.html">AUTOSAR A15-0-2 至少应为所有操作提供异常安全的基本保障。此外, 每个函数可以提供强保证或 nothrow 保证 [AUTOSAR-A15_0_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_0_2-a.html">确保资源已释放 [AUTOSAR-A15_0_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_1_1.html">AUTOSAR A15-1-1 应该只抛出从 std::exception 衍生出来的实例 [AUTOSAR-A15_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_1_1-a.html">只能使用 std::exception 异常 [AUTOSAR-A15_1_1-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_1_2.html">AUTOSAR A15-1-2 异常对象不应是指针 [AUTOSAR-A15_1_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_1_2-a.html">异常对象不应该有指针类型 [AUTOSAR-A15_1_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_1_4.html">AUTOSAR A15-1-4 如果一个函数以异常退出，那么在抛出之前，该函数应该将函数构造的所有对象/资源置于有效状态或者将他们删除 [AUTOSAR-A15_1_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_1_4-a.html">确保资源已释放 [AUTOSAR-A15_1_4-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_1_5.html">AUTOSAR A15-1-5 不应跨执行边界抛出异常 [AUTOSAR-A15_1_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_1_5-a.html">不要跨越执行边界抛出异常 [AUTOSAR-A15_1_5-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_2_1.html">AUTOSAR A15-2-1 在程序启动之前不应调用非 noexcept 的构造函数 [AUTOSAR-A15_2_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_2_1-a.html">在全局或命名空间作用域中调用的函数不能抛出未处理的异常 [AUTOSAR-A15_2_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_2_1-b.html">在代码中显式抛出的每个异常，在所有可能导致这一点的调用路径中都应该有一个兼容类型的处理程序 [AUTOSAR-A15_2_1-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_3_2.html">AUTOSAR A15-3-2 如果函数抛出检查异常，则应在能采取有意义的动作时进行处理，否则应进行传播。 [AUTOSAR-A15_3_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_3_2-a.html">在代码中显式抛出的每个异常，在所有可能导致这一点的调用路径中都应该有一个兼容类型的处理程序 [AUTOSAR-A15_3_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_3_3.html">AUTOSAR A15-3-3 主函数和任务主函数应至少捕获: 来自所使用的所有第三方库的基类异常、std::exception 和所有其他未处理的异常 [AUTOSAR-A15_3_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_3_3-a.html">至少应该有一个异常处理程序来捕获所有其他未处理的异常 [AUTOSAR-A15_3_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_3_4.html">AUTOSAR A15-3-4 Catch-all (省略号和 std::exception) 处理程序应只在以下情况中使用：(a) main中，(b) task main 函数中，(c) 在应该隔离独立组件的函数中，(d) 在调用第三方代码时，此代码使用不符合 AUTOSAR C++ 14 准则的异常 [AUTOSAR-A15_3_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_3_4-a.html">避免使用 catch-all 异常处理程序 [AUTOSAR-A15_3_4-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_3_5.html">AUTOSAR A15-3-5 类类型异常应通过引用或 const 引用捕获 [AUTOSAR-A15_3_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_3_5-a.html">类类型异常总是会被引用捕获 [AUTOSAR-A15_3_5-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_4_1.html">AUTOSAR A15-4-1 不得使用动态异常规范 [AUTOSAR-A15_4_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_4_1-a.html">不使用throw异常规范 [AUTOSAR-A15_4_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_4_2.html">AUTOSAR A15-4-2 如果一个函数被声明为 noexcept、noexcept(true) 或 noexcept(<true condition="">)，那么它将不会异常退出 [AUTOSAR-A15_4_2]</true></a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_4_2-a.html">避免从声明不抛出异常的函数中抛出异常 [AUTOSAR-A15_4_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_4_3.html">AUTOSAR A15-4-3 函数的 noexcept 规范在所有编译单元中应该是相同的, 或者在虚成员函数和  overrider 之间是相同的或有更多的限制 [AUTOSAR-A15_4_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_4_3-a.html">如果函数声明时指定了异常，那么所有相同函数的声明都应该使用相同的类型id声明 [AUTOSAR-A15_4_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_4_4.html">AUTOSAR A15-4-4 未抛异常的函数的声明应包含 noexcept 规范 [AUTOSAR-A15_4_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_4_4-a.html">如果函数不抛出异常，请使用关键字 'noexcept' 声明 [AUTOSAR-A15_4_4-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_4_5.html">AUTOSAR A15-4-5 可以从函数抛出的已检查异常应与函数声明一起指定，并且在所有函数声明及其覆盖程序中，这些异常应是相同的 [AUTOSAR-A15_4_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_4_5-a.html">可从函数中抛出的已检测异常应该直接在函数声明前的注释中指定 [AUTOSAR-A15_4_5-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_5_1.html">AUTOSAR A15-5-1 所有用户提供的类析构函数、释放函数、移动构造函数、移动赋值运算符和交换函数都不能异常退出。应酌情在这些功能中添加 noexcept 异常规范 [AUTOSAR-A15_5_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_5_1-a.html">绝不允许从析构函数、释放函数和交换函数中抛出异常 [AUTOSAR-A15_5_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_5_1-b.html">所有用户提供的移动构造函数和移动分配操作符都不应异常退出 [AUTOSAR-A15_5_1-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_5_2.html">AUTOSAR A15-5-2 程序不得突然终止。特别是，不应对 std::abort()，std::quick_exit()，std::_Exit()，std::terminate() 进行隐式或显式调用。 [AUTOSAR-A15_5_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_5_2-a.html">注册为'std::atexit()'或'std::at_quick_exit()'的函数的执行不应该通过异常退出 [AUTOSAR-A15_5_2-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_5_2-b.html">不得使用 'stdlib.h' 或 'cstdlib' 库中的 'abort()' 函数 [AUTOSAR-A15_5_2-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_5_2-c.html">不得使用 'stdlib.h' 或 'cstdlib' 库中的 'quick_exit()' 和 '_Exit()' 函数 [AUTOSAR-A15_5_2-c-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_5_3.html">AUTOSAR A15-5-3 不应隐式调用 std::terminate() 函数 [AUTOSAR-A15_5_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_5_3-a.html">注册为'std::atexit()'或'std::at_quick_exit()'的函数的执行不应该通过异常退出 [AUTOSAR-A15_5_3-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_5_3-b.html">绝不允许从析构函数、释放函数和交换函数中抛出异常 [AUTOSAR-A15_5_3-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_5_3-c.html">不要从析构器中抛出 [AUTOSAR-A15_5_3-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_5_3-d.html">至少应该有一个异常处理程序来捕获所有其他未处理的异常 [AUTOSAR-A15_5_3-d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_5_3-e.html">空抛出(throw;)只能用于catch处理程序的复合语句中 [AUTOSAR-A15_5_3-e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_5_3-f.html">只有在程序启动后和终止前才会出现异常情况 [AUTOSAR-A15_5_3-f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_5_3-g.html">在代码中显式抛出的每个异常，在所有可能导致这一点的调用路径中都应该有一个兼容类型的处理程序 [AUTOSAR-A15_5_3-g-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_5_3-h.html">如果函数的声明包含异常规范，则该函数只能抛出指定类型的异常 [AUTOSAR-A15_5_3-h-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_5_3-i.html">在全局或命名空间作用域中调用的函数不能抛出未处理的异常 [AUTOSAR-A15_5_3-i-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_5_3-j.html">始终捕获异常 [AUTOSAR-A15_5_3-j-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A15_5_3-k.html">正确定义退出处理程序 [AUTOSAR-A15_5_3-k-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A16_0_1.html">AUTOSAR A16-0-1 预处理器应仅用于无条件和条件文件包含以及包含保护，并使用以下指令：（1） #ifndef，（2） #ifdef，（3） #if，（4） #if defined，（5） #elif，（6） #else，（7） #define，（8） #endif，（9） #include [AUTOSAR-A16_0_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A16_0_1-a.html">#ifndef 和 #endif 预处理指令将仅用于防止重复地包含相同的头文件 [AUTOSAR-A16_0_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A16_0_1-b.html">函数应该优先于宏函数的使用 [AUTOSAR-A16_0_1-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A16_0_1-c.html">不要通过 #define 定义常量 [AUTOSAR-A16_0_1-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A16_0_1-d.html">避免使用宏 [AUTOSAR-A16_0_1-d-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A16_2_1.html">AUTOSAR A16-2-1 字符 '， "， /*， //， \ 不应出现在头文件名或#include指令中 [AUTOSAR-A16_2_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A16_2_1-a.html">下列的字符序列不得出现在头文件名中： ', \, /*, //, 或 " [AUTOSAR-A16_2_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A16_2_2.html">AUTOSAR A16-2-2 不得有未使用的  include 指令 [AUTOSAR-A16_2_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A16_2_2-a.html">文件应该只包含(include)具有编译该文件所需的声明和定义的头文件 [AUTOSAR-A16_2_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A16_6_1.html">AUTOSAR A16-6-1 不应使用 #error 指令 [AUTOSAR-A16_6_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A16_6_1-a.html">不应使用 #error 指令 [AUTOSAR-A16_6_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A16_7_1.html">AUTOSAR A16-7-1 不应使用 #pragma 指令 [AUTOSAR-A16_7_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A16_7_1-a.html">不应使用 #pragma 指令 [AUTOSAR-A16_7_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A17_0_1.html">AUTOSAR A17-0-1 C++ 标准库中的保留标识符，宏和函数不得定义，重新定义或未定义 [AUTOSAR-A17_0_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A17_0_1-a.html">不要#define也不要#undef '已定义'的标识 [AUTOSAR-A17_0_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A17_0_1-b.html">标准库中的保留标识符、宏和函数不应被定义、重新定义或取消定义（C99代码） [AUTOSAR-A17_0_1-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A17_0_1-c.html">在标准程序库中的保留标识符，宏以及函数不应该被定义，重定义或取消定义（C90代码 [AUTOSAR-A17_0_1-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A17_0_1-d.html">不要重新定义保留字 [AUTOSAR-A17_0_1-d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A17_0_1-e.html">不要使用以下划线开头的带有#define 或 #undef 名称的标识符 [AUTOSAR-A17_0_1-e-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A17_1_1.html">AUTOSAR A17-1-1 C标准库的使用应封装和隔离 [AUTOSAR-A17_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A17_1_1-a.html">不得使用错误指示 'errno' [AUTOSAR-A17_1_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A17_6_1.html">AUTOSAR A17-6-1 不应将非标准实体添加到标准名称空间中 [AUTOSAR-A17_6_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A17_6_1-a.html">不要修改标准命名空间 'std' 和 'posix' [AUTOSAR-A17_6_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_0_1.html">AUTOSAR A18-0-1 C 库设施只能通过 C++ 库的头文件访问 [AUTOSAR-A18_0_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_0_1-a.html">不能使用C语言库 [AUTOSAR-A18_0_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_0_2.html">AUTOSAR A18-0-2 应检查从字符串转换到数值的错误状态 [AUTOSAR-A18_0_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_0_2-a.html">不得使用库stdlib.h中的库函数atof，atoi和atol [AUTOSAR-A18_0_2-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_0_2-b.html">不得使用库stdlib.h中的库函数atof，atoi和atol [AUTOSAR-A18_0_2-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_0_3.html">AUTOSAR A18-0-3 不得使用库 <clocale> (locale.h)和 setlocale 函数 [AUTOSAR-A18_0_3]</clocale></a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_0_3-a.html">不应包含 &lt;locale.h&gt; 头文件 [AUTOSAR-A18_0_3-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_0_3-b.html">不要使用 setlocale 函数 [AUTOSAR-A18_0_3-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_1_1.html">AUTOSAR A18-1-1 不应使用 C 风格的数组 [AUTOSAR-A18_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_1_1-a.html">使用向量(vector)或者字符串代替数组 [AUTOSAR-A18_1_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_1_2.html">AUTOSAR A18-1-2 不得使用  std::vector<bool> 不得使用特殊化 [AUTOSAR-A18_1_2]</bool></a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_1_2-a.html">避免使用 vector&lt;bool&gt; [AUTOSAR-A18_1_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_1_3.html">AUTOSAR A18-1-3 不得使用  std::auto_ptr 类型 [AUTOSAR-A18_1_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_1_3-a.html">更喜欢使用 std::unique_ptr 而不是 std::auto_ptr [AUTOSAR-A18_1_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_1_4.html">AUTOSAR A18-1-4 指向对象数组元素的指针不应传递给单一对象类型的智能指针 [AUTOSAR-A18_1_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_1_4-a.html">指向对象数组元素的指针不应被传递给单一对象类型的智能指针 [AUTOSAR-A18_1_4-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_1_6.html">AUTOSAR A18-1-6 所有用户定义类型的 std::hash 专门化都应该有一个 noexcept 函数调用操作符 [AUTOSAR-A18_1_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_1_6-a.html">所有用户定义类型的std::hash专门化都应该有一个noexcept函数调用操作符 [AUTOSAR-A18_1_6-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_5_1.html">AUTOSAR A18-5-1 禁止使用 malloc、calloc、realloc 和 free 函数 [AUTOSAR-A18_5_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_5_1-a.html">不要使用 calloc, malloc, realloc 和 free 函数 [AUTOSAR-A18_5_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_5_10.html">AUTOSAR A18-5-10 应仅使用正确对齐的指针来快速布局, 以获得足够的存储容量 [AUTOSAR-A18_5_10]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_5_10-a.html">不要传递存储容量不足或者没有对正在构造的对象进行适当的对齐以配置 'new' 的指针 [AUTOSAR-A18_5_10-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_5_10-b.html">当一个对象数组传递给配置 'new' 的定位函数时,应该会有开销 [AUTOSAR-A18_5_10-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_5_11.html">AUTOSAR A18-5-11 应共同定义 "operator new" 和 "operator delete"  [AUTOSAR-A18_5_11]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_5_11-a.html">如果写了 new 操作符应该对应写 delete 操作符 [AUTOSAR-A18_5_11-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_5_11-b.html">如果写了 new[] 操作符应该对应写 delete[] 操作符 [AUTOSAR-A18_5_11-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_5_2.html">AUTOSAR A18-5-2 不得使用新的未布局的表达式或删除表达式 [AUTOSAR-A18_5_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_5_2-a.html">禁止使用动态内存分配 [AUTOSAR-A18_5_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_5_3.html">AUTOSAR A18-5-3 delete 表达式的形式应与用于分配内存的 new 运算符的形式相匹配 [AUTOSAR-A18_5_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_5_3-a.html">释放非数组内存时 delete 不能使用括号([]) [AUTOSAR-A18_5_3-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_5_3-b.html">释放数组内存时 delete 必须使用空括号([]) [AUTOSAR-A18_5_3-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_5_3-c.html">正确地动态释放分配的资源 [AUTOSAR-A18_5_3-c-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_5_4.html">AUTOSAR A18-5-4 如果项目有大小或非大小版本的操作符 "delete" 全局定义的，则应定义大小版本和非大小版本 [AUTOSAR-A18_5_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_5_4-a.html">定义操作符 delete 的分级版本和未分级版本 [AUTOSAR-A18_5_4-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_5_5.html">AUTOSAR A18-5-5 内存管理函数应确保以下内容：（a）由于存在最坏情况执行时间而导致的确定性行为，（b）避免内存碎片，（c）避免内存不足，（d）避免不匹配的分配或解除分配，（e）不依赖于对内核的非确定性调用 [AUTOSAR-A18_5_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_5_5-a.html">在对相应的 new/malloc 以及 delete/free 的调用中应使用相同的形式 [AUTOSAR-A18_5_5-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_5_5-b.html">被释放的内存在任何情况下都不应该被访问 [AUTOSAR-A18_5_5-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_5_5-c.html">正确定义新处理程序 [AUTOSAR-A18_5_5-c-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_5_8.html">AUTOSAR A18-5-8 功能失效的对象应具有自动存储持续时间 [AUTOSAR-A18_5_8]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_5_8-a.html">使用声明进行内存分配，而不是 new 或者 malloc [AUTOSAR-A18_5_8-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_5_9.html">AUTOSAR A18-5-9 动态内存分配和释放函数的自定义实现应满足 C++ 标准中的相应 " 必需行为 " 语句中指定的语义要求。 [AUTOSAR-A18_5_9]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_5_9-a.html">当分配失败时，用户定义的'new'操作符应该抛出'std::bad_alloc'异常 [AUTOSAR-A18_5_9-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_9_1.html">AUTOSAR A18-9-1 不得使用 std::bind [AUTOSAR-A18_9_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_9_1-a.html">与 std::bind，std::bind1st 和 std::bind2nd 相比，更偏向 lambda 表达式 [AUTOSAR-A18_9_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_9_2.html">AUTOSAR A18-9-2 将值转发给其他函数的方式有: (1) 如果值为 rvalue 引用, std::move; (2) 如果值为转发引用, std::forward [AUTOSAR-A18_9_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_9_2-a.html">'std::forward' 函数应用来转发通用引用 [AUTOSAR-A18_9_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_9_3.html">AUTOSAR A18-9-3 std::move 不得用于已声明的 const 或  const&amp; 对象 [AUTOSAR-A18_9_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_9_3-a.html">不要对常量或常量类型对象使用 std::move [AUTOSAR-A18_9_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_9_4.html">AUTOSAR A18-9-4 不得在后续过程中使用 std::forward 的参数 [AUTOSAR-A18_9_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A18_9_4-a.html">后续不要使用传递给参数 std::forward [AUTOSAR-A18_9_4-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A1_1_1.html">AUTOSAR A1-1-1 所有代码应符合 ISO/IEC 14882:2014 - 编程语言 C++ 不应该使用已弃用的功能 [AUTOSAR-A1_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A1_1_1-a.html">不应使用'register'存储类说明符 [AUTOSAR-A1_1_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A1_1_1-b.html">声明复制构造函数时应声明复制赋值运算符（反之亦然） [AUTOSAR-A1_1_1-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A1_1_1-c.html">复制构造函数和复制赋值运算符都应该为具有非平凡析构函数的类声明 [AUTOSAR-A1_1_1-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A1_1_1-d.html">不能使用C语言库 [AUTOSAR-A1_1_1-d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A1_1_1-e.html">与 std::bind，std::bind1st 和 std::bind2nd 相比，更偏向 lambda 表达式 [AUTOSAR-A1_1_1-e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A1_1_1-f.html">不应该使用 'binder1st' 和 'binder2nd' 标识符 [AUTOSAR-A1_1_1-f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A1_1_1-g.html">更喜欢使用 std::unique_ptr 而不是 std::auto_ptr [AUTOSAR-A1_1_1-g-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A1_1_1-h.html">不应该使用 'random_shuffle' 标识符 [AUTOSAR-A1_1_1-h-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A1_1_1-i.html">不要在 'bool' 类型的操作数上使用递增操作符（++） [AUTOSAR-A1_1_1-i-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A1_1_1-j.html">不应该使用 'set_unexpected' 标识符 [AUTOSAR-A1_1_1-j-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A1_1_1-k.html">不使用throw异常规范 [AUTOSAR-A1_1_1-k-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A20_8_1.html">AUTOSAR A20-8-1 已拥有的指针值不应存储在不相关的智能指针中 [AUTOSAR-A20_8_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A20_8_1-a.html">在一个无关的智能指针中不要保存一个只读指针变量 [AUTOSAR-A20_8_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A20_8_2.html">AUTOSAR A20-8-2 std::unique_ptr 应用来代表独占权 [AUTOSAR-A20_8_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A20_8_2-a.html">当将指针传递给线程中的对象时，使用智能指针 [AUTOSAR-A20_8_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A20_8_3.html">AUTOSAR A20-8-3 std::shared_ptr 应用来代表共享权 [AUTOSAR-A20_8_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A20_8_3-a.html">当将指针传递给线程中的对象时，使用智能指针 [AUTOSAR-A20_8_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A20_8_4.html">AUTOSAR A20-8-4 std::unique_ptr 应在 std::shared_ptr 上用来表示共享权是否必需 [AUTOSAR-A20_8_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A20_8_4-a.html">考虑将本地对象的 'std::shared_ptr' 类型替换为 'std::unique_ptr' 类型 [AUTOSAR-A20_8_4-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A20_8_5.html">AUTOSAR A20-8-5 std::make_unique 构造 std::unique_ptr 所拥有的对象 [AUTOSAR-A20_8_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A20_8_5-a.html">'std::make_unique'应该用来构造属于'std::unique_ptr'的对象 [AUTOSAR-A20_8_5-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A20_8_6.html">AUTOSAR A20-8-6 std::make_shared 用来构造 std::shared_ptr 所拥有的对象 [AUTOSAR-A20_8_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A20_8_6-a.html">建议使用 'std::make_shared' 而不是直接使用 new [AUTOSAR-A20_8_6-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A20_8_7.html">AUTOSAR A20-8-7 不应使用 std::weak_ptr 表示临时共享所有权 [AUTOSAR-A20_8_7]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A20_8_7-a.html">避免循环引用 shared_ptr [AUTOSAR-A20_8_7-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A21_8_1.html">AUTOSAR A21-8-1 字符处理函数的参数应该可以表示为无符号的 char 类型 [AUTOSAR-A21_8_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A21_8_1-a.html">不要传递不正确的值给 ctype.h 库函数 [AUTOSAR-A21_8_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A23_0_1.html">AUTOSAR A23-0-1 iterator 不得隐式转换为 const_iterator [AUTOSAR-A23_0_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A23_0_1-a.html">当结果转换为const迭代器时，使用const容器调用 [AUTOSAR-A23_0_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A23_0_2.html">AUTOSAR A23-0-2 容器的元素只能通过有效的引用、迭代器和指针访问 [AUTOSAR-A23_0_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A23_0_2-a.html">在遍历容器时不要修改容器 [AUTOSAR-A23_0_2-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A23_0_2-b.html">使用有效的引用、指针和迭代器来引用一个 basic_string 的元素 [AUTOSAR-A23_0_2-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A25_1_1.html">AUTOSAR A25-1-1 不应复制与此对象标识相关状态的非静态数据成员或谓词函数对象的捕获值 [AUTOSAR-A25_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A25_1_1-a.html">使谓词常量成为纯函数 [AUTOSAR-A25_1_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A25_4_1.html">AUTOSAR A25-4-1 与关联容器和 STL 排序以及相关算法一起使用的排序谓词应遵循严格的弱排序关系 [AUTOSAR-A25_4_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A25_4_1-a.html">禁止对关联容器使用判定相等数值为 true 的比较函数 [AUTOSAR-A25_4_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A26_5_1.html">AUTOSAR A26-5-1 不得使用  std::rand() 生成伪随机数 [AUTOSAR-A26_5_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A26_5_1-a.html">不要使用rand()函数来生成伪随机数 [AUTOSAR-A26_5_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A26_5_2.html">AUTOSAR A26-5-2 不应默认初始化随机数引擎 [AUTOSAR-A26_5_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A26_5_2-a.html">在伪随机数生成器中指定适当的种子 [AUTOSAR-A26_5_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A27_0_1.html">AUTOSAR A27-0-1 应验证独立组件的输入 [AUTOSAR-A27_0_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A27_0_1-a.html">避免调用只有一个参数而不是字符串常量的函数 printf/wprintf [AUTOSAR-A27_0_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A27_0_1-b.html">避免在数组索引中有受污染数据 [AUTOSAR-A27_0_1-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A27_0_1-c.html">防止来自受污染数据的缓冲区溢出 [AUTOSAR-A27_0_1-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A27_0_1-d.html">避免由于定义不正确的格式限制而导致受污染数据的缓冲区溢出 [AUTOSAR-A27_0_1-d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A27_0_1-e.html">避免来自受污染数据的缓冲区读取溢出 [AUTOSAR-A27_0_1-e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A27_0_1-f.html">避免来自受污染数据的缓冲区写入溢出 [AUTOSAR-A27_0_1-f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A27_0_1-g.html">防止命令注入 [AUTOSAR-A27_0_1-g-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A27_0_1-h.html">从格式字符串中排除未经消毒的用户输入 [AUTOSAR-A27_0_1-h-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A27_0_2.html">AUTOSAR A27-0-2 C 风格的字符串应保证有足够的空间用于数据和 null 终止符 [AUTOSAR-A27_0_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A27_0_2-a.html">避免由于读取非零终止字符串导致的溢出 [AUTOSAR-A27_0_2-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A27_0_2-b.html">避免写入缓冲区时导致的溢出 [AUTOSAR-A27_0_2-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A27_0_2-c.html">使用向量(vector)或者字符串代替数组 [AUTOSAR-A27_0_2-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A27_0_2-d.html">避免访问数组越界 [AUTOSAR-A27_0_2-d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A27_0_2-e.html">防止来自受污染数据的缓冲区溢出 [AUTOSAR-A27_0_2-e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A27_0_2-f.html">避免来自受污染数据的缓冲区写入溢出 [AUTOSAR-A27_0_2-f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A27_0_2-g.html">避免使用可能导致缓冲区溢出的不安全字符串函数 [AUTOSAR-A27_0_2-g-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A27_0_3.html">AUTOSAR A27-0-3 如果没有插入刷新或定位调用，就不能使用文件流上轮流的输入和输出操作 [AUTOSAR-A27_0_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A27_0_3-a.html">不要从一个流中交替地输入和输出，却没有间隔刷新或定位调用 [AUTOSAR-A27_0_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A27_0_4.html">AUTOSAR A27-0-4 不应使用 C 风格的字符串 [AUTOSAR-A27_0_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A27_0_4-a.html">不要使用不安全的 C 函数来写未检查范围的缓冲区 [AUTOSAR-A27_0_4-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A27_0_4-b.html">避免使用不安全的不检查界限的字符串函数 [AUTOSAR-A27_0_4-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A27_0_4-c.html">不要使用 'char' 缓冲区来存储来自 'std::cin' 的输入 [AUTOSAR-A27_0_4-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A27_0_4-d.html">不能使用 C 风格的字符串 [AUTOSAR-A27_0_4-d-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_10_1.html">AUTOSAR A2-10-1 在内部作用域声明的标识符, 不得隐藏在外部作用域声明的标识符 [AUTOSAR-A2_10_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_10_1-a.html">在局部或者函数原型体范围内声明的标识符不应该隐藏一个在全局或者命名空间范围内声明的标识符 [AUTOSAR-A2_10_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_10_1-b.html">在内层的局部范围内声明的标识符不应该隐藏在外层的局部范围内声明的标识符 [AUTOSAR-A2_10_1-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_10_1-c.html">在一个局部范围内声明的标识符不应该隐藏在一个类作用域中声明的标识符 [AUTOSAR-A2_10_1-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_10_1-d.html">在类的作用域中声明的标识符不应该隐藏在全局或命名空间范围内声明的标识符 [AUTOSAR-A2_10_1-d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_10_1-e.html">在一个内部类作用域中声明的标识符不应该隐藏在外部类作用域中声明的标识符 [AUTOSAR-A2_10_1-e-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_10_4.html">AUTOSAR A2-10-4 不应在命名空间重复使用具有静态存储持续时间的非成员对象的标识符名称 [AUTOSAR-A2_10_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_10_4-a.html">The identifier name of a non-member object with static storage duration shall not be reused within a namespace [AUTOSAR-A2_10_4-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_10_4-b.html">The identifier name of a non-member static function shall not be reused within a namespace [AUTOSAR-A2_10_4-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_10_5.html">AUTOSAR A2-10-5 不应重复使用具有静态存储持续时间的函数或具有外部或内部链接的非成员对象的标识符名称 [AUTOSAR-A2_10_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_10_5-a.html">禁止重用静态存储周期的对象或函数的标识符 [AUTOSAR-A2_10_5-a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_10_5-b.html">禁止重用静态存储周期的对象或函数的标识符 [AUTOSAR-A2_10_5-b-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_10_6.html">AUTOSAR A2-10-6 类或枚举名称不应被同一范围内的变量、函数或枚举器声明隐藏 [AUTOSAR-A2_10_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_10_6-a.html">如果标识符指的是一个类型，它不应也指向同一范围内的对象或函数 [AUTOSAR-A2_10_6-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_10_6-b.html">如果标识符指的是一个类型，它不应也指向同一范围内的对象或函数 [AUTOSAR-A2_10_6-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_10_6-c.html">如果标识符指的是一个类型，它不应也指向同一范围内的对象或函数 [AUTOSAR-A2_10_6-c-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_11_1.html">AUTOSAR A2-11-1 不得使用 Volatile 关键字 [AUTOSAR-A2_11_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_11_1-a.html">不要使用 volatile 关键字 [AUTOSAR-A2_11_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_13_1.html">AUTOSAR A2-13-1 应使用那些只在 ISO/IEC 14882:2014 中定义的转义序列 [AUTOSAR-A2_13_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_13_1-a.html">只得使用那些定义在 ISO/IEC 14882:2003 中的转义序列 [AUTOSAR-A2_13_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_13_2.html">AUTOSAR A2-13-2 不应连接具有不同编码前缀的字符串文字 [AUTOSAR-A2_13_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_13_2-a.html">不应连接具有不同编码前缀的字符串文字 [AUTOSAR-A2_13_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_13_3.html">AUTOSAR A2-13-3 不应使用 wchar_t 类型 [AUTOSAR-A2_13_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_13_3-a.html">不应使用 wchar_t 类型 [AUTOSAR-A2_13_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_13_4.html">AUTOSAR A2-13-4 字符串文字不应分配给非常量指针 [AUTOSAR-A2_13_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_13_4-a.html">字符串文字不应被修改 [AUTOSAR-A2_13_4-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_13_5.html">AUTOSAR A2-13-5 十六进制常量应该是大写的 [AUTOSAR-A2_13_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_13_5-a.html">十六进制常量应该全部使用大写字母表示 [AUTOSAR-A2_13_5-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_13_6.html">AUTOSAR A2-13-6 通用字符名称应仅使用在字符或字符串文本内 [AUTOSAR-A2_13_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_13_6-a.html">通用字符名称仅应在字符或字符串文本内使用 [AUTOSAR-A2_13_6-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_3_1.html">AUTOSAR A2-3-1 在源代码中, 应使用那些只在 C++ 语言标准的基本源代码字符集中指定的字符 [AUTOSAR-A2_3_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_3_1-a.html">只使用 ISO C 标准中定义的字符 [AUTOSAR-A2_3_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_5_1.html">AUTOSAR A2-5-1 不得使用三联符 [AUTOSAR-A2_5_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_5_1-a.html">禁止使用三字母词 [AUTOSAR-A2_5_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_5_1-b.html">禁止使用三字母词 [AUTOSAR-A2_5_1-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_5_2.html">AUTOSAR A2-5-2 不得使用有向图 [AUTOSAR-A2_5_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_5_2-a.html">不要使用下列合体字母 &lt;%, %&gt;, &lt;:, :&gt;, %:, %:%: [AUTOSAR-A2_5_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_7_1.html">AUTOSAR A2-7-1 字符 \ 不应作为  C++ 注释的最后一个字符出现 [AUTOSAR-A2_7_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_7_1-a.html">不得在 // 注释中使用行合并 [AUTOSAR-A2_7_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_7_2.html">AUTOSAR A2-7-2 代码段不应 "添加注释" [AUTOSAR-A2_7_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_7_2-a.html">代码段不应该被“注释掉” [AUTOSAR-A2_7_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_7_3.html">AUTOSAR A2-7-3 所有 "user-defined" 类型、静态和非静态的数据成员、函数和方法的声明之前都应使用 "///" 注释和 "@tag" 标签文档 [AUTOSAR-A2_7_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_7_3-a.html">所有类型、数据成员和函数的声明之前都应该有一个注释，注释使用 '@brief' 标记 [AUTOSAR-A2_7_3-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_7_3-b.html">函数参数和返回类型应该记录在函数声明之前的注释中 [AUTOSAR-A2_7_3-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_8_1.html">AUTOSAR A2-8-1 如果头文件声明了类型, 那么它的头文件名称应该与其声明的类型名称相同 [AUTOSAR-A2_8_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A2_8_1-a.html">对应类的包含文件应采用 &lt;类名&gt; 加扩展名的格式 [AUTOSAR-A2_8_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A3_1_1.html">AUTOSAR A3-1-1 应该可以在多个编译单元中包含任何头文件而不违反一个定义规则 [AUTOSAR-A3_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A3_1_1-a.html">在头文件中不能定义具有链接属性的实体 [AUTOSAR-A3_1_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A3_1_2.html">AUTOSAR A3-1-2 项目中本地定义的头文件应有 ".h", ".hpp" or ".hxx" 中其中一个的扩展文件名 [AUTOSAR-A3_1_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A3_1_2-a.html">头文件的文件扩展名应该是: ".h", ".hpp" 或 ".hxx" [AUTOSAR-A3_1_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A3_1_3.html">AUTOSAR A3-1-3 在项目中本地定义的实现文件的文件扩展名应为 '.cpp' [AUTOSAR-A3_1_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A3_1_3-a.html">C++ 的实现文件应该总是具有扩展名 ".cpp" [AUTOSAR-A3_1_3-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A3_1_4.html">AUTOSAR A3-1-4 当声明具有外部链接的数组时，应明确说明其大小 [AUTOSAR-A3_1_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A3_1_4-a.html">当数组声明具有外部链接，其大小应该显式地说明或者在初始化时隐性地定义 [AUTOSAR-A3_1_4-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A3_1_5.html">AUTOSAR A3-1-5 只有当 (1) 函数是内联的 (2) 是成员函数模板 (3)是类模板的成员函数的时候, 函数定义才应该放在类定义中 [AUTOSAR-A3_1_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A3_1_5-a.html">非模板类的定义中不能定义成员函数 [AUTOSAR-A3_1_5-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A3_1_6.html">AUTOSAR A3-1-6 常规的访问器和 mutator 函数应该内联 [AUTOSAR-A3_1_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A3_1_6-a.html">短小且简单的 accessor/mutator 语句应该为内联函数 [AUTOSAR-A3_1_6-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A3_3_1.html">AUTOSAR A3-3-1 有外部链接的对象或函数（包括具名命名空间的成员）应在头文件中声明 [AUTOSAR-A3_3_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A3_3_1-a.html">具有外部链接的对象或函数应该在头文件中声明 [AUTOSAR-A3_3_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A3_3_1-b.html">在头文件中不能定义具有链接属性的实体 [AUTOSAR-A3_3_1-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A3_3_2.html">AUTOSAR A3-3-2 静态对象和线程本地对象应不断初始化 [AUTOSAR-A3_3_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A3_3_2-a.html">静态对象和线程本地对象应不断初始化 [AUTOSAR-A3_3_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A3_8_1.html">AUTOSAR A3-8-1 对象在其生命周期之外不得被访问 [AUTOSAR-A3_8_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A3_8_1-a.html">不得使用已经释放掉的资源 [AUTOSAR-A3_8_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A3_8_1-b.html">不得从函数中返回具有自动存储的对象的地址 [AUTOSAR-A3_8_1-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A3_8_1-c.html">自动存储对象的地址不应分配给在第一个对象不再存在后可能持久存在的另一个对象 [AUTOSAR-A3_8_1-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A3_8_1-d.html">不要指向已被释放的包装对象 [AUTOSAR-A3_8_1-d-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A3_9_1.html">AUTOSAR A3-9-1 来自 <cstdint>的固定宽度整数类型，表示大小和符号，应用于代替基本数字类型 [AUTOSAR-A3_9_1]</cstdint></a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A3_9_1-a.html">用 typedef 定义基本类型应该在名称中包含数字 [AUTOSAR-A3_9_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A3_9_1-b.html">typedefs 应该被用于替代基本类型 [AUTOSAR-A3_9_1-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A4_10_1.html">AUTOSAR A4-10-1 只有 nullptr 字面量才能用作 null-pointer-constant [AUTOSAR-A4_10_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A4_10_1-a.html">NULL 不得用作一个整数值 [AUTOSAR-A4_10_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A4_10_1-b.html">使用nullptr代替null和0 [AUTOSAR-A4_10_1-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A4_5_1.html">AUTOSAR A4-5-1 类型枚举或枚举类的表达式不应用作内置和重载运算符的操作数，下标运算符[]，赋值运算符=，等于运算符==和!=，一元&amp;运算符和关系运算符&lt;， &lt;=， &gt;， &gt;= 除外 [AUTOSAR-A4_5_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A4_5_1-a.html">具有枚举类型的表达式不得用作除了 [ ], &nbsp;=, ==, !=, &lt;, &lt;=, &gt;, &gt;=, 和一元 &amp; 运算符以外的内建运算符的操作数 [AUTOSAR-A4_5_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A4_7_1.html">AUTOSAR A4-7-1 整数表达式不应导致数据丢失 [AUTOSAR-A4_7_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A4_7_1-a.html">避免从有符号类型到无符号类型的隐式变换 [AUTOSAR-A4_7_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A4_7_1-b.html">不应使用可能会导致信息丢失的从整数常量到浮点类型的隐式转换 [AUTOSAR-A4_7_1-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A4_7_1-c.html">避免将常数值转换为一个窄类型 [AUTOSAR-A4_7_1-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A4_7_1-d.html">不应使用可能导致信息丢失的从较宽到较窄的整数类型的隐式转换 [AUTOSAR-A4_7_1-d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A4_7_1-e.html">避免宽字段到窄字段浮点型数据的隐式转换 [AUTOSAR-A4_7_1-e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A4_7_1-f.html">避免浮点型到整型的隐式转换 [AUTOSAR-A4_7_1-f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A4_7_1-g.html">不应使用可能导致信息丢失的从整型到浮点型的隐式转换 [AUTOSAR-A4_7_1-g-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A4_7_1-h.html">避免整数溢出 [AUTOSAR-A4_7_1-h-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_0_1.html">AUTOSAR A5-0-1 在标准允许的任何求值顺序下，表达式的值应相同 [AUTOSAR-A5_0_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_0_1-a.html">不要编写依赖于函数调用求值顺序的代码 [AUTOSAR-A5_0_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_0_1-b.html">不要在两个相邻的序列点之间使用多个 volatile [AUTOSAR-A5_0_1-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_0_1-c.html">在序列点之间，对象的存储值最多只能通过表达式的计算来修改一次 [AUTOSAR-A5_0_1-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_0_1-d.html">涉及一个函数调用时，不要编写依赖表达式求值顺序的代码 [AUTOSAR-A5_0_1-d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_0_1-e.html">不要编写依赖于函数标志符和函数参数的求值顺序的代码 [AUTOSAR-A5_0_1-e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_0_1-f.html">不要编写依赖于函数参数求值顺序的代码 [AUTOSAR-A5_0_1-f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_0_1-g.html">表达式的值应该在任何标准允许的赋值顺序下是一样的 [AUTOSAR-A5_0_1-g-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_0_2.html">AUTOSAR A5-0-2 if 语句的条件和迭代语句的条件应具有布尔类型 [AUTOSAR-A5_0_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_0_2-a.html">if 语句的条件和循环语句的条件应该是布尔类型 [AUTOSAR-A5_0_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_0_3.html">AUTOSAR A5-0-3 对象声明应包含不超过两级指针间接 [AUTOSAR-A5_0_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_0_3-a.html">对象的声明应该包含不超过 2 层的指针嵌套 [AUTOSAR-A5_0_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_0_4.html">AUTOSAR A5-0-4 指针算术不应与指向非 final 类的指针一起使用 [AUTOSAR-A5_0_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_0_4-a.html">不要多形性地对待数组 [AUTOSAR-A5_0_4-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_0_4-b.html">指向派生类对象数组的指针不应转换为基类指针 [AUTOSAR-A5_0_4-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_0_4-c.html">没有处理数组为多态 [AUTOSAR-A5_0_4-c-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_10_1.html">AUTOSAR A5-10-1 指向成员虚函数的指针应只测试是否与空指针常量相等 [AUTOSAR-A5_10_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_10_1-a.html">指向成员虚函数的指针只应该被测试是否与空指针常量相等 [AUTOSAR-A5_10_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_16_1.html">AUTOSAR A5-16-1 三元条件运算符不得用作子表达式 [AUTOSAR-A5_16_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_16_1-a.html">三元运算符的条件不能是三元运算符表达式 [AUTOSAR-A5_16_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_1_1.html">AUTOSAR A5-1-1 除了类型初始化之外，不应使用字面量值，而应使用符号名称 [AUTOSAR-A5_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_1_1-a.html">避免使用幻数 [AUTOSAR-A5_1_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_1_2.html">AUTOSAR A5-1-2 不应在 lambda 表达式中隐式捕获变量 [AUTOSAR-A5_1_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_1_2-a.html">避免默认捕获模式 [AUTOSAR-A5_1_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_1_3.html">AUTOSAR A5-1-3 参数列表（可能为  null）应包含在每个 lambda 表达式中 [AUTOSAR-A5_1_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_1_3-a.html">在每个 lambda 表达式中包含一个参数列表 [AUTOSAR-A5_1_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_1_4.html">AUTOSAR A5-1-4 lambda 表达式对象不得超过任何引用捕获对象的存在时间 [AUTOSAR-A5_1_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_1_4-a.html">永远不要返回通过引用捕获本地对象的lambda [AUTOSAR-A5_1_4-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_1_4-b.html">永远不要通过引用从外部lambda捕获本地对象 [AUTOSAR-A5_1_4-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_1_4-c.html">通过引用捕获本地对象的lambda不应被赋值给有更长生命周期的变量 [AUTOSAR-A5_1_4-c-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_1_6.html">AUTOSAR A5-1-6 应该显式指定非 void 返回类型 lambda 表达式的返回类型 [AUTOSAR-A5_1_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_1_6-a.html">应该显式指定非 void 返回类型 lambda 表达式的返回类型 [AUTOSAR-A5_1_6-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_1_7.html">AUTOSAR A5-1-7 lambda 不应是 decltype 或 typeid 的操作数 [AUTOSAR-A5_1_7]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_1_7-a.html">lambda 不应是 typeid 的操作数 [AUTOSAR-A5_1_7-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_1_8.html">AUTOSAR A5-1-8 Lambda 表达式不应该在另一个 Lambda 表达式中定义 [AUTOSAR-A5_1_8]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_1_8-a.html">lambda 表达式不应该在另一个 lambda 表达式中定义 [AUTOSAR-A5_1_8-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_2_1.html">AUTOSAR A5-2-1 不应使用 dynamic_cast [AUTOSAR-A5_2_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_2_1-a.html">避免使用dynamic_casts [AUTOSAR-A5_2_1-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_2_2.html">AUTOSAR A5-2-2 不得使用传统 C 风格的强制转换 [AUTOSAR-A5_2_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_2_2-a.html">不得使用 C 语言风格的强制类型转换(除 void 强制类型转换外)和函数符号式强制类型转换(除了显式的构造函数调用外) [AUTOSAR-A5_2_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_2_3.html">AUTOSAR A5-2-3 强制转换不得从指针或引用的类型中移除任何 const 或 volatile 限定条件 [AUTOSAR-A5_2_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_2_3-a.html">强制转换不得从指针或引用类型中删除任何“const”或“volatile”限定条件 [AUTOSAR-A5_2_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_2_4.html">AUTOSAR A5-2-4 不得使用 reinterpret_cast [AUTOSAR-A5_2_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_2_4-a.html">避免使用强制类型转换符 reinterpret_cast [AUTOSAR-A5_2_4-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_2_5.html">AUTOSAR A5-2-5 不能超出其范围访问数组或容器 [AUTOSAR-A5_2_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_2_5-a.html">避免访问数组越界 [AUTOSAR-A5_2_5-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_2_5-b.html">避免访问数组和指针越界 [AUTOSAR-A5_2_5-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_2_5-c.html">一个指针操作数和使用这个操作数的指针算法所产生的任何指针都应该处理相同数组的元素 [AUTOSAR-A5_2_5-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_2_5-d.html">避免在数组索引中有受污染数据 [AUTOSAR-A5_2_5-d-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_2_6.html">AUTOSAR A5-2-6 如果操作数包含二进制运算符, 则应将逻辑运算符 &amp;&amp; 或 || 加上括弧 [AUTOSAR-A5_2_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_2_6-a.html">逻辑 '&amp;&amp;' 或 '||' 的每个操作数应该为后缀表达式 [AUTOSAR-A5_2_6-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_3_1.html">AUTOSAR A5-3-1 对 typeid 操作符的操作数求值不应包含副作用 [AUTOSAR-A5_3_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_3_1-a.html">typeid 操作符的操作数不能包含任何有副作用的表达式 [AUTOSAR-A5_3_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_3_1-b.html">'typeid' 操作符的操作数不应包含导致副作用的函数调用 [AUTOSAR-A5_3_1-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_3_2.html">AUTOSAR A5-3-2 空指针不能被解除引用 [AUTOSAR-A5_3_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_3_2-a.html">避免空指针引用 [AUTOSAR-A5_3_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_3_3.html">AUTOSAR A5-3-3 不应删除指向不完整类类型的指针 [AUTOSAR-A5_3_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_3_3-a.html">不要在删除点上时删除类不完整的对象 [AUTOSAR-A5_3_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_5_1.html">AUTOSAR A5-5-1 指向成员的指针不能访问不存在的类成员 [AUTOSAR-A5_5_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_5_1-a.html">强制类型转换不应将指向函数的指针转换为任何其他指针类型，包括指向函数类型的指针 [AUTOSAR-A5_5_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_6_1.html">AUTOSAR A5-6-1 整数除法或余数运算符的右侧操作数不应等于零 [AUTOSAR-A5_6_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A5_6_1-a.html">避免除零错误 [AUTOSAR-A5_6_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A6_2_1.html">AUTOSAR A6-2-1 移动、复制赋值运算符在没有任何副作用的情况下，应移动或分别复制类的基类和数据成员 [AUTOSAR-A6_2_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A6_2_1-a.html">拷贝赋值运算符不应有可能会影响复制对象的作用 [AUTOSAR-A6_2_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A6_2_1-b.html">移动赋值运算符不应具有可能影响移动对象的副作用 [AUTOSAR-A6_2_1-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A6_2_2.html">AUTOSAR A6-2-2 表达式语句不能只显式调用临时对象的构造函数 [AUTOSAR-A6_2_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A6_2_2-a.html">表达式语句不能只显式调用临时对象的构造函数 [AUTOSAR-A6_2_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A6_4_1.html">AUTOSAR A6-4-1 switch 语句应至少有两个 case 语句，与 default 标签不同 [AUTOSAR-A6_4_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A6_4_1-a.html">每个 switch 语句至少有两个 case 分支和一个潜在的 default 分支 [AUTOSAR-A6_4_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A6_5_1.html">AUTOSAR A6-5-1 不得使用循环遍历容器所有元素且不使用其循环计数器的 for 循环 [AUTOSAR-A6_5_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A6_5_1-a.html">将一个只使用元素值的循环实现为基于范围的循环 [AUTOSAR-A6_5_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A6_5_2.html">AUTOSAR A6-5-2 for 循环应包含一个没有浮点类型的循环计数器 [AUTOSAR-A6_5_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A6_5_2-a.html">for 循环应该包含一个没有浮动类型的单一的循环计数器 [AUTOSAR-A6_5_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A6_5_3.html">AUTOSAR A6-5-3 不应使用do语句 [AUTOSAR-A6_5_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A6_5_3-a.html">选择使用 while 而非 do 语句 [AUTOSAR-A6_5_3-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A6_5_4.html">AUTOSAR A6-5-4 init 语句和表达式不应该执行循环计数器初始化和修改以外的操作 [AUTOSAR-A6_5_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A6_5_4-a.html">除了初始化单个for循环参数的值外，for循环中的初始化表达式将不执行任何操作 [AUTOSAR-A6_5_4-a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A6_5_4-b.html">在 for 循环中的增量表达式除了改变单个循环参数到下一个值外，不应该执行其他任何操作 [AUTOSAR-A6_5_4-b-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A6_6_1.html">AUTOSAR A6-6-1 不得使用 goto 语句 [AUTOSAR-A6_6_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A6_6_1-a.html">不应该使用 goto 语句 [AUTOSAR-A6_6_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_1_1.html">AUTOSAR A7-1-1 Constexpr 或 const 说明符应用于不可变数据声明 [AUTOSAR-A7_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_1_1-a.html">尽可能将参数或局部变量声明为const [AUTOSAR-A7_1_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_1_2.html">AUTOSAR A7-1-2 应在编译时确定值是否可使用 constexpr 说明符 [AUTOSAR-A7_1_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_1_2-a.html">尽量使用 constexpr 声明常量类型变量 [AUTOSAR-A7_1_2-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_1_2-b.html">尽量使用 constexpr 声明函数 [AUTOSAR-A7_1_2-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_1_3.html">AUTOSAR A7-1-3 CV 限定符应该放在 typedef  类型或使用名称的右边 [AUTOSAR-A7_1_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_1_3-a.html">将CV限定符放在它们所应用的类型的右边 [AUTOSAR-A7_1_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_1_4.html">AUTOSAR A7-1-4 不应使用 register 关键字 [AUTOSAR-A7_1_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_1_4-a.html">不应使用'register'存储类说明符 [AUTOSAR-A7_1_4-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_1_5.html">AUTOSAR A7-1-5 除下列情况外，不得使用自动说明符：（1）声明变量具有与函数调用共返回类型相同的类型，（2）声明变量具有与非基本类型的初始化器相同的类型 ，（3）声明通用 lambda 表达式参数，（4）声明使用 trailing 返回类型语法的函数模板 [AUTOSAR-A7_1_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_1_5-a.html">不要过度使用 'auto' 说明符 [AUTOSAR-A7_1_5-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_1_6.html">AUTOSAR A7-1-6 不得使用 typedef 说明符 [AUTOSAR-A7_1_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_1_6-a.html">不能使用typedef定义类型 [AUTOSAR-A7_1_6-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_1_7.html">AUTOSAR A7-1-7 每个表达式语句和标识符声明应放在单独的行上 [AUTOSAR-A7_1_7]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_1_7-a.html">每行只允许有一条语句 [AUTOSAR-A7_1_7-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_1_7-b.html">不允许在同一行声明多个变量 [AUTOSAR-A7_1_7-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_1_7-c.html">每个变量都要在单独的声明语句中被声明 [AUTOSAR-A7_1_7-c-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_1_8.html">AUTOSAR A7-1-8 在声明中，非类型说明符应放在类型说明符之前 [AUTOSAR-A7_1_8]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_1_8-a.html">在声明中不要将类型说明符放在非类型说明符之前 [AUTOSAR-A7_1_8-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_1_9.html">AUTOSAR A7-1-9 类、结构或枚举不应在其类型的定义中声明 [AUTOSAR-A7_1_9]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_1_9-a.html">类，结构体或枚举不应该在其类型定义中被声明 [AUTOSAR-A7_1_9-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_2_1.html">AUTOSAR A7-2-1 具有枚举基础类型的表达式只能具有与枚举的枚举器相对应的值 [AUTOSAR-A7_2_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_2_1-a.html">带有枚举底层类型的表达式只能具有与枚举的枚举数相对应的值 [AUTOSAR-A7_2_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_2_2.html">AUTOSAR A7-2-2 应明确定义枚举基础类型 [AUTOSAR-A7_2_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_2_2-a.html">使用明确的枚举基础并确保它足够大以存储所有枚举器 [AUTOSAR-A7_2_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_2_3.html">AUTOSAR A7-2-3 枚举应声明为作用域枚举类 [AUTOSAR-A7_2_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_2_3-a.html">使用作用域枚举类型 [AUTOSAR-A7_2_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_2_4.html">AUTOSAR A7-2-4 在枚举中，要么（1）没有，（2）第一个或者（3）所有的枚举器应初始化 [AUTOSAR-A7_2_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_2_4-a.html">在枚举类型中，要么仅对第一个元素进行显式地初始化，要么所有元素都进行显式的初始化 [AUTOSAR-A7_2_4-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_2_5.html">AUTOSAR A7-2-5 枚举应该用来表示相关的命名常量集 [AUTOSAR-A7_2_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_2_5-a.html">Case 语句的标签应该使用枚举(enum)类型而不是使用整数类型(和常量) [AUTOSAR-A7_2_5-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_3_1.html">AUTOSAR A7-3-1 函数的所有重载在调用它的地方都是可见的 [AUTOSAR-A7_3_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_3_1-a.html">使用命名空间(using)声明来重新定义重载的函数 [AUTOSAR-A7_3_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_4_1.html">AUTOSAR A7-4-1 不得使用 asm 声明 [AUTOSAR-A7_4_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_4_1-a.html">不要使用asm声明 [AUTOSAR-A7_4_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_5_1.html">AUTOSAR A7-5-1 函数不应该返回一个对 const 引用传递参数的引用或指针 [AUTOSAR-A7_5_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_5_1-a.html">函数不应返回对 const 引用传递的指针或参数的引用 [AUTOSAR-A7_5_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_5_2.html">AUTOSAR A7-5-2 函数不得直接或间接调用自身 [AUTOSAR-A7_5_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_5_2-a.html">函数不应该直接或者间接地调用自己 [AUTOSAR-A7_5_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_6_1.html">AUTOSAR A7-6-1 用 [[noreturn]] 属性声明的函数不存在返回 [AUTOSAR-A7_6_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A7_6_1-a.html">不要从不应该返回值的函数中返回 [AUTOSAR-A7_6_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_2_1.html">AUTOSAR A8-2-1 在生命函数模板时，如果返回类型取决于参数类型，则应使用 trailing 返回类型语法 [AUTOSAR-A8_2_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_2_1-a.html">如果返回类型前面带有 'typename' 关键字，使用尾随返回类型语法 [AUTOSAR-A8_2_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_4_1.html">AUTOSAR A8-4-1 不能使用省略号表示法定义函数 [AUTOSAR-A8_4_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_4_1-a.html">避免使用有可变数量参数的函数 [AUTOSAR-A8_4_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_4_10.html">AUTOSAR A8-4-10 如果参数不能为 NULL，则通过引用传递参数 [AUTOSAR-A8_4_10]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_4_10-a.html">如果参数不能为 NULL，则通过引用传递参数 [AUTOSAR-A8_4_10-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_4_11.html">AUTOSAR A8-4-11 智能指针只有在表示生存期语义时才可以用作参数类型 [AUTOSAR-A8_4_11]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_4_11-a.html">智能指针只有在表示生存期语义时才可以用作参数类型 [AUTOSAR-A8_4_11-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_4_12.html">AUTOSAR A8-4-12 std::unique_ptr 应该作为一个函数传递: (1) 表示函数具有所有权的一个副本 (2) 表示函数替换了托管对象的一个 lvalue 引用 [AUTOSAR-A8_4_12]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_4_12-a.html">不要传递 const 引用类型的 std::unique_ptr 对象 [AUTOSAR-A8_4_12-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_4_12-b.html">智能指针只有在表示生存期语义时才可以用作参数类型 [AUTOSAR-A8_4_12-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_4_12-c.html">如果函数代替被管理的对象，参数应该只声明为对 'std::shared_ptr' 或 'std::unique_ptr' 的非 const Ivalue 引用 [AUTOSAR-A8_4_12-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_4_12-d.html">不要将参数类型声明为 'std::shared_ptr' 或 'std::unique_ptr' 的 rvalue 引用 [AUTOSAR-A8_4_12-d-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_4_13.html">AUTOSAR A8-4-13 std::shared_ptr 应作为以下传递给函数: (1) 表示函数共享所有权的副本 (2) 表示函数替换被管理对象的 lvalue 引用 (3) 表示函数保留引用计数的 const lvalue 引用 [AUTOSAR-A8_4_13]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_4_13-a.html">智能指针只有在表示生存期语义时才可以用作参数类型 [AUTOSAR-A8_4_13-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_4_13-b.html">如果函数代替被管理的对象，参数应该只声明为对 'std::shared_ptr' 或 'std::unique_ptr' 的非 const Ivalue 引用 [AUTOSAR-A8_4_13-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_4_13-c.html">不要将参数类型声明为 'std::shared_ptr' 或 'std::unique_ptr' 的 rvalue 引用 [AUTOSAR-A8_4_13-c-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_4_2.html">AUTOSAR A8-4-2 有非 void 返回类型函数的所有退出路径都应具有带表达式的显式 return 语句 [AUTOSAR-A8_4_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_4_2-a.html">非 void 返回类型的函数的所有退出路径应该有一个明确的包含表达式的返回语句 [AUTOSAR-A8_4_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_4_3.html">AUTOSAR A8-4-3 应该使用传递参数的常用方法 [AUTOSAR-A8_4_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_4_3-a.html">使用引用而非值传递对象 [AUTOSAR-A8_4_3-a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_4_3-b.html">尽可能声明引用参数为 const 引用 [AUTOSAR-A8_4_3-b-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_4_5.html">AUTOSAR A8-4-5 参数 "consume" 声明为  X &amp;&amp; 将永远被移出 [AUTOSAR-A8_4_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_4_5-a.html">Use std::move() on rvalue references and std::forward() on forwarding references [AUTOSAR-A8_4_5-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_4_6.html">AUTOSAR A8-4-6 参数 "forward" 声明为  T &amp;&amp; 总是被转发 [AUTOSAR-A8_4_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_4_6-a.html">Use std::move() on rvalue references and std::forward() on forwarding references [AUTOSAR-A8_4_6-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_4_7.html">AUTOSAR A8-4-7 应按值传递用于 "cheap to copy" 的  "in" 参数类型 [AUTOSAR-A8_4_7]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_4_7-a.html">通过值传递内置类型，除非你想要修改这些参数 [AUTOSAR-A8_4_7-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_4_7-b.html">通过值传递带有推导拷贝构造函数的小类型对象 [AUTOSAR-A8_4_7-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_4_8.html">AUTOSAR A8-4-8 不应使用输出参数 [AUTOSAR-A8_4_8]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_4_8-a.html">不得使用输出参数 [AUTOSAR-A8_4_8-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_4_9.html">AUTOSAR A8-4-9 参数 "in-out" 声明为 T &amp; 应该被修改 [AUTOSAR-A8_4_9]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_4_9-a.html">尽可能声明引用参数为 const 引用 [AUTOSAR-A8_4_9-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_5_0.html">AUTOSAR A8-5-0 所有内存在读取之前都应该初始化 [AUTOSAR-A8_5_0]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_5_0-a.html">避免在初始化之前使用 [AUTOSAR-A8_5_0-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_5_1.html">AUTOSAR A8-5-1 在初始化列表中，初始化顺序如下：（1）虚基类的深度和继承图从左到右的顺序，（2）继承列表从左到右顺序的直接基类，（3）按照在类定义中声明顺序的非静态数据成员 [AUTOSAR-A8_5_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_5_1-a.html">在初始化列表中按声明成员的顺序列出成员 [AUTOSAR-A8_5_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_5_2.html">AUTOSAR A8-5-2 没有等号标记的大括号形式初始化 {}，应用于变量初始化 [AUTOSAR-A8_5_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_5_2-a.html">带括号但不带等号的初始化{}，应用于变量的初始化 [AUTOSAR-A8_5_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_5_3.html">AUTOSAR A8-5-3 不应使用 {} 或 ={} 大括号的初始化形式初始化自动类型的变量 [AUTOSAR-A8_5_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A8_5_3-a.html">不应使用 '{}' 或 '= {}' 括号初始化来初始化 auto 类型的变量 [AUTOSAR-A8_5_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A9_3_1.html">AUTOSAR A9-3-1 成员函数不得返回非 const 的 'raw' 指针或对类所拥有的 private 或 protected 数据的引用 [AUTOSAR-A9_3_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A9_3_1-a.html">公共成员函数不应该返回指向私有的/受保护的类数据的非常量句柄 [AUTOSAR-A9_3_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A9_3_1-b.html">受保护(Protected)的成员函数不得返回指向私有类数据的非 const 句柄(指针或引用) [AUTOSAR-A9_3_1-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A9_5_1.html">AUTOSAR A9-5-1 不得使用Unions [AUTOSAR-A9_5_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A9_5_1-a.html">禁止使用联合体 [AUTOSAR-A9_5_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A9_5_1-b.html">禁止使用联合体 [AUTOSAR-A9_5_1-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A9_6_1.html">AUTOSAR A9-6-1 用于与硬件接口或符合通信协议的数据类型应该是无关紧要的、标准布局的, 并且只包含具有定义大小的类型的成员 [AUTOSAR-A9_6_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A9_6_1-a.html">只能将位域定义为有符号的整型或无符号的整型 [AUTOSAR-A9_6_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A9_6_2.html">AUTOSAR A9-6-2 位域应仅在与硬件接口或符合通信协议时使用 [AUTOSAR-A9_6_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-A9_6_2-a.html">不要将成员变量声明为位域 [AUTOSAR-A9_6_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_1.html">AUTOSAR M0-1-1 项目不得包含无法访问的代码 [AUTOSAR-M0_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_1-a.html">在 "if/else/while/for" 语句块中不应存在执行不到的代码 [AUTOSAR-M0_1_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_1-b.html">在 'return', 'break', 'continue', 和 'goto' 语句之后不应存在执行不到的代码 [AUTOSAR-M0_1_1-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_1-c.html">在 "else" 语句块中不应存在执行不到的代码 [AUTOSAR-M0_1_1-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_1-d.html">在 while/for/do...while 循环内的 "if" 或 "switch" 语句后不应存在执行不到的代码 [AUTOSAR-M0_1_1-d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_1-e.html">在 'if' 或 'switch' 语句后不应存在不可访问的代码 [AUTOSAR-M0_1_1-e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_1-f.html">在 'for' 循环中不应存在执行不到的代码 [AUTOSAR-M0_1_1-f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_1-g.html">在 switch 语句中不应存在执行不到的代码 [AUTOSAR-M0_1_1-g-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_10.html">AUTOSAR M0-1-10 每个定义的函数至少应调用一次 [AUTOSAR-M0_1_10]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_10-a.html">每个定义的具有外部连接的函数应该被至少使用一次 [AUTOSAR-M0_1_10-a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_10-b.html">每个定义的具有内部链接的函数应该至少被使用一次 [AUTOSAR-M0_1_10-b-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_2.html">AUTOSAR M0-1-2 项目不得包含不可行的路径 [AUTOSAR-M0_1_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_2-a.html">不允许其结果是不变的布尔运算 [AUTOSAR-M0_1_2-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_2-aa.html">不允许其结果是不变的布尔运算 [AUTOSAR-M0_1_2-aa-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_2-ab.html">不允许其结果是不变的布尔运算 [AUTOSAR-M0_1_2-ab-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_2-b.html">不允许其结果是不变的布尔运算 [AUTOSAR-M0_1_2-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_2-c.html">不允许其结果是不变的布尔运算 [AUTOSAR-M0_1_2-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_2-d.html">不允许其结果是不变的布尔运算 [AUTOSAR-M0_1_2-d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_2-e.html">不允许其结果是不变的布尔运算 [AUTOSAR-M0_1_2-e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_2-f.html">不允许其结果是不变的布尔运算 [AUTOSAR-M0_1_2-f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_2-g.html">不允许其结果是不变的布尔运算 [AUTOSAR-M0_1_2-g-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_2-h.html">不允许其结果是不变的布尔运算 [AUTOSAR-M0_1_2-h-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_2-i.html">不允许其结果是不变的布尔运算 [AUTOSAR-M0_1_2-i-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_2-j.html">不允许其结果是不变的布尔运算 [AUTOSAR-M0_1_2-j-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_2-k.html">包含枚举的条件始终为 'true' 或 'false' [AUTOSAR-M0_1_2-k-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_2-l.html">不允许其结果是不变的布尔运算 [AUTOSAR-M0_1_2-l-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_2-m.html">不允许其结果是不变的布尔运算 [AUTOSAR-M0_1_2-m-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_2-n.html">不允许其结果是不变的布尔运算 [AUTOSAR-M0_1_2-n-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_2-o.html">不允许其结果是不变的布尔运算 [AUTOSAR-M0_1_2-o-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_2-p.html">不允许其结果是不变的布尔运算 [AUTOSAR-M0_1_2-p-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_2-q.html">不允许其结果是不变的布尔运算 [AUTOSAR-M0_1_2-q-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_2-r.html">不允许其结果是不变的布尔运算 [AUTOSAR-M0_1_2-r-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_2-s.html">不允许其结果是不变的布尔运算 [AUTOSAR-M0_1_2-s-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_2-t.html">不允许其结果是不变的布尔运算 [AUTOSAR-M0_1_2-t-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_2-u.html">不允许其结果是不变的布尔运算 [AUTOSAR-M0_1_2-u-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_2-v.html">不允许其结果是不变的布尔运算 [AUTOSAR-M0_1_2-v-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_2-w.html">不允许其结果是不变的布尔运算 [AUTOSAR-M0_1_2-w-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_2-x.html">不允许其结果是不变的布尔运算 [AUTOSAR-M0_1_2-x-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_2-y.html">不允许其结果是不变的布尔运算 [AUTOSAR-M0_1_2-y-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_2-z.html">不允许其结果是不变的布尔运算 [AUTOSAR-M0_1_2-z-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_3.html">AUTOSAR M0-1-3 项目不得包含未使用的变量 [AUTOSAR-M0_1_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_3-a.html">避免使用不必要的局部变量 [AUTOSAR-M0_1_3-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_3-b.html">避免使用不必要的局部变量 [AUTOSAR-M0_1_3-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_4.html">AUTOSAR M0-1-4 项目不得包含只有一次使用的非volatile POD变量 [AUTOSAR-M0_1_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_4-a.html">项目不应包含只有一个用途的非 volatile POD变量 [AUTOSAR-M0_1_4-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_8.html">AUTOSAR M0-1-8 有 void 返回类型的所有函数都应有外部副作用 [AUTOSAR-M0_1_8]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_8-a.html">所有具有 viod 返回类型的非空函数应该具有外部作用 [AUTOSAR-M0_1_8-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_8-b.html">具有 void 返回值类型的函数不能为空 [AUTOSAR-M0_1_8-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_9.html">AUTOSAR M0-1-9 不得有无用代码 [AUTOSAR-M0_1_9]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_1_9-a.html">所有非 null 语句应该至少有一个执行或者导致控制流变化的附加作用 [AUTOSAR-M0_1_9-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_2_1.html">AUTOSAR M0-2-1 不应将对象赋值给重叠对象 [AUTOSAR-M0_2_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_2_1-a.html">结构体的每个成员不应该赋值给自己的其他成员变量 [AUTOSAR-M0_2_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_2_1-b.html">对象不能赋值给一个重叠的对象 [AUTOSAR-M0_2_1-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_3_1.html">AUTOSAR M0-3-1 运行时故障的最小化应通过至少使用以下之一来确保：（a）静态分析工具/技术; （b）动态分析工具/技术; （c）显式编码检查以处理运行时故障 [AUTOSAR-M0_3_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_3_1-a.html">只有指向数组或数组元素地址的指针才能进行指针运算 [AUTOSAR-M0_3_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_3_1-b.html">避免写入缓冲区时导致的溢出 [AUTOSAR-M0_3_1-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_3_1-c.html">&gt;, &gt;=, &lt;, &lt;= 不应用于指针类型，除非它们指向相同的数组 [AUTOSAR-M0_3_1-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_3_1-d.html">避免访问数组越界 [AUTOSAR-M0_3_1-d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_3_1-e.html">避免除零错误 [AUTOSAR-M0_3_1-e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_3_1-f.html">避免空指针引用 [AUTOSAR-M0_3_1-f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_3_1-g.html">避免由于读取非零终止字符串导致的溢出 [AUTOSAR-M0_3_1-g-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_3_1-h.html">避免由于定义不正确的格式限制导致的缓冲区溢出 [AUTOSAR-M0_3_1-h-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_3_1-i.html">避免读取缓冲区时导致的溢出 [AUTOSAR-M0_3_1-i-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_3_1-j.html">避免在引用之后再检查空(null) [AUTOSAR-M0_3_1-j-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_3_2.html">AUTOSAR M0-3-2 如果函数生成错误信息，则应测试该错误信息 [AUTOSAR-M0_3_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_3_2-a.html">如果函数返回错误信息，该错误信息必须经过测试 [AUTOSAR-M0_3_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_4_2.html">AUTOSAR M0-4-2 应记录浮点运算的使用 [AUTOSAR-M0_4_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M0_4_2-a.html">使用浮点运算应该被注释说明 [AUTOSAR-M0_4_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M10_1_1.html">AUTOSAR M10-1-1 类不应从虚基础派生 [AUTOSAR-M10_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M10_1_1-a.html">类不能从虚拟基类型中衍生 [AUTOSAR-M10_1_1-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M10_1_2.html">AUTOSAR M10-1-2 在 diamond hierarchy 中使用基类时，只应将其声明为 virtual [AUTOSAR-M10_1_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M10_1_2-a.html">基类只有在菱形继承层级中使用时才会被声明为虚类 [AUTOSAR-M10_1_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M10_1_3.html">AUTOSAR M10-1-3 可访问的基类在同一层次结构中不应同时为virtual和非virtual [AUTOSAR-M10_1_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M10_1_3-a.html">在同一层次结构中，基类不能同时具有虚拟及非虚拟的属性 [AUTOSAR-M10_1_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M10_2_1.html">AUTOSAR M10-2-1 多继承层次结构中的所有可访问实体名称都应该是唯一的 [AUTOSAR-M10_2_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M10_2_1-a.html">多重继承层次中可访问的实例名必须独一无二 [AUTOSAR-M10_2_1-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M10_3_3.html">AUTOSAR M10-3-3 如果虚函数本身被声明为纯虚函数，则它只能被纯虚函数重写 [AUTOSAR-M10_3_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M10_3_3-a.html">虚拟函数仅能被自身声明为纯虚拟的纯虚拟函数进行覆盖 [AUTOSAR-M10_3_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M11_0_1.html">AUTOSAR M11-0-1 非 POD 类类型的成员数据应为 private [AUTOSAR-M11_0_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M11_0_1-a.html">非 POD 类型的成员数据应该为 &nbsp;private 类型 [AUTOSAR-M11_0_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M12_1_1.html">AUTOSAR M12-1-1 不得在其构造函数或析构函数的主体中使用对象的动态类型 [AUTOSAR-M12_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M12_1_1-a.html">对象的动态类型不能够从它的构造函数和析构函数的函数体中使用 [AUTOSAR-M12_1_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M14_5_3.html">AUTOSAR M14-5-3 当模板赋值运算符的参数是 generic 参数时，应声明复制赋值运算符 [AUTOSAR-M14_5_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M14_5_3-a.html">存在一个包含泛型参数的模板赋值运算符时，拷贝赋值运算符应该被声明 [AUTOSAR-M14_5_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M14_6_1.html">AUTOSAR M14-6-1 在有从属基础的类模板中，任何可能在该从属基础中找到的名称都应使用qualified-id或this-&gt;来引用。 [AUTOSAR-M14_6_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M14_6_1-a.html">在含有依赖基础的类模板中，任何可能在这个依赖类中被发现的名称都应该引用使用限定标识（qualified-id）或 -&gt; [AUTOSAR-M14_6_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M15_0_3.html">AUTOSAR M15-0-3 控制不应使用 goto 或 switch 语句转移到 try 或 catch 块中 [AUTOSAR-M15_0_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M15_0_3-a.html">不得使用 goto 或 switch 开关语句将控制传递到 try 或 catch 模块中 [AUTOSAR-M15_0_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M15_1_1.html">AUTOSAR M15-1-1 throw语句的赋值表达式本身不会导致抛出异常 [AUTOSAR-M15_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M15_1_1-a.html">throw 语句的赋值表达式不得自身引起一个异常抛出 [AUTOSAR-M15_1_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M15_1_2.html">AUTOSAR M15-1-2 不应明确抛出 NULL [AUTOSAR-M15_1_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M15_1_2-a.html">NULL 不得被显式地抛出 [AUTOSAR-M15_1_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M15_1_3.html">AUTOSAR M15-1-3 null 的 throw (throw;)只能在 catch 处理程序的复合语句中使用 [AUTOSAR-M15_1_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M15_1_3-a.html">空抛出(throw;)只能用于catch处理程序的复合语句中 [AUTOSAR-M15_1_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M15_3_1.html">AUTOSAR M15-3-1 只能在启动后和终止前抛出异常 [AUTOSAR-M15_3_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M15_3_1-a.html">只有在程序启动后和终止前才会出现异常情况 [AUTOSAR-M15_3_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M15_3_3.html">AUTOSAR M15-3-3 类构造函数或析构函数的 function-try-block 实现的处理程序不应引用此类或其基类的非静态成员 [AUTOSAR-M15_3_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M15_3_3-a.html">以 function-try-block 实现的类构造函数或析构函数的处理程序不应引用该类或其基类的非静态成员 [AUTOSAR-M15_3_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M15_3_4.html">AUTOSAR M15-3-4 代码中显式抛出的每个异常在所有可能导致这一点的调用路径中都应该有一个兼容类型的处理程序 [AUTOSAR-M15_3_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M15_3_4-a.html">在全局或命名空间作用域中调用的函数不能抛出未处理的异常 [AUTOSAR-M15_3_4-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M15_3_4-b.html">在代码中显式抛出的每个异常，在所有可能导致这一点的调用路径中都应该有一个兼容类型的处理程序 [AUTOSAR-M15_3_4-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M15_3_6.html">AUTOSAR M15-3-6 在一个派生类的 try-catch 语句或 function-try 块中提供了多个处理程序，并且为其部分或全部基类提供了这些处理程序 [AUTOSAR-M15_3_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M15_3_6-a.html">如果在一个 try-catch 语句或函数 try-block 中为派生类及其部分或全部基类提供多个处理程序，则应将派生程度最高的处理程序排序为派生程度最高的基类 [AUTOSAR-M15_3_6-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M15_3_7.html">AUTOSAR M15-3-7 如果在一个 try-catch 语句或 function-try-block 中提供多个处理程序，那么任何省略号（catch-all）处理程序都应最后执行 [AUTOSAR-M15_3_7]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M15_3_7-a.html">如果在 'try-catch' 语句或 'function-try-block' 中提供了多个处理程序，那么任何省略(catch-all)处理程序都应该是最后一个 [AUTOSAR-M15_3_7-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M16_0_1.html">AUTOSAR M16-0-1 # 在文件中包含指令前必须有其他预处理指令或注释 [AUTOSAR-M16_0_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M16_0_1-a.html">#include 之前只允许有预处理命令和注释 [AUTOSAR-M16_0_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M16_0_2.html">AUTOSAR M16-0-2 宏只能在全局命名空间中被#define或#undef [AUTOSAR-M16_0_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M16_0_2-a.html">禁止在块中使用 #define 或 #undef [AUTOSAR-M16_0_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M16_0_5.html">AUTOSAR M16-0-5 类函数宏的参数不应包含类似预处理指令的标记 [AUTOSAR-M16_0_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M16_0_5-a.html">类似函数的宏的参数不应该包含类似预处理命令的标识 [AUTOSAR-M16_0_5-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M16_0_6.html">AUTOSAR M16-0-6 在类函数宏的定义中，参数的每个实例都应该括在括号中，除非它被用作#或##的操作数1 [AUTOSAR-M16_0_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M16_0_6-a.html">在函数式宏定义中，每个参数的实例应该被括号括起来，除非它被用于 # 或 ## 操作符 [AUTOSAR-M16_0_6-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M16_0_7.html">AUTOSAR M16-0-7 在 #if 或 #elif 预处理器指令中不应使用未定义的宏标识符，除非作为已定义运算符的操作数 [AUTOSAR-M16_0_7]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M16_0_7-a.html">不要使用在编译单元中未定义的预编译器指令 #if 和 #elif &nbsp;宏 [AUTOSAR-M16_0_7-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M16_0_8.html">AUTOSAR M16-0-8 如果 # 作为第一个标记出现在一行中，那么它应该紧跟在预处理标记之后 [AUTOSAR-M16_0_8]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M16_0_8-a.html">预处理指令即使被预处理器排除也必须有语法意义 [AUTOSAR-M16_0_8-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M16_1_1.html">AUTOSAR M16-1-1 所定义的预处理器运算符只能用于两种标准格式之一 [AUTOSAR-M16_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M16_1_1-a.html">预处理操作符只能用在两种标准格式之一 [AUTOSAR-M16_1_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M16_1_2.html">AUTOSAR M16-1-2 所有的 #else、 #elif 和 #endif 预处理器指令应该与它们相关的 #if 或 #ifdef 指令存留在同一个文件中 [AUTOSAR-M16_1_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M16_1_2-a.html">在同一个文件中 #else, #elif 和 #endif 必须对应有 #if 或 #ifdef 预处理指令 [AUTOSAR-M16_1_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M16_2_3.html">AUTOSAR M16-2-3 应提供 Include guards [AUTOSAR-M16_2_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M16_2_3-a.html">使用多个包含保护 [AUTOSAR-M16_2_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M16_3_1.html">AUTOSAR M16-3-1 在单个宏定义中最多只能出现一个 # 或 ## 操作符 [AUTOSAR-M16_3_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M16_3_1-a.html">禁止宏定义中使用多个 # 和 ## [AUTOSAR-M16_3_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M16_3_2.html">AUTOSAR M16-3-2 不应该使用 # 和 ## 操作符 [AUTOSAR-M16_3_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M16_3_2-a.html">禁止使用预处理操作符 # 和 ## [AUTOSAR-M16_3_2-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M17_0_2.html">AUTOSAR M17-0-2 标准库宏和对象的名称不能重复使用 [AUTOSAR-M17_0_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M17_0_2-a.html">标准库宏和对象的名称不得被重用 [AUTOSAR-M17_0_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M17_0_3.html">AUTOSAR M17-0-3 标准库函数的名称不应被重写 [AUTOSAR-M17_0_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M17_0_3-a.html">标准库函数的名称不应被重写 [AUTOSAR-M17_0_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M17_0_5.html">AUTOSAR M17-0-5 不应使用 setjmp 宏和 longjmp 函数 [AUTOSAR-M17_0_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M17_0_5-a.html">不使用 setjmp 宏和 longjmp 函数 [AUTOSAR-M17_0_5-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M18_0_3.html">AUTOSAR M18-0-3 不应使用 <cstdlib> 库中的库函数abort, exit, getenv 和 system [AUTOSAR-M18_0_3]</cstdlib></a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M18_0_3-a.html">不得使用 'stdlib.h' 或 'cstdlib' 库中的 'abort()' 函数 [AUTOSAR-M18_0_3-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M18_0_3-b.html">不得使用 'stdlib.h' &nbsp;或 'cstdlib' 库中的 'exit()' 函数 [AUTOSAR-M18_0_3-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M18_0_3-c.html">不得使用 'stdlib.h' 或 'cstdlib' 库中的 'system()' 函数 [AUTOSAR-M18_0_3-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M18_0_3-d.html">不得使用 'stdlib.h' 或 'cstdlib' 库中的 'getenv()' 函数 [AUTOSAR-M18_0_3-d-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M18_0_4.html">AUTOSAR M18-0-4 不应使用 <ctime> 库的时间处理函数 [AUTOSAR-M18_0_4]</ctime></a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M18_0_4-a.html">禁止使用库文件 time.h 中的时间处理库函数 [AUTOSAR-M18_0_4-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M18_0_5.html">AUTOSAR M18-0-5 不应使用 <cstring> 库中的无界函数 [AUTOSAR-M18_0_5]</cstring></a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M18_0_5-a.html">不得使用库 &lt;cstring&gt; 的无界函数 [AUTOSAR-M18_0_5-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M18_2_1.html">AUTOSAR M18-2-1 不得使用宏 offsetof [AUTOSAR-M18_2_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M18_2_1-a.html">不应该使用库文件 stddef.h 中的 offsetof 宏 [AUTOSAR-M18_2_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M18_7_1.html">AUTOSAR M18-7-1 不应使用 <csignal> 中的信号处理设备 [AUTOSAR-M18_7_1]</csignal></a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M18_7_1-a.html">禁止使用信号处理文件 &lt;signal.h&gt; 中的处理函数 [AUTOSAR-M18_7_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M18_7_1-b.html">禁止使用标准库文件 &lt;signal.h&gt; 中的处理函数 [AUTOSAR-M18_7_1-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M19_3_1.html">AUTOSAR M19-3-1 不应使用系统错误代码指示器 [AUTOSAR-M19_3_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M19_3_1-a.html">不得使用错误指示 'errno' [AUTOSAR-M19_3_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M27_0_1.html">AUTOSAR M27-0-1 不得使用流输入/输出库 <cstdio> [AUTOSAR-M27_0_1]</cstdio></a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M27_0_1-a.html">禁止使用库文件 stdio.h 中的输入/输出函数 [AUTOSAR-M27_0_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M2_10_1.html">AUTOSAR M2-10-1 不同的标识符应明确排版 [AUTOSAR-M2_10_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M2_10_1-a.html">不同的标识符应该是书写明确的 [AUTOSAR-M2_10_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M2_13_2.html">AUTOSAR M2-13-2 八进制常数(除了零)和八进制转义序列(除了 "\0")不得使用 [AUTOSAR-M2_13_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M2_13_2-a.html">不应该使用八进制常数（除零外） [AUTOSAR-M2_13_2-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M2_13_2-b.html">八进制转义序列不应该被使用 [AUTOSAR-M2_13_2-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M2_13_3.html">AUTOSAR M2-13-3 一个 "U"后缀应用于所有无符号类型的八进制或十六进制整数 [AUTOSAR-M2_13_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M2_13_3-a.html">后缀 "U" 应该适用于所有无符号类型的八进制或十六进制整型字面量 [AUTOSAR-M2_13_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M2_13_4.html">AUTOSAR M2-13-4 文字后缀应该是大写字母 [AUTOSAR-M2_13_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M2_13_4-a.html">字母后缀应使用大写字母而不是小写字母 [AUTOSAR-M2_13_4-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M2_7_1.html">AUTOSAR M2-7-1 字符序列  /* 不能在 C 风格的注释中使用 [AUTOSAR-M2_7_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M2_7_1-a.html">禁止在 C 语言风格的注释中使用 /* 字符序列 [AUTOSAR-M2_7_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M3_1_2.html">AUTOSAR M3-1-2 不能在块范围内声明函数 [AUTOSAR-M3_1_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M3_1_2-a.html">在文件的范围内声明函数 [AUTOSAR-M3_1_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M3_2_1.html">AUTOSAR M3-2-1 对象或函数的所有声明都应该具有兼容的类型 [AUTOSAR-M3_2_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M3_2_1-a.html">所有对象或函数的声明应该有匹配的类型 [AUTOSAR-M3_2_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M3_2_2.html">AUTOSAR M3-2-2 不能违反唯一定义规则 [AUTOSAR-M3_2_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M3_2_2-a.html">单个定义规则不应该被违反 [AUTOSAR-M3_2_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M3_2_3.html">AUTOSAR M3-2-3 在多个转换单元中使用的类型、对象或函数应在一个且仅一个文件中声明 [AUTOSAR-M3_2_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M3_2_3-a.html">在多个翻译单元中使用的类型，对象或函数应该只能在一个文件中声明 [AUTOSAR-M3_2_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M3_2_4.html">AUTOSAR M3-2-4 带有外部链接的标识符应该只有一个定义 [AUTOSAR-M3_2_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M3_2_4-a.html">External链接的标识符应该只能有一个外部定义 [AUTOSAR-M3_2_4-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M3_3_2.html">AUTOSAR M3-3-2 如果一个函数有内部链接，那么所有的重新声明都应该包括静态存储类说明符 [AUTOSAR-M3_3_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M3_3_2-a.html">如果一个函数有内部链接，那么所有的重新声明应该包括静态(static)存储类的说明符 [AUTOSAR-M3_3_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M3_4_1.html">AUTOSAR M3-4-1 声明为对象或类型的标识符应在块中定义，以最小化其可见性 [AUTOSAR-M3_4_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M3_4_1-a.html">尽可能地声明局部化的变量 [AUTOSAR-M3_4_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M3_4_1-b.html">如果对象只在一个单独的函数中访问那么应定义其在代码块范围 [AUTOSAR-M3_4_1-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M3_9_1.html">AUTOSAR M3-9-1 用于对象、函数返回类型或函数参数的类型在所有声明和重新声明中都应该是 token-for-token 完全一致的 [AUTOSAR-M3_9_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M3_9_1-a.html">用于对象，函数返回类型，或函数参数的类型在所有声明和重新声明中应该对应完全相同 [AUTOSAR-M3_9_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M3_9_3.html">AUTOSAR M3-9-3 不应使用浮点值的底层位表示 [AUTOSAR-M3_9_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M3_9_3-a.html">禁止对浮点数值进行位操作 [AUTOSAR-M3_9_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M4_10_1.html">AUTOSAR M4-10-1 NULL不能用作整数值 [AUTOSAR-M4_10_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M4_10_1-a.html">NULL 不得用作一个整数值 [AUTOSAR-M4_10_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M4_10_2.html">AUTOSAR M4-10-2 文字零(0)不能用作空指针间常数 [AUTOSAR-M4_10_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M4_10_2-a.html">字面量零 (0) 不得用作空指针常量 (null-pointer-constant) [AUTOSAR-M4_10_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M4_5_1.html">AUTOSAR M4-5-1 除了赋值运算符=、逻辑运算符 &amp;&amp;, ||, !、等式运算符==和!=、一元运算符 &amp; 和条件运算符外，带有 bool 类型的表达式不能用作内置运算符的操作数 [AUTOSAR-M4_5_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M4_5_1-a.html">有效布尔值的表达式不应该用作除 (&amp;&amp;, ||, !, =, ==, !=, ?:) 之外的运算符的操作数。 [AUTOSAR-M4_5_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M4_5_3.html">AUTOSAR M4-5-3 除了赋值运算符=、等式运算符==和!=以及一元运算符 &amp; 外，带有(普通) char 和 wchar_t 类型的表达式不能用作内置运算符的操作数 [AUTOSAR-M4_5_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M4_5_3-a.html">带有类型(普通) char 和 wchar_t 的表达式不能作为内建运算符的操作数，除了 =, ==, != 和一元 &amp; 运算符 [AUTOSAR-M4_5_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_10.html">AUTOSAR M5-0-10 如果将位操作符 ~ 和 &lt;&lt;应用于无符号字符或无符号短整型的操作数，则结果应立即转换为操作数的底层类型 [AUTOSAR-M5_0_10]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_10-a.html">如果对无符号字符型或无符号短整型进行 ~ &nbsp;和 &lt;&lt; 位运算后，其结果应立即强制转换成操作数的基本类型 [AUTOSAR-M5_0_10-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_11.html">AUTOSAR M5-0-11 普通字符类型只能用于存储和使用字符值 [AUTOSAR-M5_0_11]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_11-a.html">普通字符(plain char)类型只能用于存储和使用字符值 [AUTOSAR-M5_0_11-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_12.html">AUTOSAR M5-0-12 有符号字符和无符号字符类型只能用于存储和使用数值 [AUTOSAR-M5_0_12]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_12-a.html">带符号的 char 和 不带符号的 char 类型只能用于存储和数值类型 [AUTOSAR-M5_0_12-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_14.html">AUTOSAR M5-0-14 条件运算符的第一个操作数应该具有布尔类型 [AUTOSAR-M5_0_14]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_14-a.html">条件运算符的第一个操作数应该具有布尔类型 [AUTOSAR-M5_0_14-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_15.html">AUTOSAR M5-0-15 数组索引应该是指针算法的唯一形式 [AUTOSAR-M5_0_15]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_15-a.html">只有数组索引才能进行算术指针操作 [AUTOSAR-M5_0_15-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_16.html">AUTOSAR M5-0-16 指针操作数和使用该操作数的指针算术产生的任何指针都应同时访问同一数组的元素 [AUTOSAR-M5_0_16]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_16-a.html">避免访问数组越界 [AUTOSAR-M5_0_16-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_16-b.html">一个指针操作数和使用这个操作数的指针算法所产生的任何指针都应该处理相同数组的元素 [AUTOSAR-M5_0_16-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_17.html">AUTOSAR M5-0-17 指针之间的减法只适用于处理相同数组元素的指针 [AUTOSAR-M5_0_17]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_17-a.html">只有指向数组或数组元素地址的指针才能进行指针运算 [AUTOSAR-M5_0_17-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_18.html">AUTOSAR M5-0-18 &gt;, &gt;=, &lt;, &lt;= 不应用于指针类型的对象，除非它们指向同一个数组 [AUTOSAR-M5_0_18]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_18-a.html">&gt;, &gt;=, &lt;, &lt;= 不应用于指针类型，除非它们指向相同的数组 [AUTOSAR-M5_0_18-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_2.html">AUTOSAR M5-0-2 在表达式中，对 c++ 运算符优先规则的依赖是有限的 [AUTOSAR-M5_0_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_2-a.html">谨慎使用 C 语言中表达式的优先运算规则 [AUTOSAR-M5_0_2-a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_2-b.html">谨慎使用 C 语言中表达式的优先运算规则 [AUTOSAR-M5_0_2-b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_2-c.html">一元运算符的操作数不需要括号 [AUTOSAR-M5_0_2-c-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_2-d.html">谨慎使用 C 语言中表达式的优先运算规则 [AUTOSAR-M5_0_2-d-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_2-e.html">除非表达式中的所有运算符都相同，否则使用圆括号 [AUTOSAR-M5_0_2-e-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_2-f.html">谨慎使用 C 语言中表达式的优先运算规则 [AUTOSAR-M5_0_2-f-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_20.html">AUTOSAR M5-0-20 二进制位操作符的非常数操作数应该具有相同的基础类型 [AUTOSAR-M5_0_20]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_20-a.html">二进制位运算符的非常量的操作数应该具有相同的基本类型 [AUTOSAR-M5_0_20-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_21.html">AUTOSAR M5-0-21 位操作符只能应用于无符号基础类型的操作数 [AUTOSAR-M5_0_21]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_21-a.html">位运算符应只适用于无符号的基本类型操作数 [AUTOSAR-M5_0_21-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_3.html">AUTOSAR M5-0-3 cvalue 表达式不能隐式转换为不同的基础类型 [AUTOSAR-M5_0_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_3-a.html">避免隐式的复合表达式的类型转换 [AUTOSAR-M5_0_3-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_3-b.html">避免隐式的复合表达式的数据类型转换 [AUTOSAR-M5_0_3-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_3-c.html">避免隐式的复合表达式的数据类型转换 [AUTOSAR-M5_0_3-c-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_4.html">AUTOSAR M5-0-4 隐式积分转换不能改变基础类型的符号 [AUTOSAR-M5_0_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_4-a.html">避免隐式的无符号整型和有符号整型的转换 [AUTOSAR-M5_0_4-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_4-b.html">避免无符号整型和有符号整型之间隐式地转换 [AUTOSAR-M5_0_4-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_5.html">AUTOSAR M5-0-5 不应该有隐含的浮点-积分转换 [AUTOSAR-M5_0_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_5-a.html">避免隐式的整型和浮点类型的转换 [AUTOSAR-M5_0_5-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_5-b.html">避免浮点型到整型的隐式转换 [AUTOSAR-M5_0_5-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_6.html">AUTOSAR M5-0-6 隐式积分或浮点数转换不能减少基础类型的大小 [AUTOSAR-M5_0_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_6-a.html">避免从更宽到更窄的类型的隐式转换 [AUTOSAR-M5_0_6-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_6-b.html">避免宽字段到窄字段浮点型数据的隐式转换 [AUTOSAR-M5_0_6-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_6-c.html">避免将浮点数从较宽的浮点类型隐式转换为较窄的浮点类型 [AUTOSAR-M5_0_6-c-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_7.html">AUTOSAR M5-0-7 cvalue表达式不应有显式的浮点-积分转换 [AUTOSAR-M5_0_7]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_7-a.html">浮点类型的复杂表达式的值只能转换为精度较低的浮点类型 [AUTOSAR-M5_0_7-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_7-b.html">整型复合表达式的值只能被强制转换到较短的类型，或者与该表达式类型相同的有符号类型 [AUTOSAR-M5_0_7-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_8.html">AUTOSAR M5-0-8 显式积分或浮点数转换不应增加 cvalue 表达式的基础类型的大小 [AUTOSAR-M5_0_8]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_8-a.html">整型复合表达式的值只能被强制转换到较短的类型，或者与该表达式类型相同的有符号类型 [AUTOSAR-M5_0_8-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_9.html">AUTOSAR M5-0-9 显式积分转换不应改变cvalue表达式的基础类型的符号 [AUTOSAR-M5_0_9]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_0_9-a.html">整型复合表达式的值只能被强制转换到较短的类型，或者与该表达式类型相同的有符号类型 [AUTOSAR-M5_0_9-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_14_1.html">AUTOSAR M5-14-1 逻辑运算符 &amp;&amp;||的右操作数不应包含副作用 [AUTOSAR-M5_14_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_14_1-a.html">逻辑&amp;&amp;或||运算符的右操作数不得含有副作用 [AUTOSAR-M5_14_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_17_1.html">AUTOSAR M5-17-1 保留二进制运算符及其赋值运算符形式之间的语义等价性 [AUTOSAR-M5_17_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_17_1-a.html">二进制过载操作符应该用其对应的复合赋值运算符实现 [AUTOSAR-M5_17_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_18_1.html">AUTOSAR M5-18-1 不应使用逗号操作符 [AUTOSAR-M5_18_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_18_1-a.html">不应该使用逗号运算符 [AUTOSAR-M5_18_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_19_1.html">AUTOSAR M5-19-1 常量无符号整数表达式的计算不应导致环绕 [AUTOSAR-M5_19_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_19_1-a.html">'&lt;&lt;' 运算符常量表达式中的整数溢出或下溢 [AUTOSAR-M5_19_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_19_1-b.html">'+'， '-'， '*' 运算符常量表达式中的整数溢出或下溢 [AUTOSAR-M5_19_1-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_2_10.html">AUTOSAR M5-2-10 在表达式中，递增(++)和递减(--) 运算符不应与其他运算符混用 [AUTOSAR-M5_2_10]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_2_10-a.html">禁止在同一个表达式中混合使用递加符 (++) 和递减符 (--) 与其他运算符 [AUTOSAR-M5_2_10-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_2_11.html">AUTOSAR M5-2-11 逗号操作符、 &amp;&amp;操作符和||操作符不得重载 [AUTOSAR-M5_2_11]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_2_11-a.html">避免重载逗号运算符 "," [AUTOSAR-M5_2_11-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_2_11-b.html">避免重载逻辑操作符AND, OR (&amp;&amp;, ||) [AUTOSAR-M5_2_11-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_2_12.html">AUTOSAR M5-2-12 作为函数参数传递的数组类型的标识符不应衰减为指针 [AUTOSAR-M5_2_12]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_2_12-a.html">作为函数实参传递的数组类型标识符不得退化为一个指针 [AUTOSAR-M5_2_12-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_2_2.html">AUTOSAR M5-2-2 指向虚拟基类的指针只能通过 dynamic_cast 转换为指向派生类的指针 [AUTOSAR-M5_2_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_2_2-a.html">指向虚拟基类型的指针只能通过dynamic_cast的方式转换为指向其衍生类的指针 [AUTOSAR-M5_2_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_2_3.html">AUTOSAR M5-2-3 从基类到派生类的转换不应该在多态类型上执行 [AUTOSAR-M5_2_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_2_3-a.html">禁止对多态类型进行从基类型到衍生类的强制类型转换 [AUTOSAR-M5_2_3-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_2_6.html">AUTOSAR M5-2-6 强制类型转换不应将指向函数的指针转换为任何其他指针类型，包括指向函数类型的指针 [AUTOSAR-M5_2_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_2_6-a.html">强制类型转换不应将指向函数的指针转换为任何其他指针类型，包括指向函数类型的指针 [AUTOSAR-M5_2_6-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_2_8.html">AUTOSAR M5-2-8 具有整数类型的对象或指向 void 类型的指针不能转换为具有指针类型的对象 [AUTOSAR-M5_2_8]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_2_8-a.html">具有整数类型的对象或指向 void 类型的指针不应转换为具有指针类型的对象 [AUTOSAR-M5_2_8-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_2_9.html">AUTOSAR M5-2-9 强制转换不能将指针类型转换为整数类型 [AUTOSAR-M5_2_9]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_2_9-a.html">不允许指针类型和整数类型之间进行类型转换 [AUTOSAR-M5_2_9-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_3_1.html">AUTOSAR M5-3-1 ! 运算符，逻辑运算符 &amp;&amp;或||的每一个操作数应具有布尔类型 [AUTOSAR-M5_3_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_3_1-a.html">! 运算符，逻辑 &amp;&amp; 或逻辑 || 运算符的每个操作数应该都是布尔类型 [AUTOSAR-M5_3_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_3_2.html">AUTOSAR M5-3-2 一元减号运算符不能应用于其基础类型为无符号的表达式 [AUTOSAR-M5_3_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_3_2-a.html">一元减法运算符不得适用于其原始类型是无符号型的表达式 [AUTOSAR-M5_3_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_3_3.html">AUTOSAR M5-3-3 一元运算符&amp;不得重载 [AUTOSAR-M5_3_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_3_3-a.html">一元 &amp; 运算符不得被重载 [AUTOSAR-M5_3_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_3_4.html">AUTOSAR M5-3-4 对 sizeof 运算符求值的操作数不应包含副作用 [AUTOSAR-M5_3_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_3_4-a.html">sizeof运算符的操作数不应包含任何有副作用的表达式 [AUTOSAR-M5_3_4-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_3_4-b.html">不应在sizeof运算符的操作数中访问由volatile左值指定的对象 [AUTOSAR-M5_3_4-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_3_4-c.html">会导致副作用的函数调用不应该用作 sizeof 运算符的操作数 [AUTOSAR-M5_3_4-c-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_8_1.html">AUTOSAR M5-8-1 移位运算符的右操作数应该位于零到1之间，小于左操作数的基础类型的位的宽度 [AUTOSAR-M5_8_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M5_8_1-a.html">一个移位操作符的右操作数应该位于 0 到 1 之间，小于左操作数底层类型的位宽 [AUTOSAR-M5_8_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_2_1.html">AUTOSAR M6-2-1 子表达式中不应使用赋值运算符 [AUTOSAR-M6_2_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_2_1-a.html">禁止在产生布尔值的表达式中使用赋值运算符 [AUTOSAR-M6_2_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_2_2.html">AUTOSAR M6-2-2 浮点表达式不应直接或间接地检验等式或不等式 [AUTOSAR-M6_2_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_2_2-a.html">禁止对浮点数类型的表达式做相等或不相等的比较 [AUTOSAR-M6_2_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_2_3.html">AUTOSAR M6-2-3 在预处理前，null 语句只能单独出现在一行中;如果 null 语句后面的第一个字符是空白字符，那么后面可能跟着一条注释 [AUTOSAR-M6_2_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_2_3-a.html">空语句只允许单独存在一行或者可以在其后面跟着注释 [AUTOSAR-M6_2_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_3_1.html">AUTOSAR M6-3-1 构成switch, while, do ... while或for主体的语句应是复合语句 [AUTOSAR-M6_3_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_3_1-a.html">'switch', 'while', 'do...while' 或 'for' 语句的主体应该是复合语句 [AUTOSAR-M6_3_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_4_1.html">AUTOSAR M6-4-1 if (条件)结构应后接复合语句.else 关键字后面应该跟着一个复合语句，或者另一个if语句 [AUTOSAR-M6_4_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_4_1-a.html">'if' 和 'else' 语句后应跟一个复合句 [AUTOSAR-M6_4_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_4_2.html">AUTOSAR M6-4-2 所有 if ... else if 结构应以 else 子句终止 [AUTOSAR-M6_4_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_4_2-a.html">所有 'if...else-if' 结构应使用一个 'else' 子句终止 [AUTOSAR-M6_4_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_4_3.html">AUTOSAR M6-4-3 switch 语句应该符合语法规范 [AUTOSAR-M6_4_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_4_3-a.html">非条件 throw 或 break 语句应终止每个非空的 switch 语句 [AUTOSAR-M6_4_3-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_4_3-b.html">在 switch 语句中的最后分支应该是 default 分支，除非所有枚举值都被测试 [AUTOSAR-M6_4_3-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_4_3-c.html">只有当最紧密封闭的复合语句是 switch 语句主体的时才能使用 switch 标签 [AUTOSAR-M6_4_3-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_4_3-d.html">每一个 switch 语句至少有一个 case 子句 [AUTOSAR-M6_4_3-d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_4_3-e.html">switch 表达式不应该出现一个实际为布尔的值 [AUTOSAR-M6_4_3-e-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_4_4.html">AUTOSAR M6-4-4 switch 标签只能在最接近的复合语句是 switch 语句的主体时使用 [AUTOSAR-M6_4_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_4_4-a.html">只有当最紧密封闭的复合语句是 switch 语句主体的时才能使用 switch 标签 [AUTOSAR-M6_4_4-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_4_5.html">AUTOSAR M6-4-5 无条件抛出或中断语句将终止每个非空 switch 子句 [AUTOSAR-M6_4_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_4_5-a.html">非条件 throw 或 break 语句应终止每个非空的 switch 语句 [AUTOSAR-M6_4_5-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_4_6.html">AUTOSAR M6-4-6 switch 语句的 final 子句应为 default 子句 [AUTOSAR-M6_4_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_4_6-a.html">在 switch 语句中的最后分支应该是 default 分支，除非所有枚举值都被测试 [AUTOSAR-M6_4_6-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_4_7.html">AUTOSAR M6-4-7 switch语句的条件不应具有布尔类型 [AUTOSAR-M6_4_7]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_4_7-a.html">switch 表达式不应该出现一个实际为布尔的值 [AUTOSAR-M6_4_7-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_5_2.html">AUTOSAR M6-5-2 如果循环计数器不被--或++修改，那么在条件允许的情况下，循环计数器只能用作 &lt;=, &lt;, &gt; 或 &gt;= 的操作数 [AUTOSAR-M6_5_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_5_2-a.html">如果循环计数器不是被 -- 或 ++ 修改，那么在条件中此循环计数器应该只能被用作 &lt;=, &lt;, &gt; 或 &gt;= 的操作数 [AUTOSAR-M6_5_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_5_3.html">AUTOSAR M6-5-3 循环计数器不能在条件或声明中被修改 [AUTOSAR-M6_5_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_5_3-a.html">禁止在循环体中修改循环计数器 [AUTOSAR-M6_5_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_5_4.html">AUTOSAR M6-5-4 在循环过程中 n 保持不变的地方，循环计数器应修改为: --，++，-= n，或+= n其中之一 [AUTOSAR-M6_5_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_5_4-a.html">循环计数器应该被 --, ++, -=n, 或 +=n 之一修改；这里的 n 在整个循环期间保持不变 [AUTOSAR-M6_5_4-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_5_5.html">AUTOSAR M6-5-5 除循环计数器外的循环控变量不得在条件或表达式中进行修改 [AUTOSAR-M6_5_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_5_5-a.html">循环计数器以外的循环控制变量不得在判定条件或运算表达式中被修改 [AUTOSAR-M6_5_5-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_5_6.html">AUTOSAR M6-5-6 除语句中修改的循环计数器外的循环控制变量应具有布尔类型 [AUTOSAR-M6_5_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_5_6-a.html">在循环体语句中被修改的循环计数器以外的循环控制变量应该是布尔类型的 [AUTOSAR-M6_5_6-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_6_1.html">AUTOSAR M6-6-1 goto语句引用的任何标签都应声明在同一个语句块中，或在语句块中封闭goto语句 [AUTOSAR-M6_6_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_6_1-a.html">任何由 goto 语句引用的标签应该声明在同一个模块中，或者在一个包含 goto 语句的模块中 [AUTOSAR-M6_6_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_6_2.html">AUTOSAR M6-6-2 在相同函数体中，goto语句应跳转到稍后声明的标签中 [AUTOSAR-M6_6_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_6_2-a.html">goto 语句应该跳转到同一个函数体中位于 goto 语句后面声明的标签 [AUTOSAR-M6_6_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_6_3.html">AUTOSAR M6-6-3 continue语句只能在符合语法规则的for循环中使用 [AUTOSAR-M6_6_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M6_6_3-a.html">continue 语句只应该被用于具有良好格式的 for 循环中 [AUTOSAR-M6_6_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M7_1_2.html">AUTOSAR M7-1-2 函数中的指针或引用参数如果不修改相应的对象，则应声明为常量指针或引用常量指针 [AUTOSAR-M7_1_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M7_1_2-a.html">如果指针不用于修改指向地址的对象则声明参数的类型为 typedef 的 const 指针 [AUTOSAR-M7_1_2-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M7_1_2-b.html">如果函数参数中指针参数在函数中不用来修改地址对象，则应声明为 const 类型 [AUTOSAR-M7_1_2-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M7_1_2-c.html">尽可能声明引用参数为 const 引用 [AUTOSAR-M7_1_2-c-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M7_3_1.html">AUTOSAR M7-3-1 全局名称空间应只包含 main，命名空间声明和外部的 'C'声明 [AUTOSAR-M7_3_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M7_3_1-a.html">全局命名空间应该只包含 main() 和命名空间声明 [AUTOSAR-M7_3_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M7_3_2.html">AUTOSAR M7-3-2 main 标识符不能用于全局函数 main 以外的函数 [AUTOSAR-M7_3_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M7_3_2-a.html">标识符 main 不得用于除了全局的 main 函数以外的其它函数 [AUTOSAR-M7_3_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M7_3_3.html">AUTOSAR M7-3-3 头文件中不应有未命名的名称空间 [AUTOSAR-M7_3_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M7_3_3-a.html">头文件中不应有未命名的命名空间 [AUTOSAR-M7_3_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M7_3_4.html">AUTOSAR M7-3-4 不得使用应用指令 [AUTOSAR-M7_3_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M7_3_4-a.html">不得使用 using 指示符 [AUTOSAR-M7_3_4-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M7_3_6.html">AUTOSAR M7-3-6 头文件中不应使用应用指令和使用声明(不包括类作用域或函数作用域应用声明) [AUTOSAR-M7_3_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M7_3_6-a.html">不应该在头文件中使用 'using' 指令和 'using' 声明(除了类和函数范围内的 using 声明) [AUTOSAR-M7_3_6-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M7_4_1.html">AUTOSAR M7-4-1 汇编程序的所有使用应记录在案 [AUTOSAR-M7_4_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M7_4_1-a.html">所有汇编程序的使用应该被注释说明 [AUTOSAR-M7_4_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M7_4_2.html">AUTOSAR M7-4-2 汇编指令只能通过asm声明引入 [AUTOSAR-M7_4_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M7_4_2-a.html">汇编指令应该只能使用 asm 声明来引入 [AUTOSAR-M7_4_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M7_4_3.html">AUTOSAR M7-4-3 汇编语言应该被封装和隔离 [AUTOSAR-M7_4_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M7_4_3-a.html">汇编语言应该封装在 C/C++ 函数中并被隔离 [AUTOSAR-M7_4_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M7_5_1.html">AUTOSAR M7-5-1 函数不应返回一个引用或指向函数中定义的自动变量(包括参数)的指针 [AUTOSAR-M7_5_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M7_5_1-a.html">不得从函数中返回具有自动存储的对象的地址 [AUTOSAR-M7_5_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M7_5_2.html">AUTOSAR M7-5-2 具有自动存储功能的对象的地址不应分配给另一个对象，该对象可能在第一个对象停用后仍然存在 [AUTOSAR-M7_5_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M7_5_2-a.html">自动存储对象的地址不应分配给在第一个对象不再存在后可能持久存在的另一个对象 [AUTOSAR-M7_5_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M8_0_1.html">AUTOSAR M8-0-1 初始化声明列表或成员声明列表应分别由单个初始化声明符或成员声名符组成 [AUTOSAR-M8_0_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M8_0_1-a.html">每个变量都要在单独的声明语句中被声明 [AUTOSAR-M8_0_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M8_3_1.html">AUTOSAR M8-3-1 覆盖虚拟函数中的参数要么使用与其覆盖的函数相同的默认参数，要么不指定任何默认参数 [AUTOSAR-M8_3_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M8_3_1-a.html">禁止使用不同的默认参数值来重定义继承的虚拟函数 [AUTOSAR-M8_3_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M8_4_2.html">AUTOSAR M8-4-2函数重声明中用于参数的标识符应与声明中的标识符相同 [AUTOSAR-M8_4_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M8_4_2-a.html">禁止函数声明中使用的标识符与实际定义中的标识符不一致 [AUTOSAR-M8_4_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M8_4_4.html">AUTOSAR M8-4-4 函数标识符要么用于调用函数，要么在前面加上&amp; [AUTOSAR-M8_4_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M8_4_4-a.html">函数标识符只能与前面的 &nbsp;'&amp;' 一起使用，或者与括号中的参数列表一起使用，参数列表可以是空的 [AUTOSAR-M8_4_4-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M8_5_2.html">AUTOSAR M8-5-2 在数组和结构体的非零初始化中，应使用大括号来指出结构 [AUTOSAR-M8_5_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M8_5_2-a.html">聚合体和共同体的初始化对象应该用大括号括起来 [AUTOSAR-M8_5_2-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M8_5_2-b.html">数组不应该部分初始化 [AUTOSAR-M8_5_2-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M8_5_2-c.html">结构的非零初始化要求每个元素都有显示初始化器 [AUTOSAR-M8_5_2-c-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M9_3_1.html">AUTOSAR M9-3-1 常量成员函数不应返回非常量指针或对类数据的引用 [AUTOSAR-M9_3_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M9_3_1-a.html">Const 成员函数不得返回指向类数据的非 const 指针或引用 [AUTOSAR-M9_3_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M9_3_3.html">AUTOSAR M9-3-3 如果一个成员函数可以是静态的，那么它就应该是静态的，否则如果它可以是常量，那么它就应该是常量 [AUTOSAR-M9_3_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M9_3_3-a.html">如果一个成员函数可以被设为 static 那么它应该被设为 static，否则如果可以被设为 const 那么它应该被设为 const [AUTOSAR-M9_3_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M9_6_4.html">AUTOSAR M9-6-4 带符号整数类型的命名位字段的长度应大于一位 [AUTOSAR-M9_6_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/AUTOSAR-M9_6_4-a.html">具有带符号的整数类型且已命名的位域应该有超过一位的长度 [AUTOSAR-M9_6_4-a-2]</a>
</li></ul>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD.html">数据流分析 [BD]</a></b>
<ul>
<li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-API.html">不正确的 API 使用 [BD-API]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-API-BADPARAM.html">不要传递不正确的值给库函数 [BD-API-BADPARAM-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-API-CTYPE.html">不要传递不正确的值给 ctype.h 库函数 [BD-API-CTYPE-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-API-NEGPARAM.html">不要将负值传递给期望非负参数的函数 [BD-API-NEGPARAM-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-API-REVNEGPARAM.html">在传递为非负性参数后不要检查是否为非负值 [BD-API-REVNEGPARAM-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-API-STRSIZE.html">传递给 string.h 中的任何函数的 size_t 参数应该具有正确的值 [BD-API-STRSIZE-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-API-VALPARAM.html">验证传递给库函数的值 [BD-API-VALPARAM-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-CO.html">容器 [BD-CO]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-CO-EMPCON.html">不要将空容器迭代器作为目标传递给 std 算法 [BD-CO-EMPCON-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-CO-ITINVCOMP.html">不要比较来自不同容器的迭代器 [BD-CO-ITINVCOMP-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-CO-ITMOD.html">在遍历容器时不要修改容器 [BD-CO-ITMOD-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-CO-ITOUT.html">不要访问超出范围的迭代器 [BD-CO-ITOUT-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-CO-STRMOD.html">使用有效的引用、指针和迭代器来引用一个 basic_string 的元素 [BD-CO-STRMOD-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-MISC.html">杂项 [BD-MISC]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-MISC-DC.html">防止调用不安全的函数(自定义规则) [BD-MISC-DC-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-MISC-TRANS.html">始终关闭事务 [BD-MISC-TRANS-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB.html">潜在的缺陷 [BD-PB]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-ARRAY.html">避免访问数组越界 [BD-PB-ARRAY-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-ARRPTR.html">指向对象数组元素的指针不应被传递给单一对象类型的智能指针 [BD-PB-ARRPTR-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-BADSHIFT.html">避免不正确的位移操作 [BD-PB-BADSHIFT-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-BYTEORD.html">在系统之间传输数据时使用正确的字节顺序 [BD-PB-BYTEORD-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-CC.html">避免始终计算为相同值的条件 [BD-PB-CC-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-CHECKRET.html">持续检查非 void 函数的返回值 [BD-PB-CHECKRET-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-CHECKRETGEN.html">始终检查非 void 函数的返回值 [BD-PB-CHECKRETGEN-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-DEREF.html">避免在引用之后再检查空(null) [BD-PB-DEREF-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-DNMPTR.html">不要通过调用 realloc() 修改对象的对齐方式 [BD-PB-DNMPTR-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-EOFCOMP.html">应该将宏 EOF 与标准库函数中未修改的返回值进行比较 [BD-PB-EOFCOMP-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-ERRNO.html">正确使用 errno 值 [BD-PB-ERRNO-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-EXCEPT.html">始终捕获异常 [BD-PB-EXCEPT-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-EXITHAN.html">正确定义退出处理程序 [BD-PB-EXITHAN-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-FGETS.html">通过 fgets() 或 fgetws() 重置字符串失败 [BD-PB-FGETS-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-FSETPOS.html">只对 fsetpos() 使用从 fgetpos() 返回的值 [BD-PB-FSETPOS-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-INFREC.html">避免无限递归 [BD-PB-INFREC-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-INTOVERF.html">避免整数溢出 [BD-PB-INTOVERF-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-INVENV.html">不依赖于可能使其无效操作的环境指针 [BD-PB-INVENV-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-INVRET.html">某些标准库函数返回的指针不应该在随后调用相同或相关函数中使用 [BD-PB-INVRET-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-MCCSTR.html">标准库函数 memcmp 不应该用于比较 null 终止字符串 [BD-PB-MCCSTR-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-MODSTR.html">不要修改字符串字面量 [BD-PB-MODSTR-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-NEWHAN.html">正确定义新处理程序 [BD-PB-NEWHAN-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-NOEXCEPT.html">避免从声明不抛出异常的函数中抛出异常 [BD-PB-NOEXCEPT-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-NORETURN.html">不要从不应该返回值的函数中返回 [BD-PB-NORETURN-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-NOTINIT.html">避免在初始化之前使用 [BD-PB-NOTINIT-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-NP.html">避免空指针引用 [BD-PB-NP-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-NZTS.html">确保字符串为零终止 [BD-PB-NZTS-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-OVERFARRAY.html">避免访问数组和指针越界 [BD-PB-OVERFARRAY-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-OVERFFMT.html">避免由于定义不正确的格式限制导致的缓冲区溢出 [BD-PB-OVERFFMT-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-OVERFNZT.html">避免由于读取非零终止字符串导致的溢出 [BD-PB-OVERFNZT-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-OVERFRD.html">避免读取缓冲区时导致的溢出 [BD-PB-OVERFRD-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-OVERFWR.html">避免写入缓冲区时导致的溢出 [BD-PB-OVERFWR-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-OVERLAP.html">不应将对象分配或复制到重叠的对象 [BD-PB-OVERLAP-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-POLARR.html">没有处理数组为多态 [BD-PB-POLARR-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-POVR.html">避免覆盖方法参数 [BD-PB-POVR-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-PTRARR.html">一个指针操作数和使用这个操作数的指针算法所产生的任何指针都应该处理相同数组的元素 [BD-PB-PTRARR-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-PTRCMP.html">不要比较两个不相关的指针 [BD-PB-PTRCMP-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-PTRVALUE.html">在一个无关的智能指针中不要保存一个只读指针变量 [BD-PB-PTRVALUE-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-PUTENV.html">不要调用 putenv() 使用一个指向自动变量的指针作为参数 [BD-PB-PUTENV-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-RECFUN.html">不要使用递归 [BD-PB-RECFUN-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-REFPARAM.html">如果参数不能为 NULL，则通过引用传递参数 [BD-PB-REFPARAM-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-SIGHAN.html">正确定义信号处理程序 [BD-PB-SIGHAN-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-SIGRETURN.html">不要返回计算异常信号的处理函数 [BD-PB-SIGRETURN-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-STDEXC.html">始终抛出创建的 std::exception 对象 [BD-PB-STDEXC-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-STREAMFLAGS.html">可疑的流标志设置 [BD-PB-STREAMFLAGS-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-STREAMFMT.html">恢复流格式 [BD-PB-STREAMFMT-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-STREAMINOUT.html">不要从一个流中交替地输入和输出，却没有间隔刷新或定位调用 [BD-PB-STREAMINOUT-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-SUBSEQFRWD.html">后续不要使用传递给参数 std::forward [BD-PB-SUBSEQFRWD-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-SUBSEQMOVE.html">不要依赖被移动对象的值 [BD-PB-SUBSEQMOVE-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-SWITCH.html">避免具有无法到达分支的开关语句 [BD-PB-SWITCH-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-TERMHAN.html">正确定义终止处理函数 [BD-PB-TERMHAN-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-UCMETH.html">避免无法到达的方法 [BD-PB-UCMETH-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-UNEXPHAN.html">正确定义意外处理函数 [BD-PB-UNEXPHAN-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-VALRANGE.html">保证容器索引在有效范围内 [BD-PB-VALRANGE-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-VARARGS.html">正确地使用可变参数的宏 [BD-PB-VARARGS-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-VCTOR.html">不要从类的任何构造函数中调用类的虚函数 [BD-PB-VCTOR-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-VDTOR.html">不要从类的析构函数中调用类的虚函数 [BD-PB-VDTOR-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-VLASIZE.html">确保可变长度数组的大小在有效范围内 [BD-PB-VLASIZE-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-VOVR.html">避免未使用的值 [BD-PB-VOVR-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-WRAPESC.html">不要指向已被释放的包装对象 [BD-PB-WRAPESC-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-WRRDSTR.html">同一个文件不能在不同的流上同时打开用于读取和写入访问 [BD-PB-WRRDSTR-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-WRROS.html">避免写入以只读方式打开的流 [BD-PB-WRROS-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-PB-ZERO.html">避免除零错误 [BD-PB-ZERO-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-RES.html">资源 [BD-RES]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-RES-BADDEALLOC.html">正确地动态释放分配的资源 [BD-RES-BADDEALLOC-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-RES-BADFREEF.html">确保释放函数保证资源释放 [BD-RES-BADFREEF-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-RES-CSP.html">避免循环引用 shared_ptr [BD-RES-CSP-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-RES-FREE.html">不得使用已经释放掉的资源 [BD-RES-FREE-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-RES-INSUFMEM.html">分配足够的内存来存放给定类型的对象 [BD-RES-INSUFMEM-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-RES-INVFREE.html">不得使用无效的指针释放资源 [BD-RES-INVFREE-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-RES-LEAKS.html">确保资源已释放 [BD-RES-LEAKS-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-RES-STACKLIM.html">不要在超过已定义的限制的栈上创建变量 [BD-RES-STACKLIM-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-SECURITY.html">安全 [BD-SECURITY]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-SECURITY-ARRAY.html">避免在数组索引中有受污染数据 [BD-SECURITY-ARRAY-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-SECURITY-BUFWRITE.html">防止来自受污染数据的缓冲区溢出 [BD-SECURITY-BUFWRITE-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-SECURITY-INTOVERF.html">防止来自受污染数据的整数溢出/下溢 [BD-SECURITY-INTOVERF-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-SECURITY-LOG.html">避免将未经验证的二进制数据传递给日志方法 [BD-SECURITY-LOG-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-SECURITY-OVERFFMT.html">避免由于定义不正确的格式限制而导致受污染数据的缓冲区溢出 [BD-SECURITY-OVERFFMT-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-SECURITY-OVERFRD.html">避免来自受污染数据的缓冲区读取溢出 [BD-SECURITY-OVERFRD-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-SECURITY-OVERFWR.html">避免来自受污染数据的缓冲区写入溢出 [BD-SECURITY-OVERFWR-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-SECURITY-RAND.html">在伪随机数生成器中指定适当的种子 [BD-SECURITY-RAND-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-SECURITY-TDCMD.html">防止命令注入 [BD-SECURITY-TDCMD-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-SECURITY-TDCONSOLE.html">避免在输出控制台打印受污染的数据 [BD-SECURITY-TDCONSOLE-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-SECURITY-TDENV.html">防止环境注入 [BD-SECURITY-TDENV-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-SECURITY-TDFNAMES.html">防止文件名注入 [BD-SECURITY-TDFNAMES-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-SECURITY-TDINPUT.html">从格式字符串中排除未经消毒的用户输入 [BD-SECURITY-TDINPUT-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-SECURITY-TDSQL.html">防止 SQL 注入 [BD-SECURITY-TDSQL-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-SECURITY-XXEXRC.html">在 libxerces-c 中禁用解析 XML 外部实体(XXE) [BD-SECURITY-XXEXRC-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-TRS.html">多线程 &amp; 同步性 [BD-TRS]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-TRS-ARG.html">声明具有适当存储时间在 POSIX 线程之间共享的对象 [BD-TRS-ARG-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-TRS-BITLOCK.html">在修改位域时使用锁来防止竞争条件 [BD-TRS-BITLOCK-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-TRS-CMF.html">使 const 成员函数是线程安全的 [BD-TRS-CMF-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-TRS-DIFCS.html">变量应该在单个关键部分的上下文中使用 [BD-TRS-DIFCS-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-TRS-DLOCK.html">避免双重锁定 [BD-TRS-DLOCK-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-TRS-DSTRLOCK.html">不要销毁另一个线程的互斥对象 [BD-TRS-DSTRLOCK-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-TRS-FORKFILE.html">当使用 fork 和文件描述符时避免竞争条件 [BD-TRS-FORKFILE-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-TRS-FRC.html">避免访问文件的资源竞争 [BD-TRS-FRC-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-TRS-JOINDETACH.html">不要连接或分离以前连接或分离的线程 [BD-TRS-JOINDETACH-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-TRS-LOCK.html">不要抛弃未释放的锁 [BD-TRS-LOCK-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-TRS-MLOCK.html">不要使用具有不同的锁集的全局变量 [BD-TRS-MLOCK-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-TRS-ORDER.html">不要以不同的顺序获取锁 [BD-TRS-ORDER-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-TRS-REVLOCK.html">不释放尚未获得的锁 [BD-TRS-REVLOCK-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-TRS-SYMLINK.html">在检查符号链接是否存在时避免竞争条件 [BD-TRS-SYMLINK-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/BD-TRS-TSHL.html">不要在持有一个锁的同时使用阻塞函数 [BD-TRS-TSHL-1]</a>
</li></ul>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CDD.html">代码重复性检测 [CDD]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CDD-DUPC.html">避免代码重复 [CDD-DUPC-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CDD-DUPI.html">避免重复的 #include 指令 [CDD-DUPI-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CDD-DUPM.html">避免函数重复 [CDD-DUPM-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CDD-DUPS.html">避免字符串常量重复 [CDD-DUPS-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C.html">SEI CERT C [CERT_C]</a></b>
<ul>
<li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-API00.html">CERT-API00_C (REC) 函数应该验证它们的参数 [CERT_C-API00]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-API00-a.html">必须在每个函数内部检查参数的有效性 [CERT_C-API00-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-API01.html">CERT-API01_C (REC) 避免在敏感数据之前直接在内存中放置字符串 [CERT_C-API01]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-API01-a.html">避免写入缓冲区时导致的溢出 [CERT_C-API01-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-API01-b.html">避免使用可能导致缓冲区溢出的不安全字符串函数 [CERT_C-API01-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-API02.html">CERT-API02_C (REC) 对数组进行读写操作的函数应该使用一个参数来指定源文件或目标的大小 [CERT_C-API02]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-API02-a.html">避免使用可能导致缓冲区溢出的不安全字符串函数 [CERT_C-API02-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-API02-b.html">不要使用不安全的 C 函数来写未检查范围的缓冲区 [CERT_C-API02-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ARR01.html">CERT-ARR01_C (REC) 在获取数组大小时，不对指针应用sizeof运算符 [CERT_C-ARR01]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ARR01-a.html">不要在指针类型上调用'sizeof' [CERT_C-ARR01-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ARR02.html">CERT-ARR02_C (REC) 显式地指定数组界限，即使由初始化器隐式定义 [CERT_C-ARR02]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ARR02-a.html">使用初始化器显式指定数组声明中的数组大小 [CERT_C-ARR02-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ARR30.html">CERT-ARR30_C (RULE) 不形成或者使用越界指针或数组下标 [CERT_C-ARR30]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ARR30-a.html">避免访问数组越界 [CERT_C-ARR30-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ARR32.html">CERT-ARR32_C (RULE) 确保可变长度数组的大小参数在有效范围内 [CERT_C-ARR32]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ARR32-a.html">确保可变长度数组的大小在有效范围内 [CERT_C-ARR32-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ARR36.html">CERT-ARR36_C (RULE) 不去除或比较两个未引用自同一数组的指针 [CERT_C-ARR36]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ARR36-a.html">只有指向数组或数组元素地址的指针才能进行指针运算 [CERT_C-ARR36-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ARR37.html">CERT-ARR37_C (RULE) 不要向非数组对象的指针添加或减去一个整数 [CERT_C-ARR37]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ARR37-a.html">指针运算不得用于指向非数组类型变量的指针 [CERT_C-ARR37-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ARR38.html">CERT-ARR38_C (RULE) 保证库函数不会形成无效指针 [CERT_C-ARR38]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ARR38-a.html">避免读取缓冲区时导致的溢出 [CERT_C-ARR38-a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ARR38-b.html">避免写入缓冲区时导致的溢出 [CERT_C-ARR38-b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ARR38-c.html">避免由于定义不正确的格式限制导致的缓冲区溢出 [CERT_C-ARR38-c-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ARR38-d.html">避免由于读取非零终止字符串导致的溢出 [CERT_C-ARR38-d-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ARR39.html">CERT-ARR39_C (RULE) 不要向指针添加或减去缩放的整数 [CERT_C-ARR39]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ARR39-a.html">避免访问数组越界 [CERT_C-ARR39-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ARR39-b.html">不应该使用指针算法 [CERT_C-ARR39-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ARR39-c.html">不要拿整型和指针做加减运算 [CERT_C-ARR39-c-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON01.html">CERT-CON01_C (REC) 在相同的抽象级别上，在同一个模块中获取和释放同步基元 [CERT_C-CON01]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON01-a.html">不要抛弃未释放的锁 [CERT_C-CON01-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON02.html">CERT-CON02_C (REC) 不使用volatile关键字作为同步基元 [CERT_C-CON02]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON02-a.html">不要使用 volatile 关键字 [CERT_C-CON02-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON05.html">CERT-CON05_C (REC) 持有锁时不执行可能阻塞的操作 [CERT_C-CON05]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON05-a.html">不要在持有一个锁的同时使用阻塞函数 [CERT_C-CON05-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON30.html">CERT-CON30_C (RULE) 清理线程特定的存储 [CERT_C-CON30]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON30-a.html">确保资源已释放 [CERT_C-CON30-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON31.html">CERT-CON31_C (RULE) 在线程上锁时不要破坏互斥对象 [CERT_C-CON31]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON31-a.html">不要销毁另一个线程的互斥对象 [CERT_C-CON31-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON31-b.html">不得使用已经释放掉的资源 [CERT_C-CON31-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON31-c.html">不得使用无效的指针释放资源 [CERT_C-CON31-c-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON32.html">CERT-CON32_C (RULE) 当多个线程访问位字段时，防止数据抢占 [CERT_C-CON32]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON32-a.html">在修改位域时使用锁来防止竞争条件 [CERT_C-CON32-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON33.html">CERT-CON33_C (RULE) 在使用库函数时消除抢占条件 [CERT_C-CON33]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON33-a.html">避免使用对线程不安全(thread-unsafe)的函数 [CERT_C-CON33-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON34.html">CERT-CON34_C (RULE) 用适当的存储持续时间声明线程之间共享的对象 [CERT_C-CON34]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON34-a.html">声明具有适当存储时间在 POSIX 线程之间共享的对象 [CERT_C-CON34-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON35.html">CERT-CON35_C (RULE) 按预定顺序加锁以避免死锁 [CERT_C-CON35]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON35-a.html">避免双重锁定 [CERT_C-CON35-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON36.html">CERT-CON36_C (RULE) 封装在循环中伪唤醒的函数 [CERT_C-CON36]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON36-a.html">封装可以在循环中伪唤醒的函数 [CERT_C-CON36-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON37.html">CERT-CON37_C (RULE) 不要在多线程程序中调用signal() [CERT_C-CON37]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON37-a.html">禁止使用信号处理文件 &lt;signal.h&gt; 中的处理函数 [CERT_C-CON37-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON38.html">CERT-CON38_C (RULE) 在使用条件变量时保持线程安全性和活性 [CERT_C-CON38]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON38-a.html">使用带有唯一条件变量的“cnd_signal()”函数 [CERT_C-CON38-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON39.html">CERT-CON39_C (RULE) 不要连接或分离先前已经连接或分离的线程 [CERT_C-CON39]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON39-a.html">不要连接或分离以前连接或分离的线程 [CERT_C-CON39-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON40.html">CERT-CON40_C (RULE) 不要在表达式中两次引用原子变量 [CERT_C-CON40]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON40-a.html">不要在表达式中两次引用原子变量 [CERT_C-CON40-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON41.html">CERT-CON41_C (RULE) 封装在循环中可能出现虚假错误的函数 [CERT_C-CON41]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON41-a.html">循环中使用包装函数可能失败 [CERT_C-CON41-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON43.html">CERT-CON43_C (RULE) 不允许多线程代码中的数据抢占 [CERT_C-CON43]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-CON43-a.html">不允许使用容易发生争用的函数 [CERT_C-CON43-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL00.html">CERT-DCL00_C (REC) 使用 Const限定不可变对象 [CERT_C-DCL00]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL00-a.html">尽可能将参数或局部变量声明为const [CERT_C-DCL00-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL01.html">CERT-DCL01_C (REC) 不要在子类中重用变量名 [CERT_C-DCL01]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL01-a.html">在局部或者函数原型体范围内声明的标识符不应该隐藏一个在全局或者命名空间范围内声明的标识符 [CERT_C-DCL01-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL01-b.html">在内层的局部范围内声明的标识符不应该隐藏在外层的局部范围内声明的标识符 [CERT_C-DCL01-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL02.html">CERT-DCL02_C (REC) 使用外表不同的标识符 [CERT_C-DCL02]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL02-a.html">在函数和变量名中包含的字母应该全部由小写字母组成 [CERT_C-DCL02-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL04.html">CERT-DCL04_C (REC) 一次声明不声明多个变量 [CERT_C-DCL04]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL04-a.html">每个变量都要在单独的声明语句中被声明 [CERT_C-DCL04-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL05.html">CERT-DCL05_C (REC) 只使用非指针类型的typedefs  [CERT_C-DCL05]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL05-a.html">如果指针不用于修改指向地址的对象则声明参数的类型为 typedef 的 const 指针 [CERT_C-DCL05-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL06.html">CERT-DCL06_C (REC) 使用有意义的符号常量来表示字面量值 [CERT_C-DCL06]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL06-a.html">应该尽可能使用“#define”或枚举类型常量（enum），而不是硬编码值 [CERT_C-DCL06-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL10.html">CERT-DCL10_C (REC) 在可变函数的写入(writer)和调用(caller)函数之间保持一致 [CERT_C-DCL10]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL10-a.html">格式字符串中的格式说明符的数量和调用字符串格式化函数时相应的参数的数量应该相等 [CERT_C-DCL10-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL11.html">CERT-DCL11_C (REC) 理解与可变函数相关的类型问题 [CERT_C-DCL11]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL11-a.html">在调用字符串格式化函数时，格式字符串中的'%s'和'%c'格式说明符及其对应的参数不应该不匹配 [CERT_C-DCL11-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL11-b.html">在调用字符串格式化函数时，格式字符串中的'%f'格式说明符及其对应的参数之间不应存在不匹配 [CERT_C-DCL11-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL11-c.html">在调用字符串格式化函数时，字符串中的“%i”和“%d”格式说明符及其对应的参数不应该不匹配 [CERT_C-DCL11-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL11-d.html">在调用字符串格式化函数时，格式字符串中的'%u'格式说明符及其对应的参数之间不应存在不匹配 [CERT_C-DCL11-d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL11-e.html">在调用字符串格式化函数时，格式字符串中的'%p'格式说明符及其对应的参数之间不应存在不匹配 [CERT_C-DCL11-e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL11-f.html">格式字符串中的格式说明符的数量和调用字符串格式化函数时相应的参数的数量应该相等 [CERT_C-DCL11-f-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL12.html">CERT-DCL12_C (REC) 使用不透明类型实现抽象数据类型 [CERT_C-DCL12]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL12-a.html">如果指向一个结构体或联合体的指针在一个编译单元内从未被间接引用，那么该对象的实现应该被隐藏起来 [CERT_C-DCL12-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL13.html">CERT-DCL13_C (REC) 声明函数参数，这些参数是指针，指针指向的值不会由函数变为常量 [CERT_C-DCL13]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL13-a.html">如果函数参数中指针参数在函数中不用来修改地址对象，则应声明为 const 类型 [CERT_C-DCL13-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL15.html">CERT-DCL15_C (REC) 将不需要外部链接的文件范围对象或函数声明为静态 [CERT_C-DCL15]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL15-a.html">具有外部链接的对象或函数应该在头文件中声明 [CERT_C-DCL15-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL16.html">CERT-DCL16_C (REC) 使用"L"，而不是"l"表示一个长整型值 [CERT_C-DCL16]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL16-a.html">使用大写 'L' 而非小写 'l' 来指定长整型 [CERT_C-DCL16-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL18.html">CERT-DCL18_C (REC) 在指定十进制值时，不要以0开始的整型常量 [CERT_C-DCL18]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL18-a.html">八进制和十六进制转义序列将被终止 [CERT_C-DCL18-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL18-b.html">不应该使用八进制常数（除零外） [CERT_C-DCL18-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL19.html">CERT-DCL19_C (REC) 最小化变量和函数的范围 [CERT_C-DCL19]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL19-a.html">尽可能地声明局部化的变量 [CERT_C-DCL19-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL20.html">CERT-DCL20_C (REC) 当函数无参数时显式地指定void [CERT_C-DCL20]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL20-a.html">传递给函数的参数个数必须与函数定义的参数一致 [CERT_C-DCL20-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL22.html">CERT-DCL22_C (REC) 对于无法缓存的数据使用volatile [CERT_C-DCL22]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL22-a.html">避免未使用的值 [CERT_C-DCL22-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL30.html">CERT-DCL30_C (RULE) 声明具有适当存储时间的对象 [CERT_C-DCL30]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL30-a.html">不得从函数中返回具有自动存储的对象的地址 [CERT_C-DCL30-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL30-b.html">自动存储对象的地址不应分配给在第一个对象不再存在后可能持久存在的另一个对象 [CERT_C-DCL30-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL31.html">CERT-DCL31_C (RULE) 在使用标识符之前声明它们 [CERT_C-DCL31]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL31-a.html">所有对象和函数必须先声明再使用 [CERT_C-DCL31-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL36.html">CERT-DCL36_C (RULE) 不要声明具有冲突链接分类的标识符 [CERT_C-DCL36]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL36-a.html">标识符在同一编译单元中不能同时具有内部和外部链接 [CERT_C-DCL36-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL37.html">CERT-DCL37_C (RULE) 不要声明或定义保留标识符 [CERT_C-DCL37]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL37-a.html">不要使用以下划线开头的带有#define 或 #undef 名称的标识符 [CERT_C-DCL37-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL38.html">CERT-DCL38_C (RULE) 在声明灵活数组成员（flexible array member）时使用正确的语法 [CERT_C-DCL38]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL38-a.html">结构的最终成员不应该是“0”或“1”的数组 [CERT_C-DCL38-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL39.html">CERT-DCL39_C (RULE) 通过信任边界（trust boundary）传递结构时避免信息泄漏 [CERT_C-DCL39]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL39-a.html">不应将指向结构的指针传递给可将数据复制到用户空间的函数 [CERT_C-DCL39-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL40.html">CERT-DCL40_C (RULE) 不创建相同函数或对象的不兼容声明 [CERT_C-DCL40]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL40-a.html">当一个有外部联系的对象或函数被定义，则一个声明应该为可见的 [CERT_C-DCL40-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL40-b.html">如果对象或者函数被声明了一次以上，那么他们的类型应该是兼容的 [CERT_C-DCL40-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL41.html">CERT-DCL41_C (RULE) 在第一个case标签之前不要在switch语句中声明变量 [CERT_C-DCL41]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-DCL41-a.html">switch 语句应该只包含 switch 标签和 switch 子句，不能包含其他代码 [CERT_C-DCL41-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ENV01.html">CERT-ENV01_C (REC) 不要假设环境变量的大小 [CERT_C-ENV01]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ENV01-a.html">不要使用不安全的 C 函数来写未检查范围的缓冲区 [CERT_C-ENV01-a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ENV01-b.html">避免使用可能导致缓冲区溢出的不安全字符串函数 [CERT_C-ENV01-b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ENV01-c.html">避免写入缓冲区时导致的溢出 [CERT_C-ENV01-c-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ENV02.html">CERT-ENV02_C (REC) 注意多个具有相同有效名称的环境变量 [CERT_C-ENV02]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ENV02-a.html">限制使用系统属性（环境变量） [CERT_C-ENV02-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ENV30.html">CERT-ENV30_C (RULE) 不要通过函数的返回值来修改对象引用 [CERT_C-ENV30]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ENV30-a.html">由标准库函数 'localeconv', 'getenv', 'setlocale' 或, 'strerror' 返回的指针只能被用于指向常量类型 [CERT_C-ENV30-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ENV31.html">CERT-ENV31_C (RULE) 不要依赖一个环境指针，而这个环境指针跟随着一个可能使它失效的操作 [CERT_C-ENV31]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ENV31-a.html">不依赖于可能使其无效操作的环境指针 [CERT_C-ENV31-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ENV32.html">CERT-ENV32_C (RULE) 所有退出处理程序必须正常返回 [CERT_C-ENV32]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ENV32-a.html">正确定义退出处理程序 [CERT_C-ENV32-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ENV33.html">CERT-ENV33_C (RULE) 不要调用system()函数 [CERT_C-ENV33]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ENV33-a.html">不要调用 'stdlib.h' 或 'cstdlib' 库中参数不为 '0'（空指针）的 'system()' 函数 [CERT_C-ENV33-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ENV34.html">CERT-ENV34_C (RULE) 不存储某一函数返回的指针 [CERT_C-ENV34]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ENV34-a.html">某些标准库函数返回的指针不应该在随后调用相同或相关函数中使用 [CERT_C-ENV34-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ERR01.html">CERT-ERR01_C (REC) 使用 ferror()而不是errno检查文件流错误 [CERT_C-ERR01]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ERR01-a.html">不得使用错误指示 'errno' [CERT_C-ERR01-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ERR02.html">CERT-ERR02_C (REC) 避免某些错误指示器 [CERT_C-ERR02]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ERR02-a.html">不得使用标准的库的 input/output 函数 [CERT_C-ERR02-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ERR04.html">CERT-ERR04_C (REC) 选择一个合适的终止策略 [CERT_C-ERR04]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ERR04-a.html">不得使用 'stdlib.h' 或 'cstdlib' 库中的 'abort()' 函数 [CERT_C-ERR04-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ERR04-b.html">不得使用 'stdlib.h' &nbsp;或 'cstdlib' 库中的 'exit()' 函数 [CERT_C-ERR04-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ERR04-c.html">不得使用 'stdlib.h' 或 'cstdlib' 库中的 'quick_exit()' 和 '_Exit()' 函数 [CERT_C-ERR04-c-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ERR05.html">CERT-ERR05_C (REC) 不依赖于应用程序的代码应该提供错误检测，而不需要指定错误处理 [CERT_C-ERR05]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ERR05-a.html">不得使用 'stdlib.h' 或 'cstdlib' 库中的 'abort()' 函数 [CERT_C-ERR05-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ERR05-b.html">不得使用 'stdlib.h' &nbsp;或 'cstdlib' 库中的 'exit()' 函数 [CERT_C-ERR05-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ERR05-c.html">不得使用 'stdlib.h' 或 'cstdlib' 库中的 'quick_exit()' 和 '_Exit()' 函数 [CERT_C-ERR05-c-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ERR06.html">CERT-ERR06_C (REC) 理解 assert() 和 abort() 的终止行为 [CERT_C-ERR06]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ERR06-a.html">不要使用断言 [CERT_C-ERR06-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ERR07.html">CERT-ERR07_C (REC) 选择支持错误检查的函数，而不是不支持错误检查的等效函数 [CERT_C-ERR07]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ERR07-a.html">不得使用库stdlib.h中的库函数atof，atoi和atol [CERT_C-ERR07-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ERR07-b.html">不得使用标准的库的 input/output 函数 [CERT_C-ERR07-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ERR30.html">CERT-ERR30_C (RULE) 在调用已知设置errno的库函数之前，将errno设置为零，并仅在函数返回一个指示失败的值之后检查errno [CERT_C-ERR30]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ERR30-a.html">正确使用 errno 值 [CERT_C-ERR30-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ERR30-b.html">在调用fopen函数的附近提供文件打开错误的错误处理机制 [CERT_C-ERR30-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ERR32.html">CERT-ERR32_C (RULE) 不要依赖errno的不定值 [CERT_C-ERR32]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ERR32-a.html">正确使用 errno 值 [CERT_C-ERR32-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ERR33.html">CERT-ERR33_C (RULE) 检测和处理标准库错误 [CERT_C-ERR33]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ERR33-a.html">应该使用具有非 void 返回类型的函数返回值 [CERT_C-ERR33-a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ERR33-b.html">不得使用一个非 void 返回类型函数返回的值 [CERT_C-ERR33-b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ERR33-c.html">避免空指针引用 [CERT_C-ERR33-c-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ERR33-d.html">始终检查非 void 函数的返回值 [CERT_C-ERR33-d-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ERR34.html">CERT-ERR34_C (RULE) 在将字符串转换为数字时检测错误 [CERT_C-ERR34]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-ERR34-a.html">不得使用库stdlib.h中的库函数atof，atoi和atol [CERT_C-ERR34-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP00.html">CERT-EXP00_C (REC) 使用括号作为操作的优先级 [CERT_C-EXP00]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP00-a.html">如果操作符的优先级低于算术运算符，应该使用圆括号明确表达式的操作顺序 [CERT_C-EXP00-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP02.html">CERT-EXP02_C (REC) 注意逻辑 AND 和 OR 运算符的短路行为 [CERT_C-EXP02]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP02-a.html">逻辑&amp;&amp;或||运算符的右操作数不得含有副作用 [CERT_C-EXP02-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP05.html">CERT-EXP05_C (REC) 不要舍弃常量资格（const qualification） [CERT_C-EXP05]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP05-a.html">强制转换不得从指针或引用类型中删除任何“const”或“volatile”限定条件 [CERT_C-EXP05-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP08.html">CERT-EXP08_C (REC) 确保正确使用指针算法 [CERT_C-EXP08]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP08-a.html">不应该使用指针算法 [CERT_C-EXP08-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP08-b.html">避免访问数组越界 [CERT_C-EXP08-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP10.html">CERT-EXP10_C (REC) 不依赖于子表达式的评价顺序或副作用发生的顺序 [CERT_C-EXP10]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP10-a.html">表达式的值应该在任何标准允许的赋值顺序下是一样的 [CERT_C-EXP10-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP10-b.html">不要编写依赖于函数参数求值顺序的代码 [CERT_C-EXP10-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP10-c.html">不要编写依赖于函数标志符和函数参数的求值顺序的代码 [CERT_C-EXP10-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP10-d.html">涉及一个函数调用时，不要编写依赖表达式求值顺序的代码 [CERT_C-EXP10-d-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP12.html">CERT-EXP12_C (REC) 不要忽略函数返回的值 [CERT_C-EXP12]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP12-a.html">应该使用具有非 void 返回类型的函数返回值 [CERT_C-EXP12-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP12-b.html">不得使用一个非 void 返回类型函数返回的值 [CERT_C-EXP12-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP14.html">CERT-EXP14_C (REC) 在对小于int的整数类型执行按位操作时，要注意整数提升 [CERT_C-EXP14]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP14-a.html">避免在同一个表达式中混合使用不同精度的算术运算 [CERT_C-EXP14-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP15.html">CERT-EXP15_C (REC) 不要将分号放在 if, for, 或者 while 语句的同一行上 [CERT_C-EXP15]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP15-a.html">分号的可疑使用 [CERT_C-EXP15-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP16.html">CERT-EXP16_C (REC) 不要将函数指针与常数值进行比较 [CERT_C-EXP16]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP16-a.html">函数地址不应与零相比较 [CERT_C-EXP16-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP19.html">CERT-EXP19_C (REC) 对if、for或while语句的主体使用花括号 [CERT_C-EXP19]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP19-a.html">'switch', 'while', 'do...while' 或 'for' 语句的主体应该是复合语句 [CERT_C-EXP19-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP20.html">CERT-EXP20_C (REC) 执行显式测试以确定成功（success）、正确（ true）、错误（false）和相等（equality） [CERT_C-EXP20]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP20-a.html">避免使用相等运算符 ("==", "!=") 来对 TRUE 宏/枚举(enum)常量进行值比较 [CERT_C-EXP20-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP30.html">CERT-EXP30_C (RULE) 不依赖于副作用的评估顺序 [CERT_C-EXP30]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP30-a.html">表达式的值应该在任何标准允许的赋值顺序下是一样的 [CERT_C-EXP30-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP30-b.html">不要编写依赖于函数参数求值顺序的代码 [CERT_C-EXP30-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP30-c.html">不要编写依赖于函数标志符和函数参数的求值顺序的代码 [CERT_C-EXP30-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP30-d.html">涉及一个函数调用时，不要编写依赖表达式求值顺序的代码 [CERT_C-EXP30-d-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP32.html">CERT-EXP32_C (RULE) 不要通过非易失性引用（nonvolatile reference）访问易失性对象（volatile object） [CERT_C-EXP32]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP32-a.html">强制转换不得从指针或引用类型中删除任何“const”或“volatile”限定条件 [CERT_C-EXP32-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP33.html">CERT-EXP33_C (RULE) 不读取未初始化的内存 [CERT_C-EXP33]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP33-a.html">避免在初始化之前使用 [CERT_C-EXP33-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP34.html">CERT-EXP34_C (RULE) 不要解除空指针引用 [CERT_C-EXP34]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP34-a.html">避免空指针引用 [CERT_C-EXP34-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP35.html">CERT-EXP35_C (RULE) 不要修改具有临时生存期的对象 [CERT_C-EXP35]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP35-a.html">在函数调用的结果中不访问数组 [CERT_C-EXP35-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP36.html">CERT-EXP36_C (RULE) 不将指针转换为更严格对齐的指针类型 [CERT_C-EXP36]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP36-a.html">不允许不同的指针对象之间进行强制转换 [CERT_C-EXP36-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP37.html">CERT-EXP37_C (RULE) 用正确的参数和类型调用函数 [CERT_C-EXP37]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP37-a.html">在函数原型声明中应该为所有参数提供标识符 [CERT_C-EXP37-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP37-b.html">函数类型应该包含具体名称的参数 [CERT_C-EXP37-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP37-c.html">函数类型应当为原型形式 [CERT_C-EXP37-c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP37-d.html">在函数调用时，函数总是有可见的原型 [CERT_C-EXP37-d-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP39.html">CERT-EXP39_C (RULE) 不能通过不兼容类型的指针来访问变量 [CERT_C-EXP39]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP39-a.html">避免隐式的整型和浮点类型的转换 [CERT_C-EXP39-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP39-b.html">不允许不同的指针对象之间进行强制转换 [CERT_C-EXP39-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP39-c.html">避免访问数组和指针越界 [CERT_C-EXP39-c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP39-d.html">避免由于定义不正确的格式限制而导致受污染数据的缓冲区溢出 [CERT_C-EXP39-d-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP39-e.html">避免来自受污染数据的缓冲区读取溢出 [CERT_C-EXP39-e-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP39-f.html">避免来自受污染数据的缓冲区写入溢出 [CERT_C-EXP39-f-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP40.html">CERT-EXP40_C (RULE) 不要修改常量对象 [CERT_C-EXP40]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP40-a.html">强制转换不得从指针或引用类型中删除任何“const”或“volatile”限定条件 [CERT_C-EXP40-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP42.html">CERT-EXP42_C (RULE) 不要比较填充数据 [CERT_C-EXP42]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP42-a.html">不能对非 POD 使用 memcpy 或 memcmp [CERT_C-EXP42-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP43.html">CERT-EXP43_C (RULE) 在使用限制条件指针时避免未定义的行为 [CERT_C-EXP43]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP43-a.html">不得使用严格的类型限定符 [CERT_C-EXP43-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP44.html">CERT-EXP44_C (RULE) 不要依赖于 sizeof、_Alignof 或 _Generic 的操作数的副作用 [CERT_C-EXP44]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP44-a.html">不应在sizeof运算符的操作数中访问由volatile左值指定的对象 [CERT_C-EXP44-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP44-b.html">会导致副作用的函数调用不应该用作 sizeof 运算符的操作数 [CERT_C-EXP44-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP45.html">CERT-EXP45_C (RULE) 不要在选择语句中执行任务 [CERT_C-EXP45]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP45-b.html">赋值操作符不得使用在没有括号的条件中 [CERT_C-EXP45-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP45-d.html">禁止在产生布尔值的表达式中使用赋值运算符 [CERT_C-EXP45-d-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP46.html">CERT-EXP46_C (RULE) 不要将位操作符与类似于boolean的操作数一起使用 [CERT_C-EXP46]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP46-a.html">逻辑运算符 (&amp;&amp;, || 和 !) 的操作数应该是有效的布尔值 [CERT_C-EXP46-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP46-b.html">有效布尔值的表达式不应该用作除 (&amp;&amp;, ||, !, =, ==, !=, ?:) 之外的运算符的操作数。 [CERT_C-EXP46-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP47.html">CERT-EXP47_C (RULE) 不要使用不正确类型的参数调用va_arg [CERT_C-EXP47]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-EXP47-a.html">不要使用错误的参数类型调用va_arg [CERT_C-EXP47-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO01.html">CERT-FIO01_C (REC) 使用文件名作为函数的标识时要小心 [CERT_C-FIO01]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO01-a.html">不要使用 chmod(), chown(), chgrp() [CERT_C-FIO01-a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO01-b.html">不允许使用容易发生争用的函数 [CERT_C-FIO01-b-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO21.html">CERT-FIO21_C (REC) 不要在共享目录中创建临时文件 [CERT_C-FIO21]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO21-a.html">不允许使用容易发生争用的函数 [CERT_C-FIO21-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO22.html">CERT-FIO22_C (REC) 在生成过程之前关闭文件 [CERT_C-FIO22]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO22-a.html">确保资源已释放 [CERT_C-FIO22-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO24.html">CERT-FIO24_C (REC) 不要打开已经打开的文件 [CERT_C-FIO24]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO24-a.html">避免访问文件的资源竞争 [CERT_C-FIO24-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO30.html">CERT-FIO30_C (RULE) 从格式字符串中排除用户输入 [CERT_C-FIO30]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO30-a.html">避免调用只有一个参数而不是字符串常量的函数 printf/wprintf [CERT_C-FIO30-a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO30-b.html">当第二个参数是变量时，避免使用只有两个参数的函数 fprintf/fwprintf [CERT_C-FIO30-b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO30-c.html">禁止使用来自不信任用户的未经过滤的数据作为格式化参数 [CERT_C-FIO30-c-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO32.html">CERT-FIO32_C (RULE) 不要在只适合文件的设备上执行操作 [CERT_C-FIO32]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO32-a.html">防止文件名注入 [CERT_C-FIO32-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO34.html">CERT-FIO34_C (RULE) 区分从文件中读取的字符、EOF 或 WEOF  [CERT_C-FIO34]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO34-a.html">避免从更宽到更窄的类型的隐式转换 [CERT_C-FIO34-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO37.html">CERT-FIO37_C (RULE) 不要假设 fgets() 或 fgetws() 成功时返回一个非空字符串 [CERT_C-FIO37]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO37-a.html">避免访问数组越界 [CERT_C-FIO37-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO38.html">CERT-FIO38_C (RULE) 不复制文件（FILE）对象 [CERT_C-FIO38]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO38-a.html">指针指向了不能引用的文件对象 [CERT_C-FIO38-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO39.html">CERT-FIO39_C (RULE) 在没有介入flush（intervening flush）或定位调用（positioning call）的情况下不要交替从一个流输入和输出 [CERT_C-FIO39]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO39-a.html">不要从一个流中交替地输入和输出，却没有间隔刷新或定位调用 [CERT_C-FIO39-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO40.html">CERT-FIO40_C (RULE) 在 fgets() 或 fgetws() 的失败上重置字符串 [CERT_C-FIO40]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO40-a.html">通过 fgets() 或 fgetws() 重置字符串失败 [CERT_C-FIO40-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO41.html">CERT-FIO41_C (RULE) 不要使用带有副作用的流参数调用 getc()、putc()、getwc() 或 putwc() [CERT_C-FIO41]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO41-a.html">表达式的值应该在任何标准允许的赋值顺序下是一样的 [CERT_C-FIO41-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO41-b.html">不要编写依赖于函数参数求值顺序的代码 [CERT_C-FIO41-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO41-c.html">不要编写依赖于函数标志符和函数参数的求值顺序的代码 [CERT_C-FIO41-c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO41-d.html">涉及一个函数调用时，不要编写依赖表达式求值顺序的代码 [CERT_C-FIO41-d-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO41-e.html">包含递增(++)或递减(-)运算符的完整表达式应该没有其他潜在的副作用 [CERT_C-FIO41-e-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO42.html">CERT-FIO42_C (RULE) 当不再需要文件时关闭它们 [CERT_C-FIO42]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO42-a.html">确保资源已释放 [CERT_C-FIO42-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO44.html">CERT-FIO44_C (RULE) 只将从 fgetpos() 返回的值用于 fsetpos() [CERT_C-FIO44]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO44-a.html">只对 fsetpos() 使用从 fgetpos() 返回的值 [CERT_C-FIO44-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO45.html">CERT-FIO45_C (RULE) 在访问文件时避免 TOCTOU 竞态条件 [CERT_C-FIO45]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO45-a.html">避免访问文件的资源竞争 [CERT_C-FIO45-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO46.html">CERT-FIO46_C (RULE) 不要访问已关闭的文件 [CERT_C-FIO46]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO46-a.html">不得使用已经释放掉的资源 [CERT_C-FIO46-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO47.html">CERT-FIO47_C (RULE) 使用有效的格式字符串 [CERT_C-FIO47]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO47-a.html">在调用字符串格式化函数时，格式字符串中的'%s'和'%c'格式说明符及其对应的参数不应该不匹配 [CERT_C-FIO47-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO47-b.html">在调用字符串格式化函数时，格式字符串中的'%f'格式说明符及其对应的参数之间不应存在不匹配 [CERT_C-FIO47-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO47-c.html">在调用字符串格式化函数时，字符串中的“%i”和“%d”格式说明符及其对应的参数不应该不匹配 [CERT_C-FIO47-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO47-d.html">在调用字符串格式化函数时，格式字符串中的'%u'格式说明符及其对应的参数之间不应存在不匹配 [CERT_C-FIO47-d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO47-e.html">在调用字符串格式化函数时，格式字符串中的'%p'格式说明符及其对应的参数之间不应存在不匹配 [CERT_C-FIO47-e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FIO47-f.html">格式字符串中的格式说明符的数量和调用字符串格式化函数时相应的参数的数量应该相等 [CERT_C-FIO47-f-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FLP00.html">CERT-FLP00_C (REC) 了解浮点数的局限性 [CERT_C-FLP00]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FLP00-a.html">禁止对浮点数类型的表达式做相等或不相等的比较 [CERT_C-FLP00-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FLP02.html">CERT-FLP02_C (REC) 当需要精确计算时，避免使用浮点数 [CERT_C-FLP02]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FLP02-a.html">禁止对浮点数类型的表达式做相等或不相等的比较 [CERT_C-FLP02-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FLP03.html">CERT-FLP03_C (REC) 检测和处理浮点错误 [CERT_C-FLP03]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FLP03-a.html">避免除零错误 [CERT_C-FLP03-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FLP03-b.html">避免宽字段到窄字段浮点型数据的隐式转换 [CERT_C-FLP03-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FLP03-c.html">避免隐式的窄字段到宽字段浮点型数据转换 [CERT_C-FLP03-c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FLP03-d.html">避免将浮点数从较宽的浮点类型隐式转换为较窄的浮点类型 [CERT_C-FLP03-d-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FLP06.html">CERT-FLP06_C (REC) 为浮点操作将整数转换为浮点数 [CERT_C-FLP06]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FLP06-a.html">不应使用可能导致信息丢失的从整型到浮点型的隐式转换 [CERT_C-FLP06-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FLP06-b.html">不应使用可能会导致信息丢失的从整数常量到浮点类型的隐式转换 [CERT_C-FLP06-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FLP30.html">CERT-FLP30_C (RULE) 不使用浮点变量作为循环计数器 [CERT_C-FLP30]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FLP30-a.html">不得使用浮点变量作为循环计数器 [CERT_C-FLP30-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FLP32.html">CERT-FLP32_C (RULE) 防止或检测数学函数中的域和范围错误 [CERT_C-FLP32]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FLP32-a.html">验证传递给库函数的值 [CERT_C-FLP32-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FLP34.html">CERT-FLP34_C (RULE) 确保浮点转换在新类型的范围内 [CERT_C-FLP34]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FLP34-a.html">避免从更宽到更窄的类型的隐式转换 [CERT_C-FLP34-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FLP36.html">CERT-FLP36_C (RULE) 将整数值转换为浮点类型时保持精度 [CERT_C-FLP36]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FLP36-a.html">不应使用可能导致信息丢失的从整型到浮点型的隐式转换 [CERT_C-FLP36-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FLP36-b.html">不应使用可能会导致信息丢失的从整数常量到浮点类型的隐式转换 [CERT_C-FLP36-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FLP37.html">CERT-FLP37_C (RULE) 不要使用对象来比较浮点值 [CERT_C-FLP37]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-FLP37-c.html">不要使用对象表示比较浮点值 [CERT_C-FLP37-c-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT02.html">CERT-INT02_C (REC) 了解整数转换规则 [CERT_C-INT02]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT02-a.html">不应使用可能导致信息丢失的从较宽到较窄的整数类型的隐式转换 [CERT_C-INT02-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT02-b.html">避免在同一个表达式中混合使用不同精度的算术运算 [CERT_C-INT02-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT04.html">CERT-INT04_C (REC) 强制限制来自受污染源（tainted sources）的整数值 [CERT_C-INT04]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT04-a.html">防止来自受污染数据的整数溢出/下溢 [CERT_C-INT04-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT04-b.html">避免来自受污染数据的缓冲区读取溢出 [CERT_C-INT04-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT04-c.html">避免来自受污染数据的缓冲区写入溢出 [CERT_C-INT04-c-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT05.html">CERT-INT05_C (REC) 如果不能处理所有可能的输入，不要使用输入函数转换字符数据 [CERT_C-INT05]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT05-a.html">避免使用不安全的不检查界限的字符串函数 [CERT_C-INT05-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT07.html">CERT-INT07_C (REC) 对数值使用显式符号或无符号字符类型 [CERT_C-INT07]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT07-a.html">普通字符(plain char)类型只能用于存储和使用字符值 [CERT_C-INT07-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT07-b.html">带符号的 char 和 不带符号的 char 类型只能用于存储和数值类型 [CERT_C-INT07-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT08.html">CERT-INT08_C (REC) 验证所有整数值在范围内 [CERT_C-INT08]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT08-a.html">避免整数溢出 [CERT_C-INT08-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT09.html">CERT-INT09_C (REC) 确保枚举常量映射到唯一值 [CERT_C-INT09]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT09-a.html">在枚举类型中，要么仅对第一个元素进行显式地初始化，要么所有元素都进行显式的初始化 [CERT_C-INT09-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT10.html">CERT-INT10_C (REC) 使用 % 运算符时不要假设余数为正 [CERT_C-INT10]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT10-a.html">避免访问数组越界 [CERT_C-INT10-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT12.html">CERT-INT12_C (REC) 在表达式中使用普通 int 位域（plain int bit-field）时，不要对其类型进行假设 [CERT_C-INT12]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT12-a.html">只能将位域定义为有符号的整型或无符号的整型 [CERT_C-INT12-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT13.html">CERT-INT13_C (REC) 只在无符号操作数上使用位操作符 [CERT_C-INT13]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT13-a.html">位运算符应只适用于无符号的基本类型操作数 [CERT_C-INT13-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT15.html">CERT-INT15_C (REC) 对程序员定义的整数类型使用 intmax_t 或 uintmax_t 进行格式化的 IO [CERT_C-INT15]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT15-a.html">不应该使用 char, int, short, long, float and double 的基本类型, 而是应该用 typedef 来定义特定长度的等量 [CERT_C-INT15-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT16.html">CERT-INT16_C (REC) 不要假设有符号整数的表示 [CERT_C-INT16]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT16-a.html">位运算符应只适用于无符号的基本类型操作数 [CERT_C-INT16-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT18.html">CERT-INT18_C (REC) 在比较或指定整数表达式的大小之前，先计算较大的整数表达式 [CERT_C-INT18]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT18-a.html">避免在将结果赋给更大整数类型的变量的表达式中可能出现的整数溢出 [CERT_C-INT18-a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT18-b.html">避免在将结果与更广泛的整数类型的表达式进行比较的表达式中可能出现的整数溢出 [CERT_C-INT18-b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT18-c.html">避免在将结果转换为更广泛的整数类型的表达式中可能出现的整数溢出 [CERT_C-INT18-c-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT30.html">CERT-INT30_C (RULE) 确保无符号整数操作不隐藏 [CERT_C-INT30]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT30-a.html">避免整数溢出 [CERT_C-INT30-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT30-b.html">'+'， '-'， '*' 运算符常量表达式中的整数溢出或下溢 [CERT_C-INT30-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT30-c.html">'&lt;&lt;' 运算符常量表达式中的整数溢出或下溢 [CERT_C-INT30-c-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT31.html">CERT-INT31_C (RULE) 确保整数转换不会导致数据丢失或错误解释 [CERT_C-INT31]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT31-a.html">当操作数是布尔值时应该使用布尔类型的表达式 [CERT_C-INT31-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT31-b.html">本质为布尔类型的操作数不应该用在需要使用数值操作数的地方 [CERT_C-INT31-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT31-c.html">字符类型的操作数不应该用在需要数类型的地方 [CERT_C-INT31-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT31-d.html">在算术运算中不应该使用枚举类型 [CERT_C-INT31-d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT31-e.html">不要对有符号类型和枚举类型使用移位和位运算 [CERT_C-INT31-e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT31-f.html">本质上带符号或枚举类型的操作数不应用作移位操作符的右侧操作数 [CERT_C-INT31-f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT31-g.html">一元减运算符的操作数不应该是无符号类型 [CERT_C-INT31-g-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT31-h.html">表达式的值不能赋给更小类型的对象 [CERT_C-INT31-h-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT31-i.html">表达式的值不应赋给另一基本类型类别的对象 [CERT_C-INT31-i-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT31-j.html">通常算数运算符的两边的操作数应该是相同类型 [CERT_C-INT31-j-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT31-k.html">第二个和第三个三元操作符的操作数有相同的基本类型分类 [CERT_C-INT31-k-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT31-l.html">复合表达式的值不应该赋值给宽数据类型的一个对象 [CERT_C-INT31-l-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT31-m.html">如果复合表达式作为一个操作数用于通常的算术运算并与比它位数宽的操作数进行运算时将报告违规 [CERT_C-INT31-m-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT31-n.html">如果复合表达式被用于条件运算符的操作数，那么其他操作数不应该有更宽的类型 [CERT_C-INT31-n-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT31-o.html">避免整数溢出 [CERT_C-INT31-o-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT32.html">CERT-INT32_C (RULE) 确保对有符号整数的操作不会导致溢出 [CERT_C-INT32]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT32-a.html">避免整数溢出 [CERT_C-INT32-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT32-b.html">'+'， '-'， '*' 运算符常量表达式中的整数溢出或下溢 [CERT_C-INT32-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT32-c.html">'&lt;&lt;' 运算符常量表达式中的整数溢出或下溢 [CERT_C-INT32-c-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT33.html">CERT-INT33_C (RULE) 确保除法和求余数操作不会导致除零错误 [CERT_C-INT33]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT33-a.html">避免除零错误 [CERT_C-INT33-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT34.html">CERT-INT34_C (RULE) 不要通过负位数或则通过大于或等于操作数中存在的位数来转变表达式 [CERT_C-INT34]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT34-a.html">移位运算符右操作数的无效范围 [CERT_C-INT34-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT35.html">CERT-INT35_C (RULE) 使用正确的整数精度 [CERT_C-INT35]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT35-a.html">检查shift操作符的右手操作数时，请使用正确的整数精度 [CERT_C-INT35-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT36.html">CERT-INT36_C (RULE) 将指针转换为整数或将整数转换为指针 [CERT_C-INT36]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-INT36-b.html">不应在指向对象类型的指针与除 'uintptr_t' 或 'intptr_t' 以外的整数类型之间执行转换 [CERT_C-INT36-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM00.html">CERT-MEM00_C (REC) 在相同抽象级别的相同模块中分配和释放内存 [CERT_C-MEM00]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM00-a.html">不要分配内存后期望其他人稍后去释放 [CERT_C-MEM00-a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM00-b.html">不要分配内存后期望其他人稍后去释放 [CERT_C-MEM00-b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM00-c.html">不要分配内存后期望其他人稍后去释放它 [CERT_C-MEM00-c-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM00-d.html">不得使用已经释放掉的资源 [CERT_C-MEM00-d-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM00-e.html">确保资源已释放 [CERT_C-MEM00-e-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM01.html">CERT-MEM01_C (REC) 在 free() 之后立即在指针中存储一个新值 [CERT_C-MEM01]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM01-a.html">不得使用已经释放掉的资源 [CERT_C-MEM01-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM01-b.html">始终将一个新值赋给指向已释放内存的表达式 [CERT_C-MEM01-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM01-c.html">始终将一个新值赋给指向已释放内存的全局或成员变量 [CERT_C-MEM01-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM01-d.html">总是为指向释放内存的参数或局部变量分配新值 [CERT_C-MEM01-d-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM02.html">CERT-MEM02_C (REC) 将内存分配函数调用的结果立即强制类型转换为分配类型的指针 [CERT_C-MEM02]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM02-a.html">赋值运算符应该具有兼容类型的操作数 [CERT_C-MEM02-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM02-b.html">不给不兼容类型的变量赋函数返回值 [CERT_C-MEM02-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM04.html">CERT-MEM04_C (REC) 当心零长度分配 [CERT_C-MEM04]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM04-a.html">应检查传递给库函数的值的有效性 [CERT_C-MEM04-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM05.html">CERT-MEM05_C (REC) 避免大量的堆栈分配 [CERT_C-MEM05]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM05-a.html">不要使用递归 [CERT_C-MEM05-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM05-b.html">确保可变长度数组的大小在有效范围内 [CERT_C-MEM05-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM07.html">CERT-MEM07_C (REC) 确保对calloc()的参数在相乘时,不要重复 [CERT_C-MEM07]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM07-a.html">应检查传递给库函数的值的有效性 [CERT_C-MEM07-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM12.html">CERT-MEM12_C (REC) 在使用和释放资源时发生错误要离开函数时，考虑使用 goto 链 [CERT_C-MEM12]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM12-a.html">确保资源已释放 [CERT_C-MEM12-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM30.html">CERT-MEM30_C (RULE) 不访问已经释放的内存 [CERT_C-MEM30]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM30-a.html">不得使用已经释放掉的资源 [CERT_C-MEM30-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM31.html">CERT-MEM31_C (RULE) 当不再需要时释放动态分配的内存 [CERT_C-MEM31]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM31-a.html">确保资源已释放 [CERT_C-MEM31-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM33.html">CERT-MEM33_C (RULE) 动态分配和复制包含灵活数组成员的结构 [CERT_C-MEM33]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM33-a.html">动态分配包含灵活数组成员的结构 [CERT_C-MEM33-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM33-b.html">不要复制包含柔性数组成员的结构的实例 [CERT_C-MEM33-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM34.html">CERT-MEM34_C (RULE) 只有空闲内存被动态分配 [CERT_C-MEM34]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM34-a.html">不得使用无效的指针释放资源 [CERT_C-MEM34-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM35.html">CERT-MEM35_C (RULE) 为对象分配足够的内存 [CERT_C-MEM35]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM35-a.html">不要在指针类型上使用 sizeof 操作符来指定通过 'malloc'， 'calloc' 或 'realloc' 函数分配的内存大小 [CERT_C-MEM35-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM36.html">CERT-MEM36_C (RULE) 不要通过调用 realloc() 来修改对象的对齐方式 [CERT_C-MEM36]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MEM36-a.html">不要通过调用 realloc() 修改对象的对齐方式 [CERT_C-MEM36-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC01.html">CERT-MSC01_C (REC) 争取逻辑完整性 [CERT_C-MSC01]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC01-a.html">所有 'if...else-if' 结构应使用一个 'else' 子句终止 [CERT_C-MSC01-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC01-b.html">switch 语句中最后必须为 default 子句 [CERT_C-MSC01-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC04.html">CERT-MSC04_C (REC) 一致地以可读的方式使用注释 [CERT_C-MSC04]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC04-a.html">禁止在 C 语言风格的注释中使用 /* 字符序列 [CERT_C-MSC04-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC04-b.html">字符序列 // 不得被用于 C 语言风格的注释中 [CERT_C-MSC04-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC04-c.html">字符序列 /* 不得被用于 C++ 语言风格的注释中 [CERT_C-MSC04-c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC04-d.html">不得在 // 注释中使用行合并 [CERT_C-MSC04-d-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC07.html">CERT-MSC07_C (REC) 检测和删除死代码 [CERT_C-MSC07]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC07-a.html">在 "else" 语句块中不应存在执行不到的代码 [CERT_C-MSC07-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC07-b.html">在 'return', 'break', 'continue', 和 'goto' 语句之后不应存在执行不到的代码 [CERT_C-MSC07-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC07-c.html">在 "if/else/while/for" 语句块中不应存在执行不到的代码 [CERT_C-MSC07-c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC07-d.html">在 switch 语句中不应存在执行不到的代码 [CERT_C-MSC07-d-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC07-e.html">在 'for' 循环中不应存在执行不到的代码 [CERT_C-MSC07-e-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC07-f.html">在 'if' 或 'switch' 语句后不应存在不可访问的代码 [CERT_C-MSC07-f-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC07-g.html">在 while/for/do...while 循环内的 "if" 或 "switch" 语句后不应存在执行不到的代码 [CERT_C-MSC07-g-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC07-h.html">避免具有无法到达分支的开关语句 [CERT_C-MSC07-h-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC09.html">CERT-MSC09_C (REC) 字符编码:为安全起见，使用 ASCII 子集 [CERT_C-MSC09]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC09-a.html">只使用 ISO C 标准中定义的字符 [CERT_C-MSC09-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC11.html">CERT-MSC11_C (REC) 使用断言合并诊断测试 [CERT_C-MSC11]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC11-a.html">广泛地使用断言证明内部假设和不变式 [CERT_C-MSC11-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC12.html">CERT-MSC12_C (REC) 检测和删除无效或从未执行的代码 [CERT_C-MSC12]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC12-a.html">在 "else" 语句块中不应存在执行不到的代码 [CERT_C-MSC12-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC12-b.html">在 'return', 'break', 'continue', 和 'goto' 语句之后不应存在执行不到的代码 [CERT_C-MSC12-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC12-c.html">在 "if/else/while/for" 语句块中不应存在执行不到的代码 [CERT_C-MSC12-c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC12-d.html">在 switch 语句中不应存在执行不到的代码 [CERT_C-MSC12-d-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC12-e.html">在 'for' 循环中不应存在执行不到的代码 [CERT_C-MSC12-e-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC12-f.html">在 'if' 或 'switch' 语句后不应存在不可访问的代码 [CERT_C-MSC12-f-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC12-g.html">在 while/for/do...while 循环内的 "if" 或 "switch" 语句后不应存在执行不到的代码 [CERT_C-MSC12-g-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC12-h.html">避免具有无法到达分支的开关语句 [CERT_C-MSC12-h-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC13.html">CERT-MSC13_C (REC) 检测和删除未使用的值 [CERT_C-MSC13]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC13-a.html">避免使用不必要的局部变量 [CERT_C-MSC13-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC14.html">CERT-MSC14_C (REC) 不引入不必要的平台依赖 [CERT_C-MSC14]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC14-a.html">对常量无符号整数表达式的求值不应该导致循环 [CERT_C-MSC14-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC15.html">CERT-MSC15_C (REC) 不要依赖于未定义的行为 [CERT_C-MSC15]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC15-a.html">对常量无符号整数表达式的求值不应该导致循环 [CERT_C-MSC15-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC17.html">CERT-MSC17_C (REC) 用break语句结束与case标签相关联的每一组语句 [CERT_C-MSC17]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC17-a.html">switch 语句中各 case 之间缺失 break 语句 [CERT_C-MSC17-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC19.html">CERT-MSC19_C (REC) 对于返回数组的函数，最好返回空数组而不是null值 [CERT_C-MSC19]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC19-a.html">避免访问数组越界 [CERT_C-MSC19-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC19-b.html">避免空指针引用 [CERT_C-MSC19-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC22.html">CERT-MSC22_C (REC) 安全地使用 setjmp()、longjmp() 工具 [CERT_C-MSC22]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC22-a.html">不使用 setjmp 宏和 longjmp 函数 [CERT_C-MSC22-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC24.html">CERT-MSC24_C (REC) 不要使用废弃或过时的函数 [CERT_C-MSC24]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC24-a.html">不得使用库stdlib.h中的库函数atof，atoi和atol [CERT_C-MSC24-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC24-b.html">不得使用 'stdlib.h' 或 'cstdlib' 库中的 'getenv()' 函数 [CERT_C-MSC24-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC24-c.html">避免使用可能导致缓冲区溢出的不安全字符串函数 [CERT_C-MSC24-c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC24-d.html">不要使用不安全的 C 函数来写未检查范围的缓冲区 [CERT_C-MSC24-d-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC30.html">CERT-MSC30_C (RULE) 不使用 rand() 函数生成伪随机数 [CERT_C-MSC30]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC30-a.html">不要使用rand()函数来生成伪随机数 [CERT_C-MSC30-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC32.html">CERT-MSC32_C (RULE) 正确地生成伪随机数字发生器 [CERT_C-MSC32]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC32-a.html">避免使用标准 C 库中随机数的函数 [CERT_C-MSC32-a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC32-b.html">不要使用rand()函数来生成伪随机数 [CERT_C-MSC32-b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC32-c.html">出于安全考虑，不应该使用标准随机数生成器来生成随机性 [CERT_C-MSC32-c-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC32-d.html">在伪随机数生成器中指定适当的种子 [CERT_C-MSC32-d-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC33.html">CERT-MSC33_C (RULE) 不要将无效数据传递给 asctime() 函数 [CERT_C-MSC33]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC33-a.html">避免使用标准 C 库中与时间有关的函数 [CERT_C-MSC33-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC37.html">CERT-MSC37_C (RULE) 确保控制永远不会到达非 void 函数的末尾 [CERT_C-MSC37]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC37-a.html">非 void 返回类型的函数的所有退出路径应该有一个明确的包含表达式的返回语句 [CERT_C-MSC37-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC38.html">CERT-MSC38_C (RULE) 如果预定义的标识符可能只实现为宏（macro），那么不要将其视为对象 [CERT_C-MSC38]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC38-a.html">类似函数的宏在调用时参数个数必须一致 [CERT_C-MSC38-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC39.html">CERT-MSC39_C (RULE) 不要在具有不定值的 va_list 上调用 va_arg() [CERT_C-MSC39]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC39-a.html">正确地使用可变参数的宏 [CERT_C-MSC39-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC40.html">CERT-MSC40_C (RULE) 不要违反约束 [CERT_C-MSC40]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC40-a.html">带有外部链接的函数的内联定义不应包含静态对象的定义和使用 [CERT_C-MSC40-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC41.html">CERT-MSC41_C (RULE) 不硬编码敏感信息 [CERT_C-MSC41]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-MSC41-a.html">不要硬编码字符串文字 [CERT_C-MSC41-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS30.html">CERT-POS30_C (RULE) 正确使用 readlink() 函数 [CERT_C-POS30]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS30-a.html">避免由于读取非零终止字符串导致的溢出 [CERT_C-POS30-a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS30-b.html">应当使用函数 'read' 和 'readlink' 返回的值 [CERT_C-POS30-b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS30-c.html">期望以 null 结尾的字符串为参数的函数可能使用不以 null 结尾的字符串 [CERT_C-POS30-c-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS33.html">CERT-POS33_C (RULE) 不要使用 vfork()  [CERT_C-POS33]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS33-a.html">避免使用 'vfork()' 函数 [CERT_C-POS33-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS34.html">CERT-POS34_C (RULE) 不要使用指向自动变量作为参数的指针调用  putenv()  [CERT_C-POS34]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS34-a.html">限制使用系统属性（环境变量） [CERT_C-POS34-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS34-b.html">不要调用 putenv() 使用一个指向自动变量的指针作为参数 [CERT_C-POS34-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS35.html">CERT-POS35_C (RULE) 在检查符号链接是否存在时，要避免竞态条件 [CERT_C-POS35]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS35-a.html">不允许使用容易发生争用的函数 [CERT_C-POS35-a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS35-b.html">在检查符号链接是否存在时避免竞争条件 [CERT_C-POS35-b-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS36.html">CERT-POS36_C (RULE) 在放弃特权的同时遵守正确的撤销命令 [CERT_C-POS36]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS36-a.html">在放弃特权时遵守正确的撤销命令 [CERT_C-POS36-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS37.html">CERT-POS37_C (RULE) 确保特权的放弃是成功的 [CERT_C-POS37]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS37-a.html">确保成功地放弃特权 [CERT_C-POS37-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS38.html">CERT-POS38_C (RULE) 使用fork和文件描述符时要注意竞态条件 [CERT_C-POS38]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS38-a.html">当使用 fork 和文件描述符时避免竞争条件 [CERT_C-POS38-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS39.html">CERT-POS39_C (RULE) 在系统之间传输数据时使用正确的字节顺序 [CERT_C-POS39]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS39-a.html">在系统之间传输数据时使用正确的字节顺序 [CERT_C-POS39-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS44.html">CERT-POS44_C (RULE) 不使用信号终止线程 [CERT_C-POS44]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS44-a.html">禁止使用信号处理文件 &lt;signal.h&gt; 中的处理函数 [CERT_C-POS44-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS47.html">CERT-POS47_C (RULE) 不要使用可以异步取消的线程 [CERT_C-POS47]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS47-a.html">不应该使用 'PTHREAD_CANCEL_ASYNCHRONOUS'参数来调用函数'pthread_setcanceltype()' [CERT_C-POS47-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS48.html">CERT-POS48_C (RULE) 不解开或销毁另一个POSIX线程的互斥锁 [CERT_C-POS48]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS48-a.html">不要销毁另一个线程的互斥对象 [CERT_C-POS48-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS48-b.html">不释放尚未获得的锁 [CERT_C-POS48-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS49.html">CERT-POS49_C (RULE) 当数据必须由多个线程访问时，提供一个互斥锁，并保证相邻的数据不被访问 [CERT_C-POS49]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS49-a.html">在修改位域时使用锁来防止竞争条件 [CERT_C-POS49-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS50.html">CERT-POS50_C (RULE) 声明 POSIX 线程之间具有适当存储时间的共享对象 [CERT_C-POS50]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS50-a.html">声明具有适当存储时间在 POSIX 线程之间共享的对象 [CERT_C-POS50-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS51.html">CERT-POS51_C (RULE) 通过按照预定义顺序的锁定，避免与 POSIX 线程发生死锁 [CERT_C-POS51]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS51-a.html">不要以不同的顺序获取锁 [CERT_C-POS51-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS52.html">CERT-POS52_C (RULE) 不执行在持有POSIX锁时可能阻塞的操作 [CERT_C-POS52]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS52-a.html">不要在持有一个锁的同时使用阻塞函数 [CERT_C-POS52-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS53.html">CERT-POS53_C (RULE) 在条件变量上不要使用多个互斥锁(mutex)进行并发等待操作 [CERT_C-POS53]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS53-a.html">在条件变量上的并行等待操作不应该使用多个mutex [CERT_C-POS53-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS54.html">CERT-POS54_C (RULE) 检测和处理 POSIX 库错误 [CERT_C-POS54]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS54-a.html">应该使用具有非 void 返回类型的函数返回值 [CERT_C-POS54-a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS54-b.html">不得使用一个非 void 返回类型函数返回的值 [CERT_C-POS54-b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-POS54-c.html">避免空指针引用 [CERT_C-POS54-c-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-PRE00.html">CERT-PRE00_C (REC) 选择内联或静态函数，而不是类似函数的宏 [CERT_C-PRE00]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-PRE00-a.html">函数应该优先于宏函数的使用 [CERT_C-PRE00-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-PRE01.html">CERT-PRE01_C (REC) 在宏中的参数名周围使用括号 [CERT_C-PRE01]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-PRE01-a.html">在函数式宏定义中，每个参数的实例应该被括号括起来，除非它被用于 # 或 ## 操作符 [CERT_C-PRE01-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-PRE02.html">CERT-PRE02_C (REC) 宏替换列表应该被圆括弧括起 [CERT_C-PRE02]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-PRE02-a.html">必须把类函数形式的宏定义放进括号中 [CERT_C-PRE02-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-PRE06.html">CERT-PRE06_C (REC) 使用 include保护机制来包含头文件 [CERT_C-PRE06]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-PRE06-a.html">使用多个包含保护 [CERT_C-PRE06-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-PRE07.html">CERT-PRE07_C (REC) 避免使用重复的问号 [CERT_C-PRE07]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-PRE07-a.html">禁止使用三字母词 [CERT_C-PRE07-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-PRE30.html">CERT-PRE30_C (RULE) 不创建一个通用字符名称贯穿连接（concatenation） [CERT_C-PRE30]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-PRE30-a.html">避免产生通用字符名称的占位符串联 [CERT_C-PRE30-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-PRE31.html">CERT-PRE31_C (RULE) 避免不安全宏参数的副作用 [CERT_C-PRE31]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-PRE31-a.html">包含递增(++)或递减(-)运算符的完整表达式应该没有其他潜在的副作用 [CERT_C-PRE31-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-PRE31-b.html">断言不应该包含赋值，自增或自减运算符 [CERT_C-PRE31-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-PRE31-c.html">断言不应该包含函数调用或者类似于函数的宏调用 [CERT_C-PRE31-c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-PRE31-d.html">避免不安全宏参数造成的不良影响 [CERT_C-PRE31-d-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-PRE32.html">CERT-PRE32_C (RULE) 不要在调用函数类宏时使用预处理器指令 [CERT_C-PRE32]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-PRE32-a.html">类似函数的宏的参数不应该包含类似预处理命令的标识 [CERT_C-PRE32-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-SIG00.html">CERT-SIG00_C (REC) 由不可中断信号处理程序处理的掩码信号 [CERT_C-SIG00]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-SIG00-a.html">禁止使用信号处理文件 &lt;signal.h&gt; 中的处理函数 [CERT_C-SIG00-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-SIG01.html">CERT-SIG01_C (REC) 了解关于信号处理程序持久性的具体实现细节 [CERT_C-SIG01]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-SIG01-a.html">禁止使用信号处理文件 &lt;signal.h&gt; 中的处理函数 [CERT_C-SIG01-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-SIG02.html">CERT-SIG02_C (REC) 避免使用信号来实现正常功能 [CERT_C-SIG02]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-SIG02-a.html">禁止使用信号处理文件 &lt;signal.h&gt; 中的处理函数 [CERT_C-SIG02-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-SIG30.html">CERT-SIG30_C (RULE) 在信号处理程序中只调用异步安全函数 [CERT_C-SIG30]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-SIG30-a.html">正确定义信号处理程序 [CERT_C-SIG30-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-SIG31.html">CERT-SIG31_C (RULE) 不访问信号处理程序中的共享对象 [CERT_C-SIG31]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-SIG31-a.html">正确定义信号处理程序 [CERT_C-SIG31-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-SIG34.html">CERT-SIG34_C (RULE) 不要从可中断信号处理程序中调用 signal()  [CERT_C-SIG34]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-SIG34-a.html">正确定义信号处理程序 [CERT_C-SIG34-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-SIG35.html">CERT-SIG35_C (RULE) 不要从计算异常信号处理程返回 [CERT_C-SIG35]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-SIG35-a.html">不要返回计算异常信号的处理函数 [CERT_C-SIG35-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR00.html">CERT-STR00_C (REC) 使用适当的类型表示字符 [CERT_C-STR00]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR00-a.html">普通字符(plain char)类型只能用于存储和使用字符值 [CERT_C-STR00-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR02.html">CERT-STR02_C (REC) 清理传递给复杂子系统的数据 [CERT_C-STR02]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR02-a.html">防止命令注入 [CERT_C-STR02-a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR02-b.html">防止文件名注入 [CERT_C-STR02-b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR02-c.html">防止 SQL 注入 [CERT_C-STR02-c-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR03.html">CERT-STR03_C (REC) 不要无意截断字符串 [CERT_C-STR03]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR03-a.html">避免由于读取非零终止字符串导致的溢出 [CERT_C-STR03-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR04.html">CERT-STR04_C (REC) 对于基本字符集中的字符使用普通字符 [CERT_C-STR04]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR04-a.html">普通字符(plain char)类型只能用于存储和使用字符值 [CERT_C-STR04-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR05.html">CERT-STR05_C (REC) 当引用字符串字面量时使用指向const的指针 [CERT_C-STR05]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR05-a.html">字符串文字不应被修改 [CERT_C-STR05-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR07.html">CERT-STR07_C (REC) 为现有的字符串操作使用边界检查接口 [CERT_C-STR07]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR07-a.html">避免使用不安全的不检查界限的字符串函数 [CERT_C-STR07-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR09.html">CERT-STR09_C (REC) 不要为带有普通字符类型的表达式假定数字值 [CERT_C-STR09]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR09-a.html">带有类型(普通) char 和 wchar_t 的表达式不能作为内建运算符的操作数，除了 =, ==, != 和一元 &amp; 运算符 [CERT_C-STR09-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR10.html">CERT-STR10_C (REC) 不连接不同类型的字符串字面量 [CERT_C-STR10]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR10-a.html">窄字符串和宽字符串不应该串联在一起 [CERT_C-STR10-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR11.html">CERT-STR11_C (REC) 不指定用字符串字面量初始化的字符数组的界限 [CERT_C-STR11]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR11-a.html">不要指定用字符串文本初始化的字符数组的大小 [CERT_C-STR11-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR30.html">CERT-STR30_C (RULE) 不尝试修改字符串字面量 [CERT_C-STR30]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR30-a.html">字符串文字不应被修改 [CERT_C-STR30-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR30-b.html">不要修改字符串字面量 [CERT_C-STR30-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR31.html">CERT-STR31_C (RULE) 保证字符串存储有足够容纳字符数据和空终止符的空间 [CERT_C-STR31]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR31-a.html">避免访问数组越界 [CERT_C-STR31-a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR31-b.html">避免写入缓冲区时导致的溢出 [CERT_C-STR31-b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR31-c.html">防止来自受污染数据的缓冲区溢出 [CERT_C-STR31-c-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR31-d.html">避免来自受污染数据的缓冲区写入溢出 [CERT_C-STR31-d-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR31-e.html">避免使用可能导致缓冲区溢出的不安全字符串函数 [CERT_C-STR31-e-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR32.html">CERT-STR32_C (RULE) 不将非空终止字符序列传递给需要字符串的库函数 [CERT_C-STR32]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR32-a.html">避免由于读取非零终止字符串导致的溢出 [CERT_C-STR32-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR34.html">CERT-STR34_C (RULE) 在将字符转换为更大的整数大小之前，先将其转换为无符号字符 [CERT_C-STR34]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR34-a.html">避免隐式的整型和浮点类型的转换 [CERT_C-STR34-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR34-b.html">在赋值给较大的整型之前将字符串转换为unsigned char类型 [CERT_C-STR34-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR34-c.html">'signed char' 类型的表达式不应该作为数组下标使用 [CERT_C-STR34-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR34-d.html">在转换为更大的整型之前将字符转换为无符号字符类型 [CERT_C-STR34-d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR34-e.html">避免浮点型到整型的隐式转换 [CERT_C-STR34-e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR34-f.html">不允许不同的指针对象之间进行强制转换 [CERT_C-STR34-f-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR37.html">CERT-STR37_C (RULE) 字符处理函数的参数必须表示为无符号的字符 [CERT_C-STR37]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR37-a.html">不要传递不正确的值给 ctype.h 库函数 [CERT_C-STR37-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR38.html">CERT-STR38_C (RULE) 不混淆窄字符和宽字符的字符串和函数 [CERT_C-STR38]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-STR38-a.html">不要混淆宽窄字符串和函数 [CERT_C-STR38-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-WIN00.html">CERT-WIN00_C (REC) 在动态加载库时要明确 [CERT_C-WIN00]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-WIN00-a.html">谨慎使用以确保 LoadLibrary() 加载正确的库 [CERT_C-WIN00-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-WIN30.html">CERT-WIN30_C (RULE) 正确地配对分配和重分配函数 [CERT_C-WIN30]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_C-WIN30-a.html">确保资源已释放 [CERT_C-WIN30-a-2]</a>
</li></ul>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP.html">SEI CERT C++ [CERT_CPP]</a></b>
<ul>
<li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CON50.html">CERT-CON50_CPP (RULE) 在线程上锁时不要破坏互斥对象 [CERT_CPP-CON50]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CON50-a.html">不要销毁另一个线程的互斥对象 [CERT_CPP-CON50-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CON51.html">CERT-CON51_CPP (RULE) 确保在特殊条件下积极持有的锁被释放 [CERT_CPP-CON51]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CON51-a.html">不要直接在互斥锁上调用lock() [CERT_CPP-CON51-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CON52.html">CERT-CON52_CPP (RULE) 当多个线程访问位字段时，防止数据抢占 [CERT_CPP-CON52]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CON52-a.html">在修改位域时使用锁来防止竞争条件 [CERT_CPP-CON52-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CON53.html">CERT-CON53_CPP (RULE) 按预定顺序加锁以避免死锁 [CERT_CPP-CON53]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CON53-a.html">不要以不同的顺序获取锁 [CERT_CPP-CON53-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CON54.html">CERT-CON54_CPP (RULE) 封装在循环中伪唤醒的函数 [CERT_CPP-CON54]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CON54-a.html">封装可以在循环中伪唤醒的函数 [CERT_CPP-CON54-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CON55.html">CERT-CON55_CPP (RULE) 在使用条件变量时保持线程安全性和活性 [CERT_CPP-CON55]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CON55-a.html">当多个线程在等待同一个条件变量时，不要使用'notify_one()'函数 [CERT_CPP-CON55-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CON56.html">CERT-CON56_CPP (RULE) 不要推测地锁定一个调用线程已经拥有的非递归互斥 [CERT_CPP-CON56]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CON56-a.html">避免双重锁定 [CERT_CPP-CON56-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CTR50.html">CERT-CTR50_CPP (RULE) 保证容器索引和迭代器在有效范围内 [CERT_CPP-CTR50]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CTR50-a.html">保证容器索引在有效范围内 [CERT_CPP-CTR50-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CTR51.html">CERT-CTR51_CPP (RULE) 使用有效引用、指针和迭代器来引用容器的元素 [CERT_CPP-CTR51]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CTR51-a.html">在遍历容器时不要修改容器 [CERT_CPP-CTR51-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CTR52.html">CERT-CTR52_CPP (RULE) 保证库函数不溢出 [CERT_CPP-CTR52]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CTR52-a.html">不要将空容器迭代器作为目标传递给 std 算法 [CERT_CPP-CTR52-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CTR53.html">CERT-CTR53_CPP (RULE) 使用有效的迭代器范围 [CERT_CPP-CTR53]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CTR53-a.html">不要使用一个不是真实范围的迭代器范围 [CERT_CPP-CTR53-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CTR53-b.html">不要比较来自不同容器的迭代器 [CERT_CPP-CTR53-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CTR54.html">CERT-CTR54_CPP (RULE) 不要减去不指同一容器的迭代器 [CERT_CPP-CTR54]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CTR54-a.html">不要比较来自不同容器的迭代器 [CERT_CPP-CTR54-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CTR54-b.html">不要比较两个不相关的指针 [CERT_CPP-CTR54-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CTR55.html">CERT-CTR55_CPP (RULE) 如果结果会溢出,请不要在迭代器上使用加法操作符 [CERT_CPP-CTR55]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CTR55-a.html">不要从迭代器中添加或减去一个值大于1的常量 [CERT_CPP-CTR55-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CTR56.html">CERT-CTR56_CPP (RULE) 不要在多态对象上使用指针算法 [CERT_CPP-CTR56]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CTR56-a.html">不要多形性地对待数组 [CERT_CPP-CTR56-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CTR56-b.html">指向派生类对象数组的指针不应转换为基类指针 [CERT_CPP-CTR56-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CTR56-c.html">没有处理数组为多态 [CERT_CPP-CTR56-c-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CTR57.html">CERT-CTR57_CPP (RULE) 提供有效的排序谓词 [CERT_CPP-CTR57]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CTR57-a.html">禁止对关联容器使用判定相等数值为 true 的比较函数 [CERT_CPP-CTR57-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CTR58.html">CERT-CTR58_CPP (RULE) 谓词函数对象不应该可变 [CERT_CPP-CTR58]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-CTR58-a.html">使谓词常量成为纯函数 [CERT_CPP-CTR58-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-DCL50.html">CERT-DCL50_CPP (RULE) 不要定义 C 语言风格的可变函数 [CERT_CPP-DCL50]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-DCL50-a.html">函数不应使用可变数量的参数定义 [CERT_CPP-DCL50-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-DCL51.html">CERT-DCL51_CPP (RULE) 不要声明或定义保留标识符 [CERT_CPP-DCL51]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-DCL51-a.html">不要使用以下划线开头的带有#define 或 #undef 名称的标识符 [CERT_CPP-DCL51-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-DCL51-b.html">不要重新定义保留字 [CERT_CPP-DCL51-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-DCL51-c.html">不要#define也不要#undef '已定义'的标识 [CERT_CPP-DCL51-c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-DCL51-d.html">标准库宏、对象和函数的名称不应该被重用 [CERT_CPP-DCL51-d-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-DCL51-e.html">不应该重复使用标准库中的宏，对象和函数(C90) [CERT_CPP-DCL51-e-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-DCL51-f.html">标准库宏，对象和函数的名称不得重复使用（C99） [CERT_CPP-DCL51-f-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-DCL52.html">CERT-DCL52_CPP (RULE) 绝不限定一个引用类型为 const 或  volatile [CERT_CPP-DCL52]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-DCL52-a.html">永远不要使用'const'或'volatile'来限定引用类型 [CERT_CPP-DCL52-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-DCL53.html">CERT-DCL53_CPP (RULE) 不要写语法含糊的声明 [CERT_CPP-DCL53]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-DCL53-a.html">在文件的范围内声明函数 [CERT_CPP-DCL53-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-DCL53-b.html">在局部或者函数原型体范围内声明的标识符不应该隐藏一个在全局或者命名空间范围内声明的标识符 [CERT_CPP-DCL53-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-DCL54.html">CERT-DCL54_CPP (RULE) 在相同范围内以成对的形式重载 allocation 和 deallocation 函数 [CERT_CPP-DCL54]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-DCL54-a.html">始终同时提供 new 和 delete 操作符 [CERT_CPP-DCL54-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-DCL55.html">CERT-DCL55_CPP (RULE) 在跨越信任边界传递类对象时避免信息泄漏 [CERT_CPP-DCL55]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-DCL55-a.html">不应将指向结构的指针传递给可将数据复制到用户空间的函数 [CERT_CPP-DCL55-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-DCL56.html">CERT-DCL56_CPP (RULE) 在静态对象的初始化过程中避免循环 [CERT_CPP-DCL56]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-DCL56-a.html">通过用局部静态对象替换非局部静态对象来避免跨越编译单元的初始化顺序问题 [CERT_CPP-DCL56-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-DCL57.html">CERT-DCL57_CPP (RULE) 不要让异常从析构函数或deallocation函数中逃脱 [CERT_CPP-DCL57]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-DCL57-a.html">绝不允许从析构函数、释放函数和交换函数中抛出异常 [CERT_CPP-DCL57-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-DCL57-b.html">始终捕获异常 [CERT_CPP-DCL57-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-DCL58.html">CERT-DCL58_CPP (RULE) 不要修改标准命名空间 [CERT_CPP-DCL58]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-DCL58-a.html">不要修改标准命名空间 'std' 和 'posix' [CERT_CPP-DCL58-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-DCL59.html">CERT-DCL59_CPP (RULE) 不要在头文件中定义不具名的命名空间 [CERT_CPP-DCL59]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-DCL59-a.html">头文件中不应有未命名的命名空间 [CERT_CPP-DCL59-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-DCL60.html">CERT-DCL60_CPP (RULE) 服从单一定义规则 [CERT_CPP-DCL60]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-DCL60-a.html">类，联合体，枚举型名称 (如果有其他修饰符，也包括) 应该是一个唯一的标识符 [CERT_CPP-DCL60-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR50.html">CERT-ERR50_CPP (RULE) 不要突然终止程序 [CERT_CPP-ERR50]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR50-a.html">注册为'std::atexit()'或'std::at_quick_exit()'的函数的执行不应该通过异常退出 [CERT_CPP-ERR50-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR50-b.html">绝不允许从析构函数、释放函数和交换函数中抛出异常 [CERT_CPP-ERR50-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR50-c.html">不要从析构器中抛出 [CERT_CPP-ERR50-c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR50-d.html">至少应该有一个异常处理程序来捕获所有其他未处理的异常 [CERT_CPP-ERR50-d-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR50-e.html">空抛出(throw;)只能用于catch处理程序的复合语句中 [CERT_CPP-ERR50-e-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR50-f.html">只有在程序启动后和终止前才会出现异常情况 [CERT_CPP-ERR50-f-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR50-g.html">在代码中显式抛出的每个异常，在所有可能导致这一点的调用路径中都应该有一个兼容类型的处理程序 [CERT_CPP-ERR50-g-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR50-h.html">如果函数的声明包含异常规范，则该函数只能抛出指定类型的异常 [CERT_CPP-ERR50-h-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR50-i.html">在全局或命名空间作用域中调用的函数不能抛出未处理的异常 [CERT_CPP-ERR50-i-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR50-j.html">始终捕获异常 [CERT_CPP-ERR50-j-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR50-k.html">正确定义退出处理程序 [CERT_CPP-ERR50-k-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR50-l.html">不得使用 'stdlib.h' 或 'cstdlib' 库中的 'abort()' 函数 [CERT_CPP-ERR50-l-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR50-m.html">避免从声明不抛出异常的函数中抛出异常 [CERT_CPP-ERR50-m-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR50-n.html">不得使用 'stdlib.h' 或 'cstdlib' 库中的 'quick_exit()' 和 '_Exit()' 函数 [CERT_CPP-ERR50-n-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR51.html">CERT-ERR51_CPP (RULE) 处理所有异常 [CERT_CPP-ERR51]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR51-a.html">始终捕获异常 [CERT_CPP-ERR51-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR51-b.html">在代码中显式抛出的每个异常，在所有可能导致这一点的调用路径中都应该有一个兼容类型的处理程序 [CERT_CPP-ERR51-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR52.html">CERT-ERR52_CPP (RULE) 不要使用 setjmp() 或 longjmp() [CERT_CPP-ERR52]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR52-a.html">不使用 setjmp 宏和 longjmp 函数 [CERT_CPP-ERR52-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR52-b.html">不要使用标准头文件 &lt;setjmp.h&gt; [CERT_CPP-ERR52-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR53.html">CERT-ERR53_CPP (RULE) 不要在构造函数或析构函数的 try-block 处理程序中引用基类或类数据成员 [CERT_CPP-ERR53]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR53-a.html">以 function-try-block 实现的类构造函数或析构函数的处理程序不应引用该类或其基类的非静态成员 [CERT_CPP-ERR53-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR54.html">CERT-ERR54_CPP (RULE) 捕获处理程序应该将其参数类型从大多数派生到最小派生排序 [CERT_CPP-ERR54]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR54-a.html">如果在一个 try-catch 语句或函数 try-block 中为派生类及其部分或全部基类提供多个处理程序，则应将派生程度最高的处理程序排序为派生程度最高的基类 [CERT_CPP-ERR54-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR55.html">CERT-ERR55_CPP (RULE) 尊重异常规范 [CERT_CPP-ERR55]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR55-a.html">如果函数的声明包含异常规范，则该函数只能抛出指定类型的异常 [CERT_CPP-ERR55-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR56.html">CERT-ERR56_CPP (RULE) 保证异常安全 [CERT_CPP-ERR56]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR56-a.html">确保资源已释放 [CERT_CPP-ERR56-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR57.html">CERT-ERR57_CPP (RULE) 在处理异常时不要泄漏资源 [CERT_CPP-ERR57]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR57-a.html">确保资源已释放 [CERT_CPP-ERR57-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR58.html">CERT-ERR58_CPP (RULE) 处理所有在 main() 函数开始执行之前抛出的异常 [CERT_CPP-ERR58]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR58-a.html">只有在程序启动后和终止前才会出现异常情况 [CERT_CPP-ERR58-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR59.html">CERT-ERR59_CPP (RULE) 不要在跨执行边界抛出异常 [CERT_CPP-ERR59]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR59-a.html">不要跨越执行边界抛出异常 [CERT_CPP-ERR59-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR60.html">CERT-ERR60_CPP (RULE) 异常对象不抛出 (nothrow)拷贝可构造的 [CERT_CPP-ERR60]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR60-a.html">异常对象必须是不可抛出复制构造函数 [CERT_CPP-ERR60-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR60-b.html">继承自'std::exception'的类的显式声明复制构造函数应该具有非抛出异常规范 [CERT_CPP-ERR60-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR61.html">CERT-ERR61_CPP (RULE) 通过 lvalue 引用捕获异常 [CERT_CPP-ERR61]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR61-a.html">类类型异常总是会被引用捕获 [CERT_CPP-ERR61-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR61-b.html">按值抛出，按参考捕获 [CERT_CPP-ERR61-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR62.html">CERT-ERR62_CPP (RULE) 在将字符串转换为数字时检测错误 [CERT_CPP-ERR62]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-ERR62-a.html">不得使用库stdlib.h中的库函数atof，atoi和atol [CERT_CPP-ERR62-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP50.html">CERT-EXP50_CPP (RULE) 不依赖于副作用的评估顺序 [CERT_CPP-EXP50]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP50-a.html">表达式的值应该在任何标准允许的赋值顺序下是一样的 [CERT_CPP-EXP50-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP50-b.html">不要编写依赖于函数参数求值顺序的代码 [CERT_CPP-EXP50-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP50-c.html">不要编写依赖于函数标志符和函数参数的求值顺序的代码 [CERT_CPP-EXP50-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP50-d.html">涉及一个函数调用时，不要编写依赖表达式求值顺序的代码 [CERT_CPP-EXP50-d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP50-e.html">在序列点之间，对象的存储值最多只能通过表达式的计算来修改一次 [CERT_CPP-EXP50-e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP50-f.html">不要编写依赖于函数调用求值顺序的代码 [CERT_CPP-EXP50-f-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP51.html">CERT-EXP51_CPP (RULE) 不要通过不正确类型的指针删除数组 [CERT_CPP-EXP51]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP51-a.html">没有处理数组为多态 [CERT_CPP-EXP51-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP52.html">CERT-EXP52_CPP (RULE) 不要依赖于未评估操作数的副作用 [CERT_CPP-EXP52]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP52-a.html">sizeof运算符的操作数不应包含任何有副作用的表达式 [CERT_CPP-EXP52-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP52-b.html">不应在sizeof运算符的操作数中访问由volatile左值指定的对象 [CERT_CPP-EXP52-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP52-c.html">会导致副作用的函数调用不应该用作 sizeof 运算符的操作数 [CERT_CPP-EXP52-c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP52-d.html">typeid 操作符的操作数不能包含任何有副作用的表达式 [CERT_CPP-EXP52-d-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP52-e.html">'typeid' 操作符的操作数不应包含导致副作用的函数调用 [CERT_CPP-EXP52-e-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP53.html">CERT-EXP53_CPP (RULE) 不要读取未初始化内存 [CERT_CPP-EXP53]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP53-a.html">避免在初始化之前使用 [CERT_CPP-EXP53-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP54.html">CERT-EXP54_CPP (RULE) 不要在超出其生命周期访问对象 [CERT_CPP-EXP54]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP54-a.html">不得使用已经释放掉的资源 [CERT_CPP-EXP54-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP54-b.html">不得从函数中返回具有自动存储的对象的地址 [CERT_CPP-EXP54-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP54-c.html">自动存储对象的地址不应分配给在第一个对象不再存在后可能持久存在的另一个对象 [CERT_CPP-EXP54-c-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP55.html">CERT-EXP55_CPP (RULE) 不要通过 cv 非限定类型访问 cv 限定对象 [CERT_CPP-EXP55]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP55-a.html">强制转换不得从指针或引用类型中删除任何“const”或“volatile”限定条件 [CERT_CPP-EXP55-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP56.html">CERT-EXP56_CPP (RULE) 不要调用包含不匹配语言链接的函数 [CERT_CPP-EXP56]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP56-a.html">不要使用不匹配的语言链接调用函数 [CERT_CPP-EXP56-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP57.html">CERT-EXP57_CPP (RULE) 不要强制类型转换或删除不完整类的指针 [CERT_CPP-EXP57]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP57-a.html">不要在删除点上时删除类不完整的对象 [CERT_CPP-EXP57-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP57-b.html">不应在指向不完整类型的指针与任何其他类型之间执行转换 [CERT_CPP-EXP57-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP58.html">CERT-EXP58_CPP (RULE) 将正确类型的对象传递给 va_start [CERT_CPP-EXP58]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP58-a.html">正确地使用可变参数的宏 [CERT_CPP-EXP58-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP59.html">CERT-EXP59_CPP (RULE) 在有效类型和成员上使用 offsetof() [CERT_CPP-EXP59]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP59-a.html">在有效的类型以及成员上使用 offsetof() [CERT_CPP-EXP59-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP60.html">CERT-EXP60_CPP (RULE) 不要跨执行边界传递非标准布局类型的对象 [CERT_CPP-EXP60]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP60-a.html">不要跨越执行边界传递非标准布局类型的对象 [CERT_CPP-EXP60-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP61.html">CERT-EXP61_CPP (RULE) lambda 对象的生命周期不能超过其任何引用捕获对象 [CERT_CPP-EXP61]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP61-a.html">永远不要返回通过引用捕获本地对象的lambda [CERT_CPP-EXP61-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP61-b.html">永远不要通过引用从外部lambda捕获本地对象 [CERT_CPP-EXP61-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP61-c.html">通过引用捕获本地对象的lambda不应被赋值给有更长生命周期的变量 [CERT_CPP-EXP61-c-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP62.html">CERT-EXP62_CPP (RULE) 不访问不属于对象值表示形式的对象表示的位 [CERT_CPP-EXP62]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP62-a.html">不要比较可能包含 C 标准库函数填充位的类对象 [CERT_CPP-EXP62-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP63.html">CERT-EXP63_CPP (RULE) 不要依赖于从对象移动来的值 [CERT_CPP-EXP63]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-EXP63-a.html">不要依赖被移动对象的值 [CERT_CPP-EXP63-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-FIO50.html">CERT-FIO50_CPP (RULE) 在没有插入定位调用的情况下，不要从文件流中交替输入和输出 [CERT_CPP-FIO50]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-FIO50-a.html">不要从一个流中交替地输入和输出，却没有间隔刷新或定位调用 [CERT_CPP-FIO50-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-FIO51.html">CERT-FIO51_CPP (RULE) 当文件不再需要时应当关闭 [CERT_CPP-FIO51]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-FIO51-a.html">确保资源已释放 [CERT_CPP-FIO51-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-INT50.html">CERT-INT50_CPP (RULE) 不要强制类型转换到一个超出范围的枚举值 [CERT_CPP-INT50]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-INT50-a.html">带有枚举底层类型的表达式只能具有与枚举的枚举数相对应的值 [CERT_CPP-INT50-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-MEM50.html">CERT-MEM50_CPP (RULE) 不要访问已释放的内存 [CERT_CPP-MEM50]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-MEM50-a.html">不得使用已经释放掉的资源 [CERT_CPP-MEM50-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-MEM51.html">CERT-MEM51_CPP (RULE) 正确地释放动态分配的资源 [CERT_CPP-MEM51]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-MEM51-a.html">在对相应的 new/malloc 以及 delete/free 的调用中应使用相同的形式 [CERT_CPP-MEM51-a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-MEM51-b.html">释放数组内存时 delete 必须使用空括号([]) [CERT_CPP-MEM51-b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-MEM51-c.html">复制构造函数和复制赋值运算符都应该为具有非平凡析构函数的类声明 [CERT_CPP-MEM51-c-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-MEM51-d.html">正确地动态释放分配的资源 [CERT_CPP-MEM51-d-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-MEM52.html">CERT-MEM52_CPP (RULE) 检测和处理内存分配错误 [CERT_CPP-MEM52]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-MEM52-a.html">检查 new 的返回值 [CERT_CPP-MEM52-a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-MEM52-b.html">由于函数参数的评估顺序尚未定义，禁止在函数参数列表中进行资源分配 [CERT_CPP-MEM52-b-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-MEM53.html">CERT-MEM53_CPP (RULE) 在手动管理对象生命周期时显式构造和析构对象 [CERT_CPP-MEM53]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-MEM53-a.html">禁止对含有构造函数的对象调用 malloc/realloc [CERT_CPP-MEM53-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-MEM54.html">CERT-MEM54_CPP (RULE) 适当提供指向足够存储容量的对齐指针, 以快速布局 [CERT_CPP-MEM54]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-MEM54-a.html">不要传递存储容量不足或者没有对正在构造的对象进行适当的对齐以配置 'new' 的指针 [CERT_CPP-MEM54-a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-MEM54-b.html">当一个对象数组传递给配置 'new' 的定位函数时,应该会有开销 [CERT_CPP-MEM54-b-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-MEM55.html">CERT-MEM55_CPP (RULE) 尊重替换动态存储管理要求 [CERT_CPP-MEM55]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-MEM55-a.html">当分配失败时，用户定义的'new'操作符应该抛出'std::bad_alloc'异常 [CERT_CPP-MEM55-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-MEM56.html">CERT-MEM56_CPP (RULE) 不要在不相关的智能指针中存储已经拥有的指针值 [CERT_CPP-MEM56]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-MEM56-a.html">在一个无关的智能指针中不要保存一个只读指针变量 [CERT_CPP-MEM56-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-MEM57.html">CERT-MEM57_CPP (RULE) 避免对过度对齐的类型使用默认的 new 操作符 [CERT_CPP-MEM57]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-MEM57-a.html">避免对过度对齐类型使用默认运算符 'new' [CERT_CPP-MEM57-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-MSC50.html">CERT-MSC50_CPP (RULE) 不使用 std::rand() 函数生成伪随机数 [CERT_CPP-MSC50]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-MSC50-a.html">不要使用rand()函数来生成伪随机数 [CERT_CPP-MSC50-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-MSC51.html">CERT-MSC51_CPP (RULE) 确保你的随机数生成器被正确地开始 [CERT_CPP-MSC51]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-MSC51-a.html">在伪随机数生成器中指定适当的种子 [CERT_CPP-MSC51-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-MSC52.html">CERT-MSC52_CPP (RULE) 值返回函数必须从所有出口路径返回一个值 [CERT_CPP-MSC52]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-MSC52-a.html">非 void 返回类型的函数的所有退出路径应该有一个明确的包含表达式的返回语句 [CERT_CPP-MSC52-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-MSC53.html">CERT-MSC53_CPP (RULE) 不要从声明为 [[noreturn]]的函数返回 [CERT_CPP-MSC53]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-MSC53-a.html">不要从不应该返回值的函数中返回 [CERT_CPP-MSC53-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-MSC54.html">CERT-MSC54_CPP (RULE) 信号处理程序必须是一个普通的旧函数 [CERT_CPP-MSC54]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-MSC54-a.html">正确定义信号处理程序 [CERT_CPP-MSC54-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-OOP50.html">CERT-OOP50_CPP (RULE) 不要从构造函数或析构函数中调用虚拟函数 [CERT_CPP-OOP50]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-OOP50-a.html">避免从构造函数调用虚函数 [CERT_CPP-OOP50-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-OOP50-b.html">避免从析构函数调用虚函数 [CERT_CPP-OOP50-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-OOP50-c.html">不要从类的任何构造函数中调用类的虚函数 [CERT_CPP-OOP50-c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-OOP50-d.html">不要从类的析构函数中调用类的虚函数 [CERT_CPP-OOP50-d-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-OOP51.html">CERT-OOP51_CPP (RULE) 不要分割派生对象 [CERT_CPP-OOP51]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-OOP51-a.html">避免切片函数参数/返回值 [CERT_CPP-OOP51-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-OOP52.html">CERT-OOP52_CPP (RULE) 不要删除没有虚拟析构函数的多态对象 [CERT_CPP-OOP52]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-OOP52-a.html">在具有虚函数的基类中定义虚拟析构函数 [CERT_CPP-OOP52-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-OOP53.html">CERT-OOP53_CPP (RULE) 按规范顺序来编写构造函数成员初始化器 [CERT_CPP-OOP53]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-OOP53-a.html">在初始化列表中按声明成员的顺序列出成员 [CERT_CPP-OOP53-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-OOP54.html">CERT-OOP54_CPP (RULE) 正确地处理自拷贝赋值 [CERT_CPP-OOP54]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-OOP54-a.html">在operator=中检查对self的赋值 [CERT_CPP-OOP54-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-OOP55.html">CERT-OOP55_CPP (RULE) 不要使用指向成员指针的操作符来访问不存在的成员 [CERT_CPP-OOP55]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-OOP55-a.html">强制类型转换不应将指向函数的指针转换为任何其他指针类型，包括指向函数类型的指针 [CERT_CPP-OOP55-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-OOP56.html">CERT-OOP56_CPP (RULE) 尊重替换处理程序的要求 [CERT_CPP-OOP56]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-OOP56-a.html">正确定义终止处理函数 [CERT_CPP-OOP56-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-OOP56-b.html">正确定义意外处理函数 [CERT_CPP-OOP56-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-OOP56-c.html">正确定义新处理程序 [CERT_CPP-OOP56-c-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-OOP57.html">CERT-OOP57_CPP (RULE) 相比 C 语言标准的库函数优先选择特殊的成员函数和重载的操作符 [CERT_CPP-OOP57]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-OOP57-a.html">不要使用C标准库函数初始化具有非普通类类型的对象 [CERT_CPP-OOP57-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-OOP57-b.html">不要将非标准布局类类型的对象与C标准库函数进行比较 [CERT_CPP-OOP57-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-OOP58.html">CERT-OOP58_CPP (RULE) 拷贝操作不能改变源对象 [CERT_CPP-OOP58]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-OOP58-a.html">拷贝操作不能改变源对象 [CERT_CPP-OOP58-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-STR50.html">CERT-STR50_CPP (RULE) 保证字符串存储有足够容纳字符数据和空终止符的空间 [CERT_CPP-STR50]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-STR50-a.html">使用向量(vector)或者字符串代替数组 [CERT_CPP-STR50-a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-STR50-b.html">避免由于读取非零终止字符串导致的溢出 [CERT_CPP-STR50-b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-STR50-c.html">避免写入缓冲区时导致的溢出 [CERT_CPP-STR50-c-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-STR50-d.html">避免访问数组越界 [CERT_CPP-STR50-d-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-STR50-e.html">防止来自受污染数据的缓冲区溢出 [CERT_CPP-STR50-e-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-STR50-f.html">避免来自受污染数据的缓冲区写入溢出 [CERT_CPP-STR50-f-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-STR50-g.html">避免使用可能导致缓冲区溢出的不安全字符串函数 [CERT_CPP-STR50-g-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-STR51.html">CERT-STR51_CPP (RULE) 不要试图从空指针创建一个 std::string [CERT_CPP-STR51]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-STR51-a.html">避免空指针引用 [CERT_CPP-STR51-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-STR52.html">CERT-STR52_CPP (RULE) 使用有效引用、指针和迭代器来引用 basic_string 的元素 [CERT_CPP-STR52]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-STR52-a.html">使用有效的引用、指针和迭代器来引用一个 basic_string 的元素 [CERT_CPP-STR52-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-STR53.html">CERT-STR53_CPP (RULE) 范围检查元素访问 [CERT_CPP-STR53]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CERT_CPP-STR53-a.html">保证容器索引在有效范围内 [CERT_CPP-STR53-a-2]</a>
</li></ul>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA.html">编码规范 [CODSTA]</a></b>
<ul>
<li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP.html">C++ 编码规范 [CODSTA-CPP]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-01.html">最好使用头文件 iostream.h 而非 stdio.h [CODSTA-CPP-01-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-02.html">赋值操作符返回一个 *this 指向的引用；使赋值操作符的返回类型是指向自身 class 类型的非 const 引用 [CODSTA-CPP-02-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-03.html">位操作符，比较操作符，逻辑操作符，逗号操作符应该为 const [CODSTA-CPP-03-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-04.html">允许转换的构造函数应该是使用 explicit 修饰 [CODSTA-CPP-04-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-05.html">不要使用用户自定义的转换函数 [CODSTA-CPP-05-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-06.html">避免从成员函数返回指向类数据的非 const 句柄(指针或引用) [CODSTA-CPP-06-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-07.html">后缀增量和减量应该依据其前缀的实际情况实现 [CODSTA-CPP-07-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-08.html">避免重载逻辑操作符AND, OR (&amp;&amp;, ||) [CODSTA-CPP-08-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-09.html">避免使用强制类型转换符 reinterpret_cast [CODSTA-CPP-09-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-10.html">不要定义包含成员函数的结构体 [CODSTA-CPP-10-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-100.html">不要比较可能包含 C 标准库函数填充位的类对象 [CODSTA-CPP-100-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-101.html">关系运算符应返回布尔值 [CODSTA-CPP-101-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-102.html">二进制算术运算符和位运算符应返回一个 'prvalue' [CODSTA-CPP-102-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-103.html">不得使用输出参数 [CODSTA-CPP-103-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-104.html">typeid 操作符的操作数不能包含任何有副作用的表达式 [CODSTA-CPP-104-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-104_b.html">'typeid' 操作符的操作数不应包含导致副作用的函数调用 [CODSTA-CPP-104_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-11.html">建议使用 C++ 风格的强制类型转换 [CODSTA-CPP-11-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-12.html">基类和成员变量的类应放在不同的头文件当中 [CODSTA-CPP-12-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-13.html">作为函数返回类型的类应该放在单独的头文件中 [CODSTA-CPP-13-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-14.html">在函数原形中作为入口参数类型的类应该放在单独的头文件中 [CODSTA-CPP-14-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-15.html">使用在内联成员函数内部的函数应该放在单独的头文件中 [CODSTA-CPP-15-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-16.html">当两个操作符是对立的(例如==和!=)时，可以同时定义它们 [CODSTA-CPP-16-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-17.html">不要使用 'struct' 关键字来声明 C++ 的变量 [CODSTA-CPP-17-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-18.html">将全局变量，常量，枚举类型和自定义类型变量(typedefs)封装在一个类中 [CODSTA-CPP-18-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-19.html">至少声明一个构造函数以防止编译器提供一个公共的构造函数 [CODSTA-CPP-19-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-20.html">如果想支持混合模式的操作, 操作符应该是非成员函数 [CODSTA-CPP-20-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-21.html">赋值操作符必须返回常引用 [CODSTA-CPP-21-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-22.html">最好使用非成员非友元函数(non-member non-friend)替代成员函数 [CODSTA-CPP-22-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-23.html">每当一个全局函数被引用时，使用::作用域运算符 [CODSTA-CPP-23-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-24.html">避免使用任何虚的赋值操作符。赋值操作符不能返回 const T&amp; [CODSTA-CPP-24-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-25.html">非公共成员应为虚函数，公共函数应为非虚函数 [CODSTA-CPP-25-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-26.html">保持类型和函数在单独的namespace中，除非它们确实需要一起运行 [CODSTA-CPP-26-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-27.html">保持一个类型和它的非成员函数接口在同一个命名空间 [CODSTA-CPP-27-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-28.html">如果定义了二进制运算操作符 ( + , - , * , / , ^ , % , | , &amp; )，应同时定义其对应的赋值操作符 [CODSTA-CPP-28-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-29.html">算术和赋值操作符应该有规范的形式 [CODSTA-CPP-29-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-30.html">非成员操作符比成员操作符更支持混合形式的算术运算 [CODSTA-CPP-30-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-31.html">不要在构造函数上使用关键字 'explicit' [CODSTA-CPP-31-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-32.html">非模板类的定义中不能定义成员函数 [CODSTA-CPP-32-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-33.html">不应在模板类定义中定义成员函数 [CODSTA-CPP-33-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-34.html">避免在指针上使用 static_cast [CODSTA-CPP-34-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-35.html">避免使用dynamic_casts [CODSTA-CPP-35-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-36.html">全局命名空间应该只包含 main() 和命名空间声明 [CODSTA-CPP-36-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-37.html">在函数的执行体中不应定义类，结构体，联合体(class/struct/union) [CODSTA-CPP-37-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-38.html">转换操作符, operator-&gt;, operator(), operator[] 应该 const 类型的 [CODSTA-CPP-38-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-39.html">不要在头文件中或 #include 之前写 namespace usings [CODSTA-CPP-39-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-40.html">限制一个类的对象个数 [CODSTA-CPP-40-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-41.html">不要使用 'enum' 关键字在 C++ 中声明变量 [CODSTA-CPP-41-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-42.html">不使用 'mutable' 关键字声明成员变量 [CODSTA-CPP-42-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-43.html">尽可能声明引用参数为 const 引用 [CODSTA-CPP-43-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-44.html">应使非 const 成员函数调用 const 成员函数，而非复制 const 的定义 [CODSTA-CPP-44-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-45.html">一个类的私有成员部分应该声明成以下顺序:构造函数、析构函数、成员函数、成员操作符函数、枚举以及其他 [CODSTA-CPP-45-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-46.html">在一个类中作用范围的顺序为: public 位置应在最前面 [CODSTA-CPP-46-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-47.html">在一个类中作用范围的顺序: protected 位于 private 之前 [CODSTA-CPP-47-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-48.html">在类的protected域中，各项应该以如下顺序声明: 构造函数, 析构函数, 成员函数, 成员操作符函数, 枚举类型和其他 [CODSTA-CPP-48-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-49.html">在类的 public 域中，各项应该以如下顺序声明: 构造函数, 析构函数, 成员函数, 成员操作符函数, 枚举类型和其他 [CODSTA-CPP-49-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-50.html">不要使用 static 关键字，除非在函数或者类中 [CODSTA-CPP-50-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-51.html">在源文件中不要定义内联函数 [CODSTA-CPP-51-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-52.html">构造函数使用赋值型的操作符和独立型的操作符的自然的关系 [CODSTA-CPP-52-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-53.html">尽可能将参数或局部变量声明为const [CODSTA-CPP-53-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-54.html">成员函数应该被尽可能的声明为 const [CODSTA-CPP-54-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-55.html">在接口中不应该使用数组类型参数 [CODSTA-CPP-55-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-55_b.html">私有方法和被保护的方法不应该用数组类型声明参数 [CODSTA-CPP-55_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-56.html">类，结构体或枚举不应该在其类型定义中被声明 [CODSTA-CPP-56-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-57.html">命名空间的嵌套不能超过两层 [CODSTA-CPP-57-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-58.html">从不是重载运算符函数得到的非 void 类型的返回值应该始终被使用 [CODSTA-CPP-58-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-59.html">不能使用C语言库 [CODSTA-CPP-59-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-60.html">只得使用那些定义在 ISO/IEC 14882:2003 中的转义序列 [CODSTA-CPP-60-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-62.html">NULL 不得用作一个整数值 [CODSTA-CPP-62-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-63.html">字面量零 (0) 不得用作空指针常量 (null-pointer-constant) [CODSTA-CPP-63-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-64.html">if 语句的条件和循环语句的条件应该是布尔类型 [CODSTA-CPP-64-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-65.html">条件运算符的第一个操作数应该具有布尔类型 [CODSTA-CPP-65-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-66.html">不得使用 C 语言风格的强制类型转换(除 void 强制类型转换外)和函数符号式强制类型转换(除了显式的构造函数调用外) [CODSTA-CPP-66-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-67.html">! 运算符，逻辑 &amp;&amp; 或逻辑 || 运算符的每个操作数应该都是布尔类型 [CODSTA-CPP-67-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-68.html">一元 &amp; 运算符不得被重载 [CODSTA-CPP-68-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-69.html">for 循环应该包含一个没有浮动类型的单一的循环计数器 [CODSTA-CPP-69-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-70.html">如果循环计数器不是被 -- 或 ++ 修改，那么在条件中此循环计数器应该只能被用作 &lt;=, &lt;, &gt; 或 &gt;= 的操作数 [CODSTA-CPP-70-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-71.html">循环计数器应该被 --, ++, -=n, 或 +=n 之一修改；这里的 n 在整个循环期间保持不变 [CODSTA-CPP-71-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-72.html">循环计数器以外的循环控制变量不得在判定条件或运算表达式中被修改 [CODSTA-CPP-72-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-73.html">在循环体语句中被修改的循环计数器以外的循环控制变量应该是布尔类型的 [CODSTA-CPP-73-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-74.html">头文件中不应有未命名的命名空间 [CODSTA-CPP-74-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-75.html">不得使用 using 指示符 [CODSTA-CPP-75-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-76.html">在同一个命名空间中标识符的多重声明不得跨越该标识符的 using 声明 [CODSTA-CPP-76-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-77.html">Const 成员函数不得返回指向类数据的非 const 指针或引用 [CODSTA-CPP-77-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-78.html">如果一个成员函数可以被设为 static 那么它应该被设为 static，否则如果可以被设为 const 那么它应该被设为 const [CODSTA-CPP-78-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-79.html">判等运算符 (== 或 !=)的任何一个操作数都不应该是一个指向虚成员函数的指针 [CODSTA-CPP-79-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-80.html">避免重载逗号运算符 "," [CODSTA-CPP-80-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-81.html">不允许仅存在 getters/setters(accessors/mutators) 的类 [CODSTA-CPP-81-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-82.html">避免未封装的全局变量 (包括在命名空间中声明的变量和 public static 公共静态成员) [CODSTA-CPP-82-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-83.html">在一个局部范围内声明的标识符不应该隐藏在一个类作用域中声明的标识符 [CODSTA-CPP-83-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-84.html">在类的作用域中声明的标识符不应该隐藏在全局或命名空间范围内声明的标识符 [CODSTA-CPP-84-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-85.html">在一个内部类作用域中声明的标识符不应该隐藏在外部类作用域中声明的标识符 [CODSTA-CPP-85-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-86.html">如果在一个类中定义了两个相对相等的操作符('=='，'!=')，则其中一个操作符应以另一个操作符的形式定义 [CODSTA-CPP-86-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-87_a.html">如果标识符指的是一个类型，它不应也指向同一范围内的对象或函数 [CODSTA-CPP-87_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-87_b.html">如果标识符指的是一个类型，它不应也指向同一范围内的对象或函数 [CODSTA-CPP-87_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-87_c.html">如果标识符指的是一个类型，它不应也指向同一范围内的对象或函数 [CODSTA-CPP-87_c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-88.html">typedef 的名称不应该与其基本类型的名称相同 [CODSTA-CPP-88-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-89.html">不要分配枚举到bool [CODSTA-CPP-89-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-90.html">不应该在头文件中使用 'using' 指令和 'using' 声明(除了类和函数范围内的 using 声明) [CODSTA-CPP-90-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-91.html">二进制过载操作符应该用其对应的复合赋值运算符实现 [CODSTA-CPP-91-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-92.html">多重继承层次中可访问的实例名必须独一无二 [CODSTA-CPP-92-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-93.html">不要使用C标准库函数初始化具有非普通类类型的对象 [CODSTA-CPP-93-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-94.html">不要将非标准布局类类型的对象与C标准库函数进行比较 [CODSTA-CPP-94-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-95.html">不要修改标准命名空间 'std' 和 'posix' [CODSTA-CPP-95-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-96.html">不要使用不匹配的语言链接调用函数 [CODSTA-CPP-96-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-97.html">永远不要使用'const'或'volatile'来限定引用类型 [CODSTA-CPP-97-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-98.html">拷贝操作不能改变源对象 [CODSTA-CPP-98-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-CPP-99.html">在有效的类型以及成员上使用 offsetof() [CODSTA-CPP-99-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP.html">Modern C++ 编码规范 [CODSTA-MCPP]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-01.html">自定义类型转换函数需要使用标识符标识 [CODSTA-MCPP-01-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-02.html">不能使用typedef定义类型 [CODSTA-MCPP-02-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-03.html">使用作用域枚举类型 [CODSTA-MCPP-03-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-04.html">使用nullptr代替null和0 [CODSTA-MCPP-04-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-05.html">使用override关键字标识函数覆盖 [CODSTA-MCPP-05-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-06_a.html">使用 delete 关键避免声明拷贝构造函数以及拷贝赋值运算符 [CODSTA-MCPP-06_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-06_b.html">通过使用delete关键字来声明拷贝构造以及拷贝赋值运算符，而不是通过私有成员的方式来避免拷贝类对象 [CODSTA-MCPP-06_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-07.html">与 std::bind，std::bind1st 和 std::bind2nd 相比，更偏向 lambda 表达式 [CODSTA-MCPP-07-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-07_b.html">不应该使用 'binder1st' 和 'binder2nd' 标识符 [CODSTA-MCPP-07_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-08_a.html">使用 auto 类型来声明变量 [CODSTA-MCPP-08_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-08_b.html">请使用 auto 类型作为函数返回值 [CODSTA-MCPP-08_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-09.html">如果函数不抛出异常，请使用关键字 'noexcept' 声明 [CODSTA-MCPP-09-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-10_a.html">比起迭代器，更倾向于常量迭代器 [CODSTA-MCPP-10_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-10_b.html">应该使用 cbegin(), crbegin, cend(), crend() 函数 [CODSTA-MCPP-10_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-11_a_cpp11.html">尽量使用 constexpr 声明常量类型变量 [CODSTA-MCPP-11_a_cpp11-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-11_b_cpp11.html">尽量使用 constexpr 声明函数 [CODSTA-MCPP-11_b_cpp11-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-13.html">Use std::move() on rvalue references and std::forward() on forwarding references [CODSTA-MCPP-13-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-13_b.html">'std::forward' 函数应用来转发通用引用 [CODSTA-MCPP-13_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-14.html">避免在转发引用上使用重载 [CODSTA-MCPP-14-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-15_a.html">避免默认捕获模式 [CODSTA-MCPP-15_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-15_b.html">在 lambda 中显式地使用 'this' 指针具有捕获副作用 [CODSTA-MCPP-15_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-16_a.html">建议使用智能指针成员而不是原始指针成员 [CODSTA-MCPP-16_a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-16_b.html">对于数组或 STL 容器建议使用智能指针而不是原始指针 [CODSTA-MCPP-16_b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-16_c.html">建议使用 'std::make_shared' 而不是直接使用 new [CODSTA-MCPP-16_c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-16_d.html">更喜欢使用 std::unique_ptr 而不是 std::auto_ptr [CODSTA-MCPP-16_d-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-16_e.html">'std::make_unique'应该用来构造属于'std::unique_ptr'的对象 [CODSTA-MCPP-16_e-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-17.html">永远不要返回通过引用捕获本地对象的lambda [CODSTA-MCPP-17-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-17_b.html">永远不要通过引用从外部lambda捕获本地对象 [CODSTA-MCPP-17_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-17_c.html">通过引用捕获本地对象的lambda不应被赋值给有更长生命周期的变量 [CODSTA-MCPP-17_c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-18_a.html">在lambda表达式中避免不必要的默认捕获模式 [CODSTA-MCPP-18_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-18_b.html">避免不必要的lambda 捕获 [CODSTA-MCPP-18_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-19.html">使用引用修饰符&amp;(ref-qualifier)来声明赋值运算符 [CODSTA-MCPP-19-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-20.html">选择使用智能指针而不是原始局部指针 [CODSTA-MCPP-20-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-21.html">不要直接在互斥锁上调用lock() [CODSTA-MCPP-21-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-22.html">在基于范围的'for'循环中对自动声明使用显式引用限定符 [CODSTA-MCPP-22-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-23.html">如果类的 public 析构函数是非虚拟的，则该类应该声明为 final [CODSTA-MCPP-23-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-24.html">在成员函数声明中,只应该指定 virtual,override 或 final 中的一个 [CODSTA-MCPP-24-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-25.html">数字序列分隔符 ' 只能与相应的数值类型匹配使用 [CODSTA-MCPP-25-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-26.html">指向成员虚函数的指针只应该被测试是否与空指针常量相等 [CODSTA-MCPP-26-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-27.html">所有用户定义类型的std::hash专门化都应该有一个noexcept函数调用操作符 [CODSTA-MCPP-27-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-28.html">lambda 不应是 typeid 的操作数 [CODSTA-MCPP-28-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-29.html">当将指针传递给线程中的对象时，使用智能指针 [CODSTA-MCPP-29-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-30.html">考虑将本地对象的 'std::shared_ptr' 类型替换为 'std::unique_ptr' 类型 [CODSTA-MCPP-30-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-31.html">定义操作符 delete 的分级版本和未分级版本 [CODSTA-MCPP-31-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-32.html">静态对象和线程本地对象应不断初始化 [CODSTA-MCPP-32-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-33.html">用户定义的文字运算符只能执行传递参数的转换 [CODSTA-MCPP-33-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-34.html">智能指针只有在表示生存期语义时才可以用作参数类型 [CODSTA-MCPP-34-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-35.html">如果函数代替被管理的对象，参数应该只声明为对 'std::shared_ptr' 或 'std::unique_ptr' 的非 const Ivalue 引用 [CODSTA-MCPP-35-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-36.html">不要将参数类型声明为 'std::shared_ptr' 或 'std::unique_ptr' 的 rvalue 引用 [CODSTA-MCPP-36-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-37.html">析构类不需要进一步明确初始化，以及要求基类中的所有构造函数都应使用继承构造函数 [CODSTA-MCPP-37-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-38.html">带括号但不带等号的初始化{}，应用于变量的初始化 [CODSTA-MCPP-38-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-39.html">不应使用 '{}' 或 '= {}' 括号初始化来初始化 auto 类型的变量 [CODSTA-MCPP-39-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-40.html">不要过度使用 'auto' 说明符 [CODSTA-MCPP-40-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-41.html">不应该使用 'random_shuffle' 标识符 [CODSTA-MCPP-41-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-42.html">不要在 'bool' 类型的操作数上使用递增操作符（++） [CODSTA-MCPP-42-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-43.html">不应该使用 'set_unexpected' 标识符 [CODSTA-MCPP-43-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-44.html">lambda 表达式不应该在另一个 lambda 表达式中定义 [CODSTA-MCPP-44-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-45.html">应该显式指定非 void 返回类型 lambda 表达式的返回类型 [CODSTA-MCPP-45-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-MCPP-46.html">在每个 lambda 表达式中包含一个参数列表 [CODSTA-MCPP-46-3]</a>
</li></ul>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-01.html">数组元素必须由数组操作符[ ]访问 [CODSTA-01-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-02.html">不要将成员变量声明为位域 [CODSTA-02-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-03.html">不要通过 #define 定义常量 [CODSTA-03-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-04.html">不要使用 'static' 关键字声明局部变量 [CODSTA-04-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-05.html">应该尽可能避免使用指向指针的指针 [CODSTA-05-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-06.html">避免使用 '?:' 三元运算符 [CODSTA-06-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-07.html">如果函数没有参数，使用 ( ) 而不是 ( void ) [CODSTA-07-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-08.html">在 for 循环中不要使用 break [CODSTA-08-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-09.html">不能将函数指针强制转换为原始类型指针 [CODSTA-09-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-10.html">存储类型修饰符应该关联类型，而不是变量或函数 [CODSTA-10-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-100.html">在算术运算中不允许混合使用有符号值和无符号值 [CODSTA-100-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-101.html">在条件运算符的第二个和第三个操作数中不允许混合使用有符号和无符号值 [CODSTA-101-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-102.html">具有副作用的单一操作只能在适当的情况下使用 [CODSTA-102-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-103.html">具有副作用的函数调用只能在适当的上下文中使用 [CODSTA-103-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-104.html">如果逻辑 &amp;&amp; 或 || 的操作数包含二元运算符则操作数应该被括起来 [CODSTA-104-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-105.html">三元运算符 '?:' 的第二个或第三个操作数不得含有副作用 [CODSTA-105-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-107.html">不得使用在&lt;stdlib.h&gt;中的 bsearch 和 qsort 库函数 [CODSTA-107-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-108.html">不得使用标准头文件 &lt;tgmath.h&gt; [CODSTA-108-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-109.html">不得使用 &lt;fenv.h&gt; 中的异常处理功能 [CODSTA-109-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-11.html">广泛地使用断言证明内部假设和不变式 [CODSTA-11-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-110.html">不得使用标准的库的 input/output 函数 [CODSTA-110-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-111.html">不得使用联合体关键字 [CODSTA-111-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-112.html">不得使用可变长数组类型 [CODSTA-112-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-113.html">不得声明灵活的数组成员 [CODSTA-113-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-114.html">汇编语言应该封装在 C/C++ 函数中并被隔离 [CODSTA-114-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-115.html">如果指向一个结构体或联合体的指针在一个编译单元内从未被间接引用，那么该对象的实现应该被隐藏起来 [CODSTA-115-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-116.html">'default' 标签（如果存在）应显示为 switch 语句的第一个或最后一个 switch 标签 [CODSTA-116-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-117.html">八进制和十六进制转义序列将被终止 [CODSTA-117-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-118.html">当一个有外部联系的对象或函数被定义，则一个声明应该为可见的 [CODSTA-118-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-119.html">'default' 标签在终止 'break' 之前应有声明或注释 [CODSTA-119-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-12.html">避免使用移位操作，尽量使用算术运算 [CODSTA-12-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-120.html">内联函数应该声明为静态存储类 [CODSTA-120-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-121.html">不得使用严格的类型限定符 [CODSTA-121-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-122_a.html">应该使用具有非 void 返回类型的函数返回值 [CODSTA-122_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-122_b.html">不得使用一个非 void 返回类型函数返回的值 [CODSTA-122_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-123.html">包含递增(++)或递减(-)运算符的完整表达式应该没有其他潜在的副作用 [CODSTA-123-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-124_a.html">不得在指向函数的指针与指向函数的指针以外的任何类型之间执行转换 [CODSTA-124_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-124_b.html">函数类型的不兼容指针之间不能进行转换 [CODSTA-124_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-125.html">不应在指向不完整类型的指针与任何其他类型之间执行转换 [CODSTA-125-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-126.html">不得在指向对象类型的指针和指向不同对象类型的指针之间执行强制转换 [CODSTA-126-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-127.html">不应再指向对象的指针和指向整数类型的指针之间转换 [CODSTA-127-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-127_b.html">不应在指向对象类型的指针与除 'uintptr_t' 或 'intptr_t' 以外的整数类型之间执行转换 [CODSTA-127_b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-128.html">不应该执行从指向 void 的指针到指向对象的指针的转换 [CODSTA-128-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-129_a.html">不能在指向 void 的指针和算术类型之间执行强制类型转换 [CODSTA-129_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-129_b.html">不应在指向 void 的指针和算术类型之间执行隐式转换 [CODSTA-129_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-13.html">&gt;, &gt;=, &lt;, &lt;= 不应用于指针类型，除非它们指向相同的数组 [CODSTA-13-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-130.html">不应在指向对象的指针和非整数算术类型之间执行强制转换 [CODSTA-130-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-131.html">用 NULL 来代替字面零 (0) 作为空指针常量 [CODSTA-131-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-132.html">不应该修改函数参数 [CODSTA-132-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-133_a.html">C90中规定宏不应该与关键字定义为相同名称 [CODSTA-133_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-133_b.html">C99中规定宏不应该与关键字定义为相同名称 [CODSTA-133_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-134.html">函数参数对应的数组类型参数应该包含合适数量的元素 [CODSTA-134-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-135.html">不得使用从任何类型到指针或者指针到任何类型的类型转换 [CODSTA-135-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-136_a.html">不得使用 va_list, va_arg, va_start, va_end, va_copy 标识符 [CODSTA-136_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-136_b.html">不得使用 va_list, va_arg, va_start, va_end 标识符 [CODSTA-136_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-137.html">函数调用不得是 sizeof 运算符的操作数 [CODSTA-137-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-138.html">不得使用一个内置赋值运算符的结果 [CODSTA-138-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-14.html">禁止将 const 转换成非 const [CODSTA-14-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-141_a.html">初始化器列表不应该包含持久的副作用 [CODSTA-141_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-142.html">全局函数不能声明数组类型的参数 [CODSTA-142-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-142_b.html">使用数组参数调用的函数不应该声明具有指针参数 [CODSTA-142_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-143.html">未检查源缓冲区大小而使用 'strcpy' 是可疑的 [CODSTA-143-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-144.html">应当使用函数 'read' 和 'readlink' 返回的值 [CODSTA-144-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-145.html">期望以 null 结尾的字符串为参数的函数可能使用不以 null 结尾的字符串 [CODSTA-145-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-146.html">从一个面向字符的标准输入输出 I/O 函数返回的一个值不应该隐式转换为一个小于的 'int' 类型 [CODSTA-146-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-147.html">不应该使用相关的操作符 &lt;, &gt;, &gt;=, &lt;= 比较指针和 NULL [CODSTA-147-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-148.html">不要使用字符串字面量作为等号或关系运算符的操作数 [CODSTA-148-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-149.html">switch 语句中各 case 之间缺失 break 语句 [CODSTA-149-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-15.html">当数组作为参数传入一个函数时不要声明数组的大小 [CODSTA-15-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-150.html">断言不应该包含赋值，自增或自减运算符 [CODSTA-150-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-150_b.html">断言不应该包含函数调用或者类似于函数的宏调用 [CODSTA-150_b-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-150_c.html">避免不安全宏参数造成的不良影响 [CODSTA-150_c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-151.html">不要在布尔条件中使用枚举 [CODSTA-151-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-152.html">复合表达式的值不得传递给一个不同的基本类型类别或更广泛的基本类型 [CODSTA-152-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-154.html">在转换单元中外部对象或函数不得有多个non-defining声明 [CODSTA-154-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-155.html">应该使用C99中stdint.h的typedefs而不是个人自己的声明 [CODSTA-155-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-156_a.html">如果复合表达式作为一个操作数用于通常的算术运算并与比它位数宽的操作数进行运算时将报告违规 [CODSTA-156_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-156_b.html">如果复合表达式被用于条件运算符的操作数，那么其他操作数不应该有更宽的类型 [CODSTA-156_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-157.html">复合表达式的值不应该赋值给宽数据类型的一个对象 [CODSTA-157-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-158.html">函数类型应该包含具体名称的参数 [CODSTA-158-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-159.html">函数类型应当为原型形式 [CODSTA-159-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-16.html">当数组被初始化的时不要声明数组的大小 [CODSTA-16-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-160.html">数组参数的声明不得在 [ ] 之间包含 'static' 关键字 [CODSTA-160-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-161_a.html">当操作数是布尔值时应该使用布尔类型的表达式 [CODSTA-161_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-161_b.html">本质为布尔类型的操作数不应该用在需要使用数值操作数的地方 [CODSTA-161_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-161_c.html">字符类型的操作数不应该用在需要数类型的地方 [CODSTA-161_c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-161_d.html">在算术运算中不应该使用枚举类型 [CODSTA-161_d-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-161_e.html">不要对有符号类型和枚举类型使用移位和位运算 [CODSTA-161_e-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-161_f.html">本质上带符号或枚举类型的操作数不应用作移位操作符的右侧操作数 [CODSTA-161_f-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-161_g.html">一元减运算符的操作数不应该是无符号类型 [CODSTA-161_g-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-162.html">字符类型表达式不能用于加减运算符 [CODSTA-162-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-163_a.html">表达式的值不能赋给更小类型的对象 [CODSTA-163_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-163_b.html">表达式的值不应赋给另一基本类型类别的对象 [CODSTA-163_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-164_a.html">通常算数运算符的两边的操作数应该是相同类型 [CODSTA-164_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-164_b.html">第二个和第三个三元操作符的操作数有相同的基本类型分类 [CODSTA-164_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-165_a.html">不允许对枚举类型进行转换操作 [CODSTA-165_a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-165_b.html">不要从Boolean类型转换或转换到Boolean类型 [CODSTA-165_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-165_c.html">不要在字符类型和浮点类型之间使用强制类型转换 [CODSTA-165_c-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-166_a.html">指针指向了不能引用的文件对象 [CODSTA-166_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-166_b.html">指向文件对象的指针不应该被库函数引用 [CODSTA-166_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-167_a.html">for循环的循环计数器不能是浮点类型 [CODSTA-167_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-167_b.html">在'while' 和 'do-while' 中的循环计数器不要使用浮点类型 [CODSTA-167_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-168.html">for循环中只能有一个循环计数器，并且不能再循环体中修改 [CODSTA-168-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-169_a.html">for循环的第一个判断条件应该是格式良好的 [CODSTA-169_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-169_b.html">for循环的第二部分应该格式良好 [CODSTA-169_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-169_c.html">for循环的第三部分应该是格式良好的 [CODSTA-169_c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-17.html">不要使用 NULL 标识符; 而是使用 0 替代 [CODSTA-17-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-170_c90.html">在预处理之前的宏命名应该与预处理之后的标识符区分开来 [CODSTA-170_c90-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-170_c99.html">在预处理之前的宏命名应该与预处理之后的标识符区分开来 [CODSTA-170_c99-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-171_c90.html">宏命名应该与参数区分开来（c90) [CODSTA-171_c90-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-171_c99.html">宏命名需要与它的参数名区分开来（c99) [CODSTA-171_c99-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-172_c90.html">宏的命名需要与当前定义的其他宏的命名区分开来（c90） [CODSTA-172_c90-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-172_c99.html">宏的名称应该有别于其他当前定义的宏的名称(c99) [CODSTA-172_c99-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-174_a_c90.html">程序不应突破施加的标准编译限制 (c90) [CODSTA-174_a_c90-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-174_a_c99.html">程序不应突破施加的标准编译限制 (c99) [CODSTA-174_a_c99-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-174_b_c90.html">程序不应突破施加的标准编译限制 (c90) [CODSTA-174_b_c90-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-174_b_c99.html">程序不应突破施加的标准编译限制 (c99) [CODSTA-174_b_c99-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-175_a.html">函数中不应该包含无用的类型声明 [CODSTA-175_a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-175_b.html">源文件中不能包含未使用的类型声明 [CODSTA-175_b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-176_a.html">函数不应该包含无用的局部标签声明 [CODSTA-176_a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-176_b.html">源文件中不应该包含未使用的标签声明 [CODSTA-176_b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-177.html">源文件中不应该包含无用的宏声明 [CODSTA-177-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-178.html">外部标识符必须是独有的 [CODSTA-178-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-179_a_c90.html">在文件范围和命名空间中声明的不同标识符应该区分开来 (c90) [CODSTA-179_a_c90-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-179_a_c99.html">在文件范围和命名空间中声明的不同标识符应该区分开来 (c99) [CODSTA-179_a_c99-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-179_b_c90.html">在同样的块范围和命名空间中的标识符必须不相同 (c90) [CODSTA-179_b_c90-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-179_b_c99.html">在同样的块范围和命名空间中的标识符必须不相同 (c99) [CODSTA-179_b_c99-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-18.html">选择使用 while 而非 do 语句 [CODSTA-18-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-180.html">定义带有外部链接的对象或函数的标识符必须是唯一的 [CODSTA-180-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-181.html">不要将+, -, += 和 -= 类型操作符应用于指针类型表达式 [CODSTA-181-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-182.html">运算符'sizeof'的操作数不能是声明为"array of type"的函数参数 [CODSTA-182-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-183.html">标准库函数 'memcmp', 'memmove' and 'memcmp' 的指针参数应该指向兼容的类型 [CODSTA-183-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-184.html">传入标准库函数 'memcmp' 的指针参数不能指向指针类型、无符号类型、有符号类型、布尔类型或枚举类型 [CODSTA-184-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-185_a.html">由标准库函数 'localeconv', 'getenv', 'setlocale' 或, 'strerror' 返回的指针只能被用于指向常量类型 [CODSTA-185_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-185_b.html">由结构体 'lconv' 的成员指向的字符串不应该被修改 [CODSTA-185_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-186.html">指定的用来初始化数组对象的初始化器应明确指定数组对象的大小 [CODSTA-186-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-187_a.html">在赋值给较大的整型之前将字符串转换为unsigned char类型 [CODSTA-187_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-187_b.html">'signed char' 类型的表达式不应该作为数组下标使用 [CODSTA-187_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-187_c.html">在转换为更大的整型之前将字符转换为无符号字符类型 [CODSTA-187_c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-188.html">不要混淆宽窄字符串和函数 [CODSTA-188-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-189.html">不要拿整型和指针做加减运算 [CODSTA-189-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-19.html">使用 ctype.h 的函数对字符测试 [CODSTA-19-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-190.html">不要使用对象表示比较浮点值 [CODSTA-190-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-191.html">封装可以在循环中伪唤醒的函数 [CODSTA-191-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-192.html">结构的最终成员不应该是“0”或“1”的数组 [CODSTA-192-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-193.html">动态分配包含灵活数组成员的结构 [CODSTA-193-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-194.html">循环中使用包装函数可能失败 [CODSTA-194-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-195.html">不要在表达式中两次引用原子变量 [CODSTA-195-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-196.html">在函数调用的结果中不访问数组 [CODSTA-196-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-197.html">不要指定用字符串文本初始化的字符数组的大小 [CODSTA-197-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-198.html">浮点类型的复杂表达式的值只能转换为精度较低的浮点类型 [CODSTA-198-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-199.html">不要使用断言 [CODSTA-199-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-20.html">应该使用 EOS 作为字符串的结尾而不是使用 NULL [CODSTA-20-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-200.html">使用初始化器显式指定数组声明中的数组大小 [CODSTA-200-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-201.html">不要本地处理结构化文本 [CODSTA-201-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-202.html">带有外部链接的函数的内联定义不应包含静态对象的定义和使用 [CODSTA-202-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-203.html">不要硬编码字符串文字 [CODSTA-203-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-204.html">声明为 'noreturn' 的函数应该具有 'void' 返回类型 [CODSTA-204-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-21.html">当使用枚举类型 enum 时，每个成员的值必须被显式声明 [CODSTA-21-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-22.html">局部变量或参数名称跟类成员变量或父类/结构体成员变量的名称至少应该2个或以上字符不同 [CODSTA-22-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-23.html">所有的 'if' 语句必须有对应的 'else' 分支语句 [CODSTA-23-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-24.html">宏 FALSE 应该被定义为 0(零) [CODSTA-24-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-25.html">命名为 'FALSE' 的枚举常量应该显式地被初始化为 0 值 [CODSTA-25-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-26.html">避免使用幻数 [CODSTA-26-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-27.html">避免在函数内修改全局变量 [CODSTA-27-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-28.html">必须为联合体的声明定义字段 [CODSTA-28-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-29.html">应该尽可能使用“#define”或枚举类型常量（enum），而不是硬编码值 [CODSTA-29-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-30.html">避免返回句柄给函数的参数 [CODSTA-30-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-31.html">避免使用显式类型转换(强制类型转换) [CODSTA-31-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-32.html">如果 test 是指针时，则不能使用类似于 if(test) 或 if(!test) 的逻辑表达式 [CODSTA-32-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-33.html">在 if, while 或 switch 语句的条件表达式中不要使用 ++ 或 -- 操作符 [CODSTA-33-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-34.html">当声明函数指针时使用 typedef 来简化程序语法 [CODSTA-34-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-35.html">始终为 switch 语句提供一个 default 分支 [CODSTA-35-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-36.html">通过值传递内置类型，除非你想要修改这些参数 [CODSTA-36-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-37.html">选择 const 对象或枚举类型来 #defines 定义简单常量 [CODSTA-37-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-38.html">不要使用防止编译器检查类型的 #define 指令 [CODSTA-38-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-39.html">避免内部或外部变量名称与 C++ 保留字冲突 [CODSTA-39-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-40.html">当一个函数没有传递参数值或者没有返回值时应使用 'void' [CODSTA-40-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-41.html">避免只有一个 case 分支的 swtich 语句 [CODSTA-41-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-42.html">宏 TRUE 应该被定义为 1 [CODSTA-42-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-43.html">命名为 'TRUE' 的枚举常量应该显式地被初始化为 1 [CODSTA-43-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-44.html">局部变量不应使用与成员变量相同的名称 [CODSTA-44-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-45.html">参数不应使用与成员变量相同的名称 [CODSTA-45-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-46.html">实际中尽量使用正逻辑而不是负逻辑 [CODSTA-46-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-47.html">所有的结构体都应该有 typedefs 类型定义 [CODSTA-47-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-48.html">不要使用下列合体字母 &lt;%, %&gt;, &lt;:, :&gt;, %:, %:%: [CODSTA-48-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-49.html">如果 'for' 语句中无初始化或者无增量表达式; 应该使用 while 循环替代 [CODSTA-49-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-50.html">十六进制常量应该全部使用大写字母表示 [CODSTA-50-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-51.html">字母后缀应使用大写字母而不是小写字母 [CODSTA-51-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-52.html">除了初始化单个for循环参数的值外，for循环中的初始化表达式将不执行任何操作 [CODSTA-52-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-53.html">在 for 循环中的增量表达式除了改变单个循环参数到下一个值外，不应该执行其他任何操作 [CODSTA-53-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-54.html">每个 switch 语句至少有两个 case 分支和一个潜在的 default 分支 [CODSTA-54-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-55.html">Case 语句的标签应该使用枚举(enum)类型而不是使用整数类型(和常量) [CODSTA-55-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-56.html">'switch' 语句的所有 'case' 和 'default' 标签应该有一个显式的 'break' 或 'return' 语句， 或者 'fall through' 注释 [CODSTA-56-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-57.html">分号的可疑使用 [CODSTA-57-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-58.html">不允许类型强制转换为 void [CODSTA-58-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-59.html">在声明数组大小和 'malloc' 的内存大小时不应该使用硬编码 [CODSTA-59-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-60.html">避免使用相等运算符 ("==", "!=") 来对 TRUE 宏/枚举(enum)常量进行值比较 [CODSTA-60-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-61.html">在 switch 语句中的最后分支应该是 default 分支，除非所有枚举值都被测试 [CODSTA-61-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-62.html">强制类型转换不应将指向函数的指针转换为任何其他指针类型，包括指向函数类型的指针 [CODSTA-62-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-63.html">位运算符应只适用于无符号的基本类型操作数 [CODSTA-63-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-64.html">非条件 throw 或 break 语句应终止每个非空的 switch 语句 [CODSTA-64-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-65.html">具有整数类型的对象或指向 void 类型的指针不应转换为具有指针类型的对象 [CODSTA-65-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-66.html">二进制位运算符的非常量的操作数应该具有相同的基本类型 [CODSTA-66-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-67.html">用于对象，函数返回类型，或函数参数的类型在所有声明和重新声明中应该对应完全相同 [CODSTA-67-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-68.html">后缀 "U" 应该适用于所有无符号类型的八进制或十六进制整型字面量 [CODSTA-68-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-69.html">带有类型(普通) char 和 wchar_t 的表达式不能作为内建运算符的操作数，除了 =, ==, != 和一元 &amp; 运算符 [CODSTA-69-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-70.html">具有枚举类型的表达式不得用作除了 [ ], &nbsp;=, ==, !=, &lt;, &lt;=, &gt;, &gt;=, 和一元 &amp; 运算符以外的内建运算符的操作数 [CODSTA-70-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-71.html">具有带符号的整数类型且已命名的位域应该有超过一位的长度 [CODSTA-71-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-73.html">汇编指令应该只能使用 asm 声明来引入 [CODSTA-73-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-74.html">位域不得有枚举(enum)类型 [CODSTA-74-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-75.html">位域应该要么是 bool 类型要么是显式无符号(unsigned)或有符号(signed)的整数类型 [CODSTA-75-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-76.html">标识符 main 不得用于除了全局的 main 函数以外的其它函数 [CODSTA-76-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-77.html">goto 语句应该跳转到同一个函数体中位于 goto 语句后面声明的标签 [CODSTA-77-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-78.html">任何由 goto 语句引用的标签应该声明在同一个模块中，或者在一个包含 goto 语句的模块中 [CODSTA-78-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-79.html">对任何循环语句，都应存在不止一个用于循环终止的 break 或 goto 语句 [CODSTA-79-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-80.html">continue 语句只应该被用于具有良好格式的 for 循环中 [CODSTA-80-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-81.html">如果一个函数有内部链接，那么所有的重新声明应该包括静态(static)存储类的说明符 [CODSTA-81-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-82.html">避免无限循环 [CODSTA-82-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-82_b.html">不要使用空的无限循环 [CODSTA-82_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-83.html">所有的循环必须有一个固定的上限或下限 [CODSTA-83-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-85.html">避免在无限循环中有退出点 [CODSTA-85-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-86.html">必须在每个函数内部检查参数的有效性 [CODSTA-86-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-87.html">使用不超过一级的指针引用 [CODSTA-87-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-88.html">函数指针是不允许的 [CODSTA-88-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-89.html">声明不得包含超过一级的间接指针 [CODSTA-89-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-90.html">逻辑 '&amp;&amp;' 或 '||' 的每个操作数应该为后缀表达式 [CODSTA-90-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-91.html">函数应该最多只有一个退出(exit)点 [CODSTA-91-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-92.html">标准库宏和对象的名称不得被重用 [CODSTA-92-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-92_a.html">在标准程序库中的保留标识符，宏以及函数不应该被定义，重定义或取消定义（C90代码 [CODSTA-92_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-92_b.html">标准库中的保留标识符、宏和函数不应被定义、重新定义或取消定义（C99代码） [CODSTA-92_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-93.html">标准库函数的名称不应被重写 [CODSTA-93-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-94.html">不应该声明指针或数组类型 [CODSTA-94-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-95.html">不应该声明指针类型 [CODSTA-95-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-96.html">位域只应该有显式的无符号整数或者枚举类型 [CODSTA-96-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-97.html">如果操作符的优先级低于算术运算符，应该使用圆括号明确表达式的操作顺序 [CODSTA-97-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-98.html">所有的 'if...else if' 结构应该包含一个最后的 'else' 分支或明确的注释表示为什么不需要最后的 'else' 分支。 [CODSTA-98-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CODSTA-99.html">在比较运算中不允许混合使用有符号值和无符号值 [CODSTA-99-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/COMMENT.html">注释 [COMMENT]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/COMMENT-01.html">推荐使用 C++ 风格的注释 [COMMENT-01-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/COMMENT-02.html">提供版权信息 [COMMENT-02-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/COMMENT-03.html">每个源文件将被记录提供有关文件信息 [COMMENT-03-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/COMMENT-04.html">在函数定义之前的注释中记录函数 [COMMENT-04-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/COMMENT-04_b.html">在函数声明之前的注释中记录函数 [COMMENT-04_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/COMMENT-05.html">每一个变量声明都应该进行注解 [COMMENT-05-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/COMMENT-06.html">每一个类型定义(typedef)都应该进行注释 [COMMENT-06-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/COMMENT-07.html">每一个枚举值都应该进行注释 [COMMENT-07-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/COMMENT-08.html">每一个结构成员变量都应该进行注释 [COMMENT-08-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/COMMENT-09.html">所有汇编程序的使用应该被注释说明 [COMMENT-09-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/COMMENT-10.html">使用浮点运算应该被注释说明 [COMMENT-10-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/COMMENT-11.html">字符序列 // 不得被用于 C 语言风格的注释中 [COMMENT-11-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/COMMENT-12.html">字符序列 /* 不得被用于 C++ 语言风格的注释中 [COMMENT-12-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/COMMENT-13.html">不得在 // 注释中使用行合并 [COMMENT-13-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/COMMENT-14.html">所有类型、数据成员和函数的声明之前都应该有一个注释，注释使用 '@brief' 标记 [COMMENT-14-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/COMMENT-14_b.html">函数参数和返回类型应该记录在函数声明之前的注释中 [COMMENT-14_b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE.html">常见缺陷列表 [CWE]</a></b>
<ul>
<li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-119.html">CWE-119 在内存缓冲区范围内对操作的不正确限制 [CWE-119]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-119-a.html">避免访问数组越界 [CWE-119-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-119-b.html">避免访问数组和指针越界 [CWE-119-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-119-c.html">避免由于定义不正确的格式限制导致的缓冲区溢出 [CWE-119-c-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-119-d.html">避免读取缓冲区时导致的溢出 [CWE-119-d-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-119-e.html">避免写入缓冲区时导致的溢出 [CWE-119-e-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-119-f.html">避免在数组索引中有受污染数据 [CWE-119-f-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-119-g.html">防止来自受污染数据的缓冲区溢出 [CWE-119-g-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-119-h.html">避免来自受污染数据的缓冲区读取溢出 [CWE-119-h-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-119-i.html">避免来自受污染数据的缓冲区写入溢出 [CWE-119-i-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-119-j.html">未检查源缓冲区大小而使用 'strcpy' 是可疑的 [CWE-119-j-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-125.html">CWE-125 越界读取 [CWE-125]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-125-a.html">避免访问数组越界 [CWE-125-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-125-b.html">避免访问数组和指针越界 [CWE-125-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-125-c.html">避免读取缓冲区时导致的溢出 [CWE-125-c-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-125-d.html">避免来自受污染数据的缓冲区读取溢出 [CWE-125-d-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-190.html">CWE-190 整数溢出或环绕 [CWE-190]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-190-a.html">避免整数溢出 [CWE-190-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-190-b.html">避免在将结果转换为更广泛的整数类型的表达式中可能出现的整数溢出 [CWE-190-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-190-c.html">避免在将结果赋给更大整数类型的变量的表达式中可能出现的整数溢出 [CWE-190-c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-190-d.html">避免在将结果与更广泛的整数类型的表达式进行比较的表达式中可能出现的整数溢出 [CWE-190-d-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-190-e.html">'+'， '-'， '*' 运算符常量表达式中的整数溢出或下溢 [CWE-190-e-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-190-f.html">'&lt;&lt;' 运算符常量表达式中的整数溢出或下溢 [CWE-190-f-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-190-g.html">对常量无符号整数表达式的求值不应该导致循环 [CWE-190-g-5]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-20.html">CWE-20 不正确的输入验证 [CWE-20]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-20-a.html">避免在数组索引中有受污染数据 [CWE-20-a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-20-b.html">防止来自受污染数据的整数溢出/下溢 [CWE-20-b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-20-c.html">避免将未经验证的二进制数据传递给日志方法 [CWE-20-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-20-d.html">防止命令注入 [CWE-20-d-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-20-e.html">避免在输出控制台打印受污染的数据 [CWE-20-e-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-20-f.html">防止环境注入 [CWE-20-f-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-20-g.html">从格式字符串中排除未经消毒的用户输入 [CWE-20-g-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-20-h.html">防止 SQL 注入 [CWE-20-h-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-20-i.html">防止文件名注入 [CWE-20-i-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-20-j.html">不可信数据用作循环边界 [CWE-20-j-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-200.html">CWE-200 信息泄露 [CWE-200]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-200-a.html">不要将应用程序错误导致的潜在敏感信息打印到异常消息中 [CWE-200-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-22.html">CWE-22 将路径名错误地限制到受限目录 (“路径遍历”) [CWE-22]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-22-a.html">防止文件名注入 [CWE-22-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-269.html">CWE-269 权限管理不当 [CWE-269]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-269-a.html">在放弃特权时遵守正确的撤销命令 [CWE-269-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-269-b.html">确保成功地放弃特权 [CWE-269-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-287.html">CWE-287 错误 的身份验证 [CWE-287]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-287-a.html">不使用弱加密功能 [CWE-287-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-326.html">CWE-326 加密强度不够 [CWE-326]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-326-a.html">不使用弱加密功能 [CWE-326-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-362.html">CWE-362 使用不适合同步的共享资源并发执行 (“竞争条件”) [CWE-362]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-362-a.html">不允许使用容易发生争用的函数 [CWE-362-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-362-b.html">避免访问文件的资源竞争 [CWE-362-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-362-c.html">在修改位域时使用锁来防止竞争条件 [CWE-362-c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-362-d.html">当使用 fork 和文件描述符时避免竞争条件 [CWE-362-d-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-362-e.html">不要使用具有不同的锁集的全局变量 [CWE-362-e-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-400.html">CWE-400 不受控制的资源消耗 [CWE-400]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-400-a.html">不要在超过已定义的限制的栈上创建变量 [CWE-400-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-415.html">CWE-415 双重释放内存 [CWE-415]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-415-a.html">不得使用已经释放掉的资源 [CWE-415-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-416.html">CWE-416 释放内存后再使用 [CWE-416]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-416-a.html">不得使用已经释放掉的资源 [CWE-416-a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-416-b.html">不要指向已被释放的包装对象 [CWE-416-b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-416-c.html">被释放的内存在任何情况下都不应该被访问 [CWE-416-c-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-426.html">CWE-426 不可信的搜索路径 [CWE-426]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-426-a.html">谨慎使用以确保 LoadLibrary() 加载正确的库 [CWE-426-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-476.html">CWE-476 空指针引用 [CWE-476]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-476-a.html">避免空指针引用 [CWE-476-a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-476-b.html">避免在引用之后再检查空(null) [CWE-476-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-611.html">CWE-611 XML 错误限制外部实体引用 [CWE-611]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-611-a.html">在 libxerces-c 中禁用解析 XML 外部实体(XXE) [CWE-611-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-617.html">CWE-617 可达的断言 [CWE-617]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-617-a.html">不要使用断言 [CWE-617-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-704.html">CWE-704 类型转换错误或强制转换错误 [CWE-704]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-704-a.html">不得在指向函数的指针与指向函数的指针以外的任何类型之间执行转换 [CWE-704-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-704-b.html">函数类型的不兼容指针之间不能进行转换 [CWE-704-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-704-c.html">不应在指向不完整类型的指针与任何其他类型之间执行转换 [CWE-704-c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-704-d.html">不得在指向对象类型的指针和指向不同对象类型的指针之间执行强制转换 [CWE-704-d-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-704-e.html">不应在指向对象类型的指针与除 'uintptr_t' 或 'intptr_t' 以外的整数类型之间执行转换 [CWE-704-e-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-704-f.html">不应该执行从指向 void 的指针到指向对象的指针的转换 [CWE-704-f-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-704-g.html">不能在指向 void 的指针和算术类型之间执行强制类型转换 [CWE-704-g-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-704-h.html">不应在指向 void 的指针和算术类型之间执行隐式转换 [CWE-704-h-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-704-i.html">不应在指向对象的指针和非整数算术类型之间执行强制转换 [CWE-704-i-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-704-j.html">不应使用可能导致信息丢失的从较宽到较窄的整数类型的隐式转换 [CWE-704-j-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-704-k.html">不应使用可能导致信息丢失的从整型到浮点型的隐式转换 [CWE-704-k-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-704-l.html">不应使用可能会导致信息丢失的从整数常量到浮点类型的隐式转换 [CWE-704-l-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-732.html">CWE-732 关键资源不正确的权限分配 [CWE-732]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-732-a.html">在调用 'mkstemp' 之前调用 'umask' [CWE-732-a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-732-b.html">如果文件是使用 'open' 或 'openat' 系统调用创建的，则指定访问权限位 [CWE-732-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-770.html">CWE-770 无限制或节流地分配资源 [CWE-770]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-770-a.html">确保资源已释放 [CWE-770-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-772.html">CWE-772 遗漏超过有效期之后对资源的释放 [CWE-772]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-772-a.html">确保资源已释放 [CWE-772-a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-772-b.html">在具有虚函数的基类中定义虚拟析构函数 [CWE-772-b-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-78.html">CWE-78 操作系统命令中使用错误中和的特殊元素 (“操作系统命令注入”) [CWE-78]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-78-a.html">防止命令注入 [CWE-78-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-787.html">CWE-787 越界编写 [CWE-787]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-787-a.html">避免访问数组越界 [CWE-787-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-787-b.html">避免访问数组和指针越界 [CWE-787-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-787-c.html">避免由于定义不正确的格式限制导致的缓冲区溢出 [CWE-787-c-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-787-d.html">避免写入缓冲区时导致的溢出 [CWE-787-d-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-787-e.html">防止来自受污染数据的缓冲区溢出 [CWE-787-e-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-787-f.html">避免来自受污染数据的缓冲区写入溢出 [CWE-787-f-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-798.html">CWE-798 使用硬编码凭证 [CWE-798]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-798-a.html">不要硬编码字符串文字 [CWE-798-a-5]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-835.html">CWE-835 具有不可到达退出条件的循环 (“无限循环”) [CWE-835]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-835-a.html">避免无限循环 [CWE-835-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-863.html">CWE-863 错误的授权 [CWE-863]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-863-a.html">不要使用 'cuserid' 函数 [CWE-863-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-89.html">CWE-89 SQL 命令中使用错误中和的特殊元素 (“SQL 注入”) [CWE-89]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/CWE-89-a.html">防止 SQL 注入 [CWE-89-a-1]</a>
</li></ul>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/EXCEPT.html">异常 [EXCEPT]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/EXCEPT-01.html">绝不允许从析构函数、释放函数和交换函数中抛出异常 [EXCEPT-01-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/EXCEPT-02.html">按值抛出，按参考捕获 [EXCEPT-02-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/EXCEPT-03.html">不要从析构器中抛出 [EXCEPT-03-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/EXCEPT-04.html">所有的异常应该重新抛出，或者用标准的日志记录器进行记录 [EXCEPT-04-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/EXCEPT-05.html">在程序中不要运用 C++ 异常处理函数(例如,不得使用 throw, catch 和 try 等) [EXCEPT-05-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/EXCEPT-06.html">至少应该有一个异常处理程序来捕获所有其他未处理的异常 [EXCEPT-06-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/EXCEPT-07.html">空抛出(throw;)只能用于catch处理程序的复合语句中 [EXCEPT-07-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/EXCEPT-08.html">只有在程序启动后和终止前才会出现异常情况 [EXCEPT-08-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/EXCEPT-09.html">异常对象不应该有指针类型 [EXCEPT-09-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/EXCEPT-10.html">不得使用 goto 或 switch 开关语句将控制传递到 try 或 catch 模块中 [EXCEPT-10-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/EXCEPT-11.html">throw 语句的赋值表达式不得自身引起一个异常抛出 [EXCEPT-11-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/EXCEPT-12.html">NULL 不得被显式地抛出 [EXCEPT-12-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/EXCEPT-13.html">在代码中显式抛出的每个异常，在所有可能导致这一点的调用路径中都应该有一个兼容类型的处理程序 [EXCEPT-13-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/EXCEPT-14.html">如果函数的声明包含异常规范，则该函数只能抛出指定类型的异常 [EXCEPT-14-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/EXCEPT-15.html">类类型异常总是会被引用捕获 [EXCEPT-15-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/EXCEPT-16.html">以 function-try-block 实现的类构造函数或析构函数的处理程序不应引用该类或其基类的非静态成员 [EXCEPT-16-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/EXCEPT-17.html">如果在一个 try-catch 语句或函数 try-block 中为派生类及其部分或全部基类提供多个处理程序，则应将派生程度最高的处理程序排序为派生程度最高的基类 [EXCEPT-17-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/EXCEPT-18.html">在全局或命名空间作用域中调用的函数不能抛出未处理的异常 [EXCEPT-18-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/EXCEPT-19.html">异常对象必须是不可抛出复制构造函数 [EXCEPT-19-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/EXCEPT-20.html">继承自'std::exception'的类的显式声明复制构造函数应该具有非抛出异常规范 [EXCEPT-20-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/EXCEPT-21.html">所有用户提供的移动构造函数和移动分配操作符都不应异常退出 [EXCEPT-21-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/EXCEPT-22.html">可从函数中抛出的已检测异常应该直接在函数声明前的注释中指定 [EXCEPT-22-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/EXCEPT-23.html">不使用throw异常规范 [EXCEPT-23-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/EXCEPT-24.html">如果在 'try-catch' 语句或 'function-try-block' 中提供了多个处理程序，那么任何省略(catch-all)处理程序都应该是最后一个 [EXCEPT-24-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/EXCEPT-25.html">不要让 'catch' 块为空 [EXCEPT-25-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/EXCEPT-26.html">避免使用 catch-all 异常处理程序 [EXCEPT-26-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT.html">代码格式 [FORMAT]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-01.html">禁止使用未用 ASCII 空格的 Tab 字符 [FORMAT-01-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-02.html">将左边大括号 '{' 置于单独的行上 [FORMAT-02-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-03.html">将右闭大括号 '}' 置于单独的行上 [FORMAT-03-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-04.html">单行字符应该不超过 80 个 [FORMAT-04-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-05.html">宏的长度不能超过 10 行 [FORMAT-05-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-06.html">每行只允许有一条语句 [FORMAT-06-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-07.html">在赋值运算符之前应该有且仅有一个 ASCII 空格字符 [FORMAT-07-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-08.html">在赋值运算符之后应该有且仅有一个 ASCII 空格字符 [FORMAT-08-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-09.html">在位运算符之前应该有且仅有一个 ASCII 空格字符 [FORMAT-09-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-10.html">在位运算符之后应该有且仅有一个 ASCII 空格字符 [FORMAT-10-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-11.html">在位运算符 '&amp;'前后应该有且仅有一个 ASCII 空格字符 [FORMAT-11-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-12.html">在条件语句的关键字和左括号之间应该有且仅有一个 ASCII 空格字符 [FORMAT-12-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-13.html">在条件语句的开括号之后最多只能有一个 ASCII 的空格字符 [FORMAT-13-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-14.html">在三元条件操作符之前只能有一个 ASCII 的空格字符 [FORMAT-14-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-15.html">在三元条件操作符之后只能有一个 ASCII 的空格字符 [FORMAT-15-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-16.html">在关系和相等运算符前后只能有一个 ASCII 的空格字符 [FORMAT-16-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-17.html">在 '.' 或 '-&gt;' 操作符之后不能有空白格 [FORMAT-17-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-18.html">在 '.' 或 '-&gt;' 操作符之前不能有空白格 [FORMAT-18-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-19.html">在所有逗号后应该有且仅有一个 ASCII 的空格字符 [FORMAT-19-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-20.html">在所有分号后应该有且仅有一个 ASCII 的空格字符 [FORMAT-20-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-21.html">在一元运算符 "!" 或 "~" 及其操作数之间不能有空格 [FORMAT-21-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-22.html">在自增/自减运算符 (++/--) 和其操作数之间不能有空格 [FORMAT-22-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-23.html">在 "return" 或 "sizeof " 语句和其开括号间不能有空格 [FORMAT-23-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-24.html">在 "return" 或 &nbsp;"sizeof " 语句括号里面的参数或表达式不能有空格 [FORMAT-24-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-25.html">'sizeof' 语句应该与括号一起使用 [FORMAT-25-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-25_b.html">return 语句应该使用括号 [FORMAT-25_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-26.html">在逻辑运算符的前后应该有且仅有一个 ASCII 空格字符 [FORMAT-26-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-27.html">代码行以每一级四个空格缩进 [FORMAT-27-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-28.html">在函数的定义中，函数返回类型应该直接写在函数名称前面的单独一行上 [FORMAT-28-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-29.html">不允许在同一行声明多个变量 [FORMAT-29-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-30.html">在函数名后直接写左括号 [FORMAT-30-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-31.html">条件表达式中单独进行逻辑判断 [FORMAT-31-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-32.html">解引用运算符 '*' 和地址运算符 '&amp;' 应直接与类型连接在一起 [FORMAT-32-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-33.html">每个变量都要在单独的声明语句中被声明 [FORMAT-33-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-34.html">包含一个区域的括号 "{}" 应该放置在同一列 [FORMAT-34-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-35.html">在函数声明的时候，前括号和第一个形参应该于函数名写在同一行上 [FORMAT-35-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-36.html">同级语句行应该缩进到相同的位置 [FORMAT-36-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-37.html">控制语句块的第一行应该比控制语句关键字缩进更多 [FORMAT-37-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-38.html">当函数的形参超过两个的时候，前括号和第一个参数应该和函数名写在一行,其他参数应该再单独一行写一个 [FORMAT-38-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-39.html">按字母顺序排序 #include 指令 [FORMAT-39-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-40.html">空格在开始方括号 '[' 之后和结束方括号 ']' 之前的使用方式应该保持一致 [FORMAT-40-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-41.html">在开始方括号 '[' 和前面的标识符之间不应该有空格 [FORMAT-41-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-42.html">用于包住一个代码模块的括号 ("{}") 在同一行上除了注释以外不应该有其它代码 [FORMAT-42-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-43.html">大括号 ("{}") 将把一个块放在同一列中 [FORMAT-43-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-44.html">用于包住一个代码模块的括号 ("{}") 不允许在 "{" 之后或 "}" 之前有空行 [FORMAT-44-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-45.html">在一元运算符 "&amp;", "*", "+", "-" 及其操作数之间不能有空格 [FORMAT-45-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/FORMAT-46.html">在宏定义中的自增/自减运算符 (++/--) 及其操作数之间不能有空格 [FORMAT-46-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369.html">GJB5369-2005 航天型号 C 语言安全子集 [GJB5369]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_10_1_1.html">禁止使用嵌套的注释 [GJB5369-4_10_1_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_10_2_2.html">建议不使用单行注释“∥” [GJB5369-4_10_2_2-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_11_1_1.html">禁止使用不合适的循环变量类型 [GJB5369-4_11_1_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_11_1_2.html">循环变量必须是局部声明的 [GJB5369-4_11_1_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_11_2_1.html">谨慎使用无限循环语句 [GJB5369-4_11_2_1-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_11_2_2.html">避免在循环中使用 break 语句 [GJB5369-4_11_2_2-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_11_2_3.html">谨慎使用无法控制的循环条件 [GJB5369-4_11_2_3-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_12_1_1.html">禁止对指针变量使用强制类型转换赋值 [GJB5369-4_12_1_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_12_2_1.html">谨慎使用其它类型变量给指针赋值 [GJB5369-4_12_2_1-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_12_2_2.html">避免使用不必要的类型转换 [GJB5369-4_12_2_2-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_13_1_1.html">枚举元素的初始化必须完整 [GJB5369-4_13_1_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_13_1_2.html">结构体变量初始化的类型必须一致 [GJB5369-4_13_1_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_13_1_3.html">结构体变量初始化的嵌套结构必须与定义的相一致 [GJB5369-4_13_1_3-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_13_1_4.html">变量使用前必须被赋过值 [GJB5369-4_13_1_4-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_14_1_1.html">禁止对实数类型的量做是否相等的比较 [GJB5369-4_14_1_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_14_1_2.html">禁止逻辑判别的表达式不是逻辑表达式 [GJB5369-4_14_1_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_14_1_3.html">switch 语句中的表达式禁止是逻辑表达式 [GJB5369-4_14_1_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_14_2_1.html">建议逻辑表达式采用显式的表达 [GJB5369-4_14_2_1-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_15_1_1.html">禁止枚举类型中的元素名与已有的变量名同名 [GJB5369-4_15_1_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_15_1_2.html">禁止局部变量与全局变量同名 [GJB5369-4_15_1_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_15_1_3.html">禁止形参名与全局变量名同名 [GJB5369-4_15_1_3-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_15_1_4.html">禁止形参名与类型或标识符同名 [GJB5369-4_15_1_4-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_15_1_5.html">禁止在内部块中重定义已有的变量名 [GJB5369-4_15_1_5-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_15_1_6.html">禁止复杂表达式中使用 volatile 类型的变量 [GJB5369-4_15_1_6-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_15_2_1.html">在源程序中谨慎使用非标准字符 [GJB5369-4_15_2_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_15_2_2.html">禁止使用预处理操作符 # 和 ## [GJB5369-4_15_2_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_1_1_1.html">过程名禁止被重用 [GJB5369-4_1_1_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_1_1_10.html">禁止过程或函数中的参数表为空 [GJB5369-4_1_1_10-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_1_1_11.html">禁止在同一个宏中使用多个 # 或 ## [GJB5369-4_1_1_11-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_1_1_12.html">禁止定义不象函数的宏 [GJB5369-4_1_1_12-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_1_1_13.html">禁止在宏中包含不允许的项 [GJB5369-4_1_1_13-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_1_1_14_a.html">禁止重新定义保留字 [GJB5369-4_1_1_14_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_1_1_14_b.html">禁止重新定义保留字 [GJB5369-4_1_1_14_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_1_1_15.html">字符型变量必须明确定义是有符号还是无符号 [GJB5369-4_1_1_15-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_1_1_16.html">禁止对一个名字重新定义 [GJB5369-4_1_1_16-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_1_1_17.html">用 typedef 自定义的类型禁止被重新定义 [GJB5369-4_1_1_17-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_1_1_18.html">禁止在同一个文件中有 #if 而没有 #endif [GJB5369-4_1_1_18-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_1_1_19.html">禁止数组没有边界限定 [GJB5369-4_1_1_19-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_1_1_2.html">标号名禁止被重用 [GJB5369-4_1_1_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_1_1_20.html">禁止在#include&lt;......&gt;中使用绝对路径名 [GJB5369-4_1_1_20-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_1_1_21.html">禁止结构体声明不完整 [GJB5369-4_1_1_21-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_1_1_3.html">禁止在结构体定义中含有空域 [GJB5369-4_1_1_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_1_1_4.html">禁止声明多重标号 [GJB5369-4_1_1_4-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_1_1_6.html">在过程声明中必须对参数说明 [GJB5369-4_1_1_6-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_1_1_7.html">禁止过程参数只有类型没有标识符 [GJB5369-4_1_1_7-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_1_1_8.html">禁止在过程参数表中使用省略号 [GJB5369-4_1_1_8-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_1_1_9.html">禁止重新定义使用 C 或 C++ 的关键字 [GJB5369-4_1_1_9-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_1_2_1.html">建议使用typedef在统一的变量声明头文件中对基本变量类型重新定义 [GJB5369-4_1_2_1-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_1_2_2.html">避免将过程定义为参数 [GJB5369-4_1_2_2-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_1_2_3.html">过程中避免使用过多的参数，建议不要超过20 个 [GJB5369-4_1_2_3-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_1_2_4.html">在结构体定义中谨慎使用位域 [GJB5369-4_1_2_4-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_1_2_6.html">禁止在块中使用 #define 或 #undef [GJB5369-4_1_2_6-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_1_2_7.html">谨慎使用 #pragma [GJB5369-4_1_2_7-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_1_2_8.html">谨慎使用联合(union)的声明 [GJB5369-4_1_2_8-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_1_2_9.html">在结构体中谨慎使用无名位域 [GJB5369-4_1_2_9-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_2_1_10.html">main 必须定义为 int main(void) 或 int main(int,char*[]) 的形式 [GJB5369-4_2_1_10-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_2_1_2.html">循环体必须用大括号括起来 [GJB5369-4_2_1_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_2_1_3.html">then/else 中的语句必须用大括号括起来 [GJB5369-4_2_1_3-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_2_1_4.html">逻辑表达式的连接必须使用括号 [GJB5369-4_2_1_4-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_2_1_5.html">禁止在头文件前有可执行代码 [GJB5369-4_2_1_5-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_2_1_6.html">宏参数必须用括号括起来 [GJB5369-4_2_1_6-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_2_1_7.html">嵌入汇编程序的过程必须是纯汇编程序 [GJB5369-4_2_1_7-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_2_1_8.html">头文件名禁止使用 "‘"、"\"和"/#" 等字符 [GJB5369-4_2_1_8-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_2_1_9.html">禁止字符串中单独使用“\”，字符串的终止必须使用“\0” [GJB5369-4_2_1_9-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_2_2_1.html">建议一个文件中的程序总行不超过2000 行 [GJB5369-4_2_2_1-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_2_2_2.html">建议一个过程或函数中的程序总行不超过 200 行 [GJB5369-4_2_2_2-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_3_1_1.html">禁止条件判别成立时相应分支无可执行语句 [GJB5369-4_3_1_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_3_1_2.html">在 if … else if 语句中必须使用 else 分支 [GJB5369-4_3_1_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_3_1_3.html">禁止条件判别的 else 分支无可执行语句 [GJB5369-4_3_1_3-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_3_1_4.html">在 switch 语句中必须有 default 语句 [GJB5369-4_3_1_4-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_3_1_5.html">禁止使用空 switch 语句 [GJB5369-4_3_1_5-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_3_1_6.html">禁止 switch 语句中只包含 default 语句 [GJB5369-4_3_1_6-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_3_1_7.html">禁止 switch 的 case 语句不是由 break 终止 [GJB5369-4_3_1_7-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_3_1_8.html">禁止switch的case语句中无任何可执行语句 [GJB5369-4_3_1_8-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_4_1_1.html">禁止将参数指针赋值给过程指针 [GJB5369-4_4_1_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_4_1_2.html">禁止指针的指针超过两级 [GJB5369-4_4_1_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_4_1_3.html">禁止将过程声明为指针类型 [GJB5369-4_4_1_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_4_2_1.html">谨慎使用指针的逻辑比较 [GJB5369-4_4_2_1-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_4_2_2.html">谨慎对指针进行代数运算 [GJB5369-4_4_2_2-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_5_1_1.html">禁止直接从过程中跳出 [GJB5369-4_5_1_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_5_1_2.html">禁止使用 goto 语句 [GJB5369-4_5_1_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_5_2_1.html">避免使用 setjmp/longjmp [GJB5369-4_5_2_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_6_1_1.html">禁止在非赋值表达式中出现赋值操作符 [GJB5369-4_6_1_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_6_1_11.html">禁止对常数值做逻辑非的运算 [GJB5369-4_6_1_11-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_6_1_12.html">禁止对有符号类型使用位运算 [GJB5369-4_6_1_12-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_6_1_13.html">禁止对枚举类型的越限使用 [GJB5369-4_6_1_13-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_6_1_15.html">禁止在逻辑表达式中使用赋值操作符 [GJB5369-4_6_1_15-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_6_1_16.html">禁止赋值操作符与“&amp;&amp;”或“||”连用 [GJB5369-4_6_1_16-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_6_1_17.html">禁止位操作符带有布尔型的操作数 [GJB5369-4_6_1_17-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_6_1_18.html">禁止位操作符作用于布尔值 [GJB5369-4_6_1_18-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_6_1_2.html">数组的使用必须保证不会出现越界 [GJB5369-4_6_1_2-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_6_1_3.html">禁止对有符号类型进行移位运算 [GJB5369-4_6_1_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_6_1_4.html">对变量进行移位运算必须保证不会产生溢出 [GJB5369-4_6_1_4-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_6_1_5.html">禁止给无符号变量赋负值 [GJB5369-4_6_1_5-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_6_1_6.html">有符号类型的位长度必须大于等于两位 [GJB5369-4_6_1_6-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_6_1_7.html">位的定义必须是有符号整数或无符号整数 [GJB5369-4_6_1_7-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_6_1_8.html">禁止给变量赋的值与变量的类型不一致 [GJB5369-4_6_1_8-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_6_1_9.html">赋值类型必须匹配 [GJB5369-4_6_1_9-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_6_2_1.html">避免使用逗号操作符 [GJB5369-4_6_2_1-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_6_2_2.html">谨防长度操作符 sizeof 的副作用 [GJB5369-4_6_2_2-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_6_2_3.html">谨慎使用不同类型变量的混合运算 [GJB5369-4_6_2_3-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_6_2_4.html">避免由于设计的原因导致某些代码不能执行 [GJB5369-4_6_2_4-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_7_1_2.html">主过程所在文件中禁止有未被该文件中任何过程调用的子过程 [GJB5369-4_7_1_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_7_1_3.html">static类型的过程在所在文件中必须被调用 [GJB5369-4_7_1_3-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_7_1_4.html">禁止使用被禁用的过程、函数、文件或名称 [GJB5369-4_7_1_4-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_7_1_6.html">禁止同一个表达式中调用多个相关函数 [GJB5369-4_7_1_6-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_7_1_8.html">禁止 void 类型的变量作为参数进行传递 [GJB5369-4_7_1_8-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_7_1_9.html">禁止实参和形参类型不一致 [GJB5369-4_7_1_9-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_7_2_1.html">避免过程参数在过程调用中未被使用 [GJB5369-4_7_2_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_7_2_2.html">避免以非调用方式使用函数 [GJB5369-4_7_2_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_7_2_3.html">谨慎使用 abort, exit 等函数 [GJB5369-4_7_2_3-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_8_1_1.html">禁止单独使用小写字母“l”或大写字母“O”作为变量名 [GJB5369-4_8_1_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_8_1_2.html">禁止三字母词的使用 [GJB5369-4_8_1_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_8_1_3.html">使用的八进制数必须加以注释 [GJB5369-4_8_1_3-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_8_2_1.html">避免使用"+="或"-="操作符 [GJB5369-4_8_2_1-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_8_2_2.html">谨慎使用 "++" 或 "--" 操作符 [GJB5369-4_8_2_2-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_8_2_3.html">避免使用 continue 语句 [GJB5369-4_8_2_3-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_8_2_4.html">谨慎使用三重表达式 [GJB5369-4_8_2_4-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_8_2_5.html">避免使用不起作用的语句 [GJB5369-4_8_2_5-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_8_2_6.html">避免使用空语句 [GJB5369-4_8_2_6-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_8_2_7.html">谨慎使用寄存器变量 [GJB5369-4_8_2_7-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_8_2_8.html">避免使用老的参数表的定义形式 [GJB5369-4_8_2_8-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_9_1_1.html">函数必须有返回语句 [GJB5369-4_9_1_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_9_1_2.html">禁止 Void 类型的过程中的 return 语句带有返回值 [GJB5369-4_9_1_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_9_1_3.html">有返回值的函数中 return 必须带有返回值 [GJB5369-4_9_1_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB5369-4_9_1_4.html">函数返回类型必须一致 [GJB5369-4_9_1_4-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114.html">GJB8114-2013 C/C++ 语言编程安全子集 [GJB8114]</a></b>
<ul>
<li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP.html">GJB8114-CPP 类别 [GJB8114-CPP]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP-A_2_1_1.html">谨慎使用派生类由虚拟基类派生 [GJB8114-CPP-A_2_1_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP-A_2_1_2.html">谨慎使用内联函数 [GJB8114-CPP-A_2_1_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP-A_2_5_1.html">建议使用C++的类型转换操作符，避免使用C的类型转换形式 [GJB8114-CPP-A_2_5_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP-A_2_7_1.html">类中函数的实现代码避免在类定义的内部定义 [GJB8114-CPP-A_2_7_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP-A_2_8_1.html">建议在所有指定捕获之后使用缺省捕获防范遗漏的异常 [GJB8114-CPP-A_2_8_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP-A_2_8_2.html">谨慎对指针类型进行抛出捕获 [GJB8114-CPP-A_2_8_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP-A_2_9_2.html">建议除常数指针外，const说明均在类型说明的最外层 [GJB8114-CPP-A_2_9_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP-A_2_9_3.html">建议不要对“&amp;&amp;”、“||”、“,”进行操作符重载 [GJB8114-CPP-A_2_9_3-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP-R_1_1_11.html">位定义的整数型变量必须明确定义是有符号还是无符号的 [GJB8114-CPP-R_1_1_11-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP-R_2_1_1.html">含有动态分配成员的类，必须编写拷贝构造函数，并重载赋值操作符 [GJB8114-CPP-R_2_1_1-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP-R_2_1_2.html">虚拟基类指针转换为派生类指针必须使用dynamic_cast转换 [GJB8114-CPP-R_2_1_2-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP-R_2_1_3.html">菱形层次结构的派生设计，对基类派生必须使用virtual说明 [GJB8114-CPP-R_2_1_3-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP-R_2_1_4.html">抽象类中的复制操作符重载必须是保护的或私有的 [GJB8114-CPP-R_2_1_4-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP-R_2_2_1.html">构造函数中禁止使用全局变量 [GJB8114-CPP-R_2_2_1-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP-R_2_2_2.html">类中必须明确定义缺省构造函数 [GJB8114-CPP-R_2_2_2-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP-R_2_2_4.html">类中所有成员变量必须在构造函数中初始化 [GJB8114-CPP-R_2_2_4-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP-R_2_2_5.html">派生类构造函数必须在初始化列表中说明直接基类构造函数 [GJB8114-CPP-R_2_2_5-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP-R_2_3_1.html">具有虚拟成员函数的类，析构函数必须是虚拟的 [GJB8114-CPP-R_2_3_1-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP-R_2_3_2.html">析构函数中禁止存在不是由自身捕获处理的异常 [GJB8114-CPP-R_2_3_2-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP-R_2_4_1.html">基类虚拟函数的参数缺省值在派生类重写函数中禁止被改变 [GJB8114-CPP-R_2_4_1-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP-R_2_4_2.html">派生类对基类虚拟函数重写的声明必须使用virtual显示说明 [GJB8114-CPP-R_2_4_2-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP-R_2_4_3.html">禁止非纯虚函数被纯虚拟函数重写 [GJB8114-CPP-R_2_4_3-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP-R_2_5_1.html">禁止将不相关的指针类型强制转换为对象指针类型 [GJB8114-CPP-R_2_5_1-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP-R_2_5_2.html">指针或引用的类型转换中禁止移除const或volatile属性 [GJB8114-CPP-R_2_5_2-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP-R_2_7_1.html">函数中固定长度数组变量的传递必须使用引用方式 [GJB8114-CPP-R_2_7_1-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP-R_2_7_2.html">定义为const的成员函数禁止返回非const的指针或引用 [GJB8114-CPP-R_2_7_2-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP-R_2_7_3.html">禁止可导致非资源性对象数据被外部修改的成员函数返回 [GJB8114-CPP-R_2_7_3-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP-R_2_8_1.html">捕获的顺序必须按由派生类到基类的次序排序 [GJB8114-CPP-R_2_8_1-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP-R_2_8_2.html">每个指定的抛出必须有与之匹配的捕获 [GJB8114-CPP-R_2_8_2-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP-R_2_8_3.html">异常抛出的对象必须使用引用方式捕获 [GJB8114-CPP-R_2_8_3-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP-R_2_8_5.html">禁止显式直接抛出NULL [GJB8114-CPP-R_2_8_5-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-CPP-R_2_9_1.html">模板的声明、定义与实现必须在同一个文件之中 [GJB8114-CPP-R_2_9_1-1]</a>
</li></ul>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_10_1.html">浮点型数转换成整型数应考虑是否需要四舍五入 [GJB8114-A_1_10_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_10_2.html">谨慎将double型数转换成float型数 [GJB8114-A_1_10_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_10_3.html">谨慎将长整型数转换成短整型数 [GJB8114-A_1_10_3-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_10_4.html">谨慎将指针量赋予非指针变量或非指针量赋予指针变量 [GJB8114-A_1_10_4-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_11_1.html">建议变量在声明的同时进行初始化 [GJB8114-A_1_11_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_11_2.html">建议所有全局变量在统一设计的初始化模块中进行初始化 [GJB8114-A_1_11_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_12_1.html">与常数进行是否相等的判别，建议常数在左，变量在右 [GJB8114-A_1_12_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_13_1.html">推荐使用带类型前缀的变量命名 [GJB8114-A_1_13_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_13_1_a.html">字符型变量命名应以c为前缀 [GJB8114-A_1_13_1_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_13_1_b.html">有符号字符型变量应以uc为前缀 [GJB8114-A_1_13_1_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_13_1_c.html">无符号字符型变量应以uc为前缀 [GJB8114-A_1_13_1_c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_13_1_d.html">所有整型变量以小写字母 'i' 开头 [GJB8114-A_1_13_1_d-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_13_1_f.html">所有无符号整型变量以 'ui' 开头 [GJB8114-A_1_13_1_f-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_13_1_g.html">所有短整型变量以字母 's' 开头 [GJB8114-A_1_13_1_g-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_13_1_i.html">无符号短整型变量应以us为前缀 [GJB8114-A_1_13_1_i-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_13_1_j.html">所有长整型变量名以 'l' 开头 [GJB8114-A_1_13_1_j-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_13_1_m.html">无符号长整型变量应以'ul'为前缀 [GJB8114-A_1_13_1_m-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_13_1_n.html">浮点类型变量名以小写字母 'f' 开头 [GJB8114-A_1_13_1_n-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_13_1_p.html">双精类型变量名以小写字母 'd' 开头 [GJB8114-A_1_13_1_p-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_13_1_q.html">长双精度型变量应以ld为前缀 [GJB8114-A_1_13_1_q-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_13_2.html">谨慎使用寄存器变量 [GJB8114-A_1_13_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_1_1.html">建议使用typedef对基本变量类型重新定义。 [GJB8114-A_1_1_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_1_2.html">谨慎由于宏中括号不匹配造成使用上的误解 [GJB8114-A_1_1_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_1_3.html">宏定义中谨慎使用##或#。 [GJB8114-A_1_1_3-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_1_4.html">建议函数内部变量在函数体开始处统一定义 [GJB8114-A_1_1_4-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_1_5.html">建议结构体嵌套定义不超过3层 [GJB8114-A_1_1_5-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_1_6_a.html">建议用宏或const定义常数。 [GJB8114-A_1_1_6_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_1_6_b.html">建议用宏或const定义常数。 [GJB8114-A_1_1_6_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_2_1.html">一个文件中的语句总行不超过2000行。 [GJB8114-A_1_2_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_2_2.html">一个函数中的语句总行不超过200行。 [GJB8114-A_1_2_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_2_3.html">C语言程序建议使用标准C的注释符，谨慎使用 //注释。 [GJB8114-A_1_2_3-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_3_1.html">谨慎使用函数指针。 [GJB8114-A_1_3_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_3_2.html">谨慎使用无类型指针 [GJB8114-A_1_3_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_3_3.html">谨慎对指针进行算术运算。 [GJB8114-A_1_3_3-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_4_1.html">避免层数过多的分支嵌套，建议最多不超过7层。 [GJB8114-A_1_4_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_5_1.html">谨慎使用goto语句 [GJB8114-A_1_5_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_6_2.html">谨慎做整型量除以整型变量的除法 [GJB8114-A_1_6_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_6_4.html">避免使用strcpy函数，应使用strncpy函数替代 [GJB8114-A_1_6_4-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_6_5.html">避免使用strcat函数，应使用strncat函数替代 [GJB8114-A_1_6_5-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_6_6.html">谨慎使用逗号操作符 [GJB8114-A_1_6_6-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_7_1.html">函数中避免使用过多的参数，建议不要超过10个 [GJB8114-A_1_7_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_7_2.html">函数中避免存在未被使用的调用参数 [GJB8114-A_1_7_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_7_3.html">谨慎使用abort、exit函数 [GJB8114-A_1_7_3-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_7_5.html">函数中数组变量作为参数指针传递时，建议同时传递数组长度 [GJB8114-A_1_7_5-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_8_1.html">避免使用空语句 [GJB8114-A_1_8_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_8_2_a.html">避免无用的多余变量 [GJB8114-A_1_8_2_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_8_2_b.html">避免无用的多余变量 [GJB8114-A_1_8_2_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_8_3.html">避免无用的多余函数 [GJB8114-A_1_8_3-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_8_4_a.html">推荐使用数字类型后缀 [GJB8114-A_1_8_4_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_8_4_b.html">推荐使用数字类型后缀 [GJB8114-A_1_8_4_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_8_4_c.html">推荐使用数字类型后缀 [GJB8114-A_1_8_4_c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_8_4_d.html">推荐使用数字类型后缀 [GJB8114-A_1_8_4_d-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_9_1.html">谨慎使用无限循环语句 [GJB8114-A_1_9_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_9_2.html">谨慎在循环中使用多个break语句 [GJB8114-A_1_9_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_1_9_3.html">谨慎在循环中使用多个continue语句 [GJB8114-A_1_9_3-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-A_2_9_1.html">建议模板参数列表中的类型参数使用typename关键字说明 [GJB8114-A_2_9_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_10_1.html">浮点数变量赋给整型变量必须强制转换 [GJB8114-R_1_10_1-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_10_2.html">长整数变量赋给短整数变量必须强制转换 [GJB8114-R_1_10_2-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_10_3.html">double型变量赋给float型变量必须强制转换 [GJB8114-R_1_10_3-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_10_5.html">将指针量赋予非指针变量或非指针量赋予指针变量，必须使用强制转换 [GJB8114-R_1_10_5-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_10_6.html">禁止使用无实质作用的类型转换 [GJB8114-R_1_10_6-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_11_1.html">避免在初始化之前使用 [GJB8114-R_1_11_1-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_11_2.html">变量初始化禁止隐含依赖于系统的缺省值 [GJB8114-R_1_11_2-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_11_3.html">结构体初始化的嵌套结构必须与定义一致 [GJB8114-R_1_11_3-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_11_4.html">枚举元素定义中的初始化必须完整 [GJB8114-R_1_11_4-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_12_1.html">禁止对逻辑量进行大于或小于的逻辑比较 [GJB8114-R_1_12_1-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_12_2.html">禁止对指针进行大于或小于的逻辑比较 [GJB8114-R_1_12_2-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_12_3.html">禁止对浮点数进行是否相等的比较 [GJB8114-R_1_12_3-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_12_4.html">禁止对无符号数进行大于等于零或小于零的比较 [GJB8114-R_1_12_4-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_12_5.html">禁止无符号数与有符号数之间的直接比较 [GJB8114-R_1_12_5-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_13_1.html">禁止局部变量与全局变量同名 [GJB8114-R_1_13_1-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_13_11.html">禁止单独使用小写字母“l”或大写字母“O”作为变量名 [GJB8114-R_1_13_11-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_13_13.html">禁止在表达式中出现多个同一volatile类型变量的运算 [GJB8114-R_1_13_13-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_13_14.html">禁止将NULL做为整型数0使用 [GJB8114-R_1_13_14-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_13_15.html">禁止给无符号类型变量赋负值 [GJB8114-R_1_13_15-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_13_2.html">禁止函数形参与全局变量同名 [GJB8114-R_1_13_2-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_13_3.html">禁止变量名与函数名同名 [GJB8114-R_1_13_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_13_4.html">禁止变量名与标识名同名。 [GJB8114-R_1_13_4-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_13_5.html">禁止变量名与枚举元素同名 [GJB8114-R_1_13_5-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_13_6.html">禁止变量名与typedef自定义的类型名同名 [GJB8114-R_1_13_6-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_13_7.html">禁止在内部块中重定义已有的变量名 [GJB8114-R_1_13_7-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_13_8.html">不能使用大小写字母，下划线区分标识符，也不能使用容易与数字混淆的字母做为标识符名字 [GJB8114-R_1_13_8-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_1_10.html">位定义的有符号整型变量位长必须大于1 [GJB8114-R_1_1_10-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_1_13_a.html">函数声明中必须对参数类型进行声明，并带有变量名 [GJB8114-R_1_1_13_a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_1_13_b.html">函数声明中必须对参数类型进行声明，并带有变量名 [GJB8114-R_1_1_13_b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_1_14_a.html">禁止函数原形中的参数与实际定义中的形参不一致 [GJB8114-R_1_1_14_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_1_14_b.html">函数声明必须与函数原型一致(形参类型和实参必须匹配) [GJB8114-R_1_1_14_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_1_17.html">禁止在函数体内使用外部声明。 [GJB8114-R_1_1_17-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_1_18.html">数组定义禁止没有显式的边界限定。 [GJB8114-R_1_1_18-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_1_1_a.html">禁止通过宏定义改变关键字和基本类型含义 [GJB8114-R_1_1_1_a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_1_1_b.html">禁止通过宏定义改变关键字和基本类型含义 [GJB8114-R_1_1_1_b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_1_2.html">禁止将其它标识宏定义为关键字和基本类型 [GJB8114-R_1_1_2-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_1_20.html">用于数值计算的字符型变量必须明确定义是有符号还是无符号。 [GJB8114-R_1_1_20-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_1_21.html">禁止在#include语句中使用绝对路径。 [GJB8114-R_1_1_21-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_1_23.html">函数参数表为空时，必须使用void明确说明。 [GJB8114-R_1_1_23-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_1_3.html">用 typedef 自定义的类型禁止被重新定义。 [GJB8114-R_1_1_3-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_1_4.html">禁止重新定义C或C++的关键字 [GJB8114-R_1_1_4-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_1_6.html">函数中的#define和#undef必须配对使用。 [GJB8114-R_1_1_6-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_1_7.html">以函数形式定义的宏，参数和结果必须用括号括起来 [GJB8114-R_1_1_7-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_1_8.html">结构、联合、枚举的定义中必须定义标识名。 [GJB8114-R_1_1_8-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_1_9.html">结构体定义中禁止含有无名结构体 [GJB8114-R_1_1_9-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_2_1.html">循环体必须用大括号括起来。 [GJB8114-R_1_2_1-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_2_2.html">if、else if、else必须用大括号括起来。 [GJB8114-R_1_2_2-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_2_3.html">禁止在头文件前有可执行代码。 [GJB8114-R_1_2_3-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_2_4.html">引起二义性理解的逻辑表达式，必须使用括号显式说明优先级顺序。 [GJB8114-R_1_2_4-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_2_5.html">逻辑判别表达式中的运算项必须要使用括号。 [GJB8114-R_1_2_5-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_2_6.html">禁止嵌套注释 [GJB8114-R_1_2_6-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_3_1.html">禁止指针的指针超过两级。 [GJB8114-R_1_3_1-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_3_10.html">确保资源已释放 [GJB8114-R_1_3_10-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_3_2.html">函数指针的使用必须加以&amp;明确说明 [GJB8114-R_1_3_2-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_3_3.html">禁止对参数指针进行赋值。 [GJB8114-R_1_3_3-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_3_4.html">禁止将局部变量地址做为函数返回值返回。 [GJB8114-R_1_3_4-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_3_5_a.html">避免空指针引用 [GJB8114-R_1_3_5_a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_3_5_b.html">不得使用已经释放掉的资源 [GJB8114-R_1_3_5_b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_3_5_c.html">禁止使用或释放未分配空间或已被释放的指针。 [GJB8114-R_1_3_5_c-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_3_6.html">指针变量被释放后必须置为NULL [GJB8114-R_1_3_6-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_3_7.html">动态分配的指针变量定义时如未被分配空间必须初始化为NULL [GJB8114-R_1_3_7-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_3_8.html">避免空指针引用 [GJB8114-R_1_3_8-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_3_9.html">空指针必须使用NULL，禁止使用整型数0。 [GJB8114-R_1_3_9-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_4_1.html">在if-else if语句中必须使用else分支。 [GJB8114-R_1_4_1-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_4_2.html">条件判定分支如果为空，必须以单独一行的分号加注释进行明确说明 [GJB8114-R_1_4_2-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_4_3.html">禁止使用空switch语句 [GJB8114-R_1_4_3-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_4_4.html">禁止对bool量使用switch语句。 [GJB8114-R_1_4_4-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_4_5.html">禁止switch语句中只包含default语句 [GJB8114-R_1_4_5-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_4_6.html">除枚举类型列举完全外，switch必须要有default。 [GJB8114-R_1_4_6-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_4_7.html">switch中的case和default必须以break或return终止，共用case必须加以明确注释。 [GJB8114-R_1_4_7-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_4_8.html">switch语句的所有分支必须具有相同的层次范围。 [GJB8114-R_1_4_8-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_5_1_a.html">禁止从复合语句外goto到复合语句内，或由下向上goto。 [GJB8114-R_1_5_1_a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_5_1_b.html">禁止从复合语句外goto到复合语句内，或由下向上goto。 [GJB8114-R_1_5_1_b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_5_2.html">禁止使用 setjmp/longjmp。 [GJB8114-R_1_5_2-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_6_1.html">禁止将浮点常数赋给整型变量 [GJB8114-R_1_6_1-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_6_10.html">禁止对常数值做逻辑非的运算 [GJB8114-R_1_6_10-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_6_11.html">避免使用枚举类型隐式类型转换 [GJB8114-R_1_6_11-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_6_12.html">避免除零错误 [GJB8114-R_1_6_12-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_6_13.html">禁止在sizeof中使用赋值 [GJB8114-R_1_6_13-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_6_14.html">避免读取缓冲区时导致的溢出 [GJB8114-R_1_6_14-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_6_15.html">避免写入缓冲区时导致的溢出 [GJB8114-R_1_6_15-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_6_16.html">不得使用已经释放掉的资源 [GJB8114-R_1_6_16-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_6_17.html">不得使用无效的指针释放资源 [GJB8114-R_1_6_17-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_6_18.html">禁止使用gets函数，应使用fgets函数替代 [GJB8114-R_1_6_18-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_6_2_a.html">禁止将越界整数赋给整型变量 [GJB8114-R_1_6_2_a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_6_2_b.html">禁止将越界整数赋给整型变量 [GJB8114-R_1_6_2_b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_6_3.html">禁止在逻辑表达式中使用赋值语句 [GJB8114-R_1_6_3-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_6_4.html">禁止对逻辑表达式进行位运算 [GJB8114-R_1_6_4-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_6_5.html">禁止在运算表达式中或函数调用参数中使用++或--操作符 [GJB8114-R_1_6_5-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_6_6.html">对变量进行移位运算禁止超出变量长度 [GJB8114-R_1_6_6-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_6_7.html">禁止移位操作中的移位数为负数 [GJB8114-R_1_6_7-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_6_8.html">避免访问数组越界 [GJB8114-R_1_6_8-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_7_1.html">禁止覆盖标准函数库的函数 [GJB8114-R_1_7_1-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_7_10.html">函数返回值的类型必须与定义一致 [GJB8114-R_1_7_10-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_7_11.html">非void返回值的函数调用时返回值未使用的话需要用void说明 [GJB8114-R_1_7_11-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_7_12.html">无返回值的函数，调用时禁止再用(void)重复说明 [GJB8114-R_1_7_12-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_7_14.html">禁止同一个表达式中调用多个顺序相关函数 [GJB8114-R_1_7_14-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_7_15.html">禁止在函数参数表中使用省略号 [GJB8114-R_1_7_15-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_7_16.html">禁止使用直接或间接自调用函数 [GJB8114-R_1_7_16-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_7_2.html">禁止函数的实参和形参类型不一致 [GJB8114-R_1_7_2-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_7_5.html">函数声明和函数定义中的参数类型必须一致 [GJB8114-R_1_7_5-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_7_7.html">有返回值的函数必须通过返回语句返回 [GJB8114-R_1_7_7-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_7_8.html">禁止无返回值函数的返回语句带有返回值 [GJB8114-R_1_7_8-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_7_9.html">有返回值函数的返回语句必须带有返回值 [GJB8114-R_1_7_9-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_8_1_a.html">在 "else" 语句块中不应存在不可达代码 [GJB8114-R_1_8_1_a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_8_1_b.html">在 'return', 'break', 'continue', 和 'goto' 语句之后不应存在不可达代码 [GJB8114-R_1_8_1_b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_8_1_c.html">在 "if/else/while/for" 语句块中不应存在不可达代码 [GJB8114-R_1_8_1_c-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_8_1_d.html">在 Switch 语句中不应存在不可达代码 [GJB8114-R_1_8_1_d-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_8_1_e.html">在 'for' 循环中不应存在不可达代码 [GJB8114-R_1_8_1_e-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_8_1_f.html">在 'if' 或 'switch' 语句之后不应存在不可达代码 [GJB8114-R_1_8_1_f-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_8_1_g.html">在 while/for/do...while 循环内的 "if" 或 "switch" 语句后不应存在不可达代码 [GJB8114-R_1_8_1_g-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_8_3.html">禁止使用无效语句 [GJB8114-R_1_8_3-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_8_4.html">使用八进制数必须明确注释 [GJB8114-R_1_8_4-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_8_5.html">数字类型后缀必须使用大写字母 [GJB8114-R_1_8_5-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_9_1.html">for循环控制变量必须使用局部变量 [GJB8114-R_1_9_1-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_9_2.html">for循环控制变量必须使用整数型变量 [GJB8114-R_1_9_2-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_9_3.html">禁止在for循环体内部修改循环控制变量 [GJB8114-R_1_9_3-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_1_9_4.html">无限循环必须使用while(1)语句，禁止使用for(;;)等其它形式的语句 [GJB8114-R_1_9_4-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GJB8114-R_2_2_3.html">单参数构造函数必须使用explicit声明 [GJB8114-R_2_2_3-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GLOBAL.html">全局静态分析 [GLOBAL]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GLOBAL-AVOIDEXTERN.html">如果函数和对象不止在一个编译单元被引用，那么久不应该使用external方式定义 [GLOBAL-AVOIDEXTERN-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GLOBAL-COMPATDECLS.html">所有对象或函数的声明应该有匹配的类型 [GLOBAL-COMPATDECLS-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GLOBAL-CONDMUTEXVAR.html">在条件变量上的并行等待操作不应该使用多个mutex [GLOBAL-CONDMUTEXVAR-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GLOBAL-EXCSPECDECL.html">如果函数声明时指定了异常，那么所有相同函数的声明都应该使用相同的类型id声明 [GLOBAL-EXCSPECDECL-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GLOBAL-ONEDEFINLINE.html">在多个编译单元中使用的内联函数应该只能在一个文件中定义 [GLOBAL-ONEDEFINLINE-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GLOBAL-ONEDEFRULE.html">单个定义规则不应该被违反 [GLOBAL-ONEDEFRULE-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GLOBAL-ONEDEFTEMPL.html">在多个编译单元中使用的函数模板应该只能在一个文件中定义 [GLOBAL-ONEDEFTEMPL-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GLOBAL-ONEDEFTYPE.html">在多个编译单元中使用的类型应该只能在一个文件中定义 [GLOBAL-ONEDEFTYPE-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GLOBAL-ONEEXTERNDEF.html">External链接的标识符应该只能有一个外部定义 [GLOBAL-ONEEXTERNDEF-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GLOBAL-ONEFILEDECL.html">在多个翻译单元中使用的类型，对象或函数应该只能在一个文件中声明 [GLOBAL-ONEFILEDECL-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GLOBAL-ONEUSEVAR.html">项目不应包含只有一个用途的非 volatile POD变量 [GLOBAL-ONEUSEVAR-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GLOBAL-REUSEDQUALGLOBVAR.html">The identifier name of a non-member object with static storage duration shall not be reused within a namespace [GLOBAL-REUSEDQUALGLOBVAR-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GLOBAL-REUSEDQUALSTATFUN.html">The identifier name of a non-member static function shall not be reused within a namespace [GLOBAL-REUSEDQUALSTATFUN-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GLOBAL-TEMPLNOINST.html">所有的类模板，函数模板，类模板成员函数和类模板静态成员应该至少有一个被实例化 [GLOBAL-TEMPLNOINST-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GLOBAL-UNIQUETYPE.html">类，联合体，枚举型名称 (如果有其他修饰符，也包括) 应该是一个唯一的标识符 [GLOBAL-UNIQUETYPE-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GLOBAL-UNIQUETYPEDEF.html">typedef 的名称 (如果有其他修饰符，也包括) 应该是一个唯一的标识符 [GLOBAL-UNIQUETYPEDEF-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GLOBAL-UNUSEDFUNC.html">每个定义的具有外部连接的函数应该被至少使用一次 [GLOBAL-UNUSEDFUNC-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GLOBAL-UNUSEDTYPE.html">项目不应包含未使用的类型声明 [GLOBAL-UNUSEDTYPE-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GLOBAL-UNUSEDVIRTPARAM.html">在虚函数和覆盖它的所有函数中参数集合中应该没有未使用的参数(命名的或未命名的) [GLOBAL-UNUSEDVIRTPARAM-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/GLOBAL-VIRTBASECLASS.html">基类只有在菱形继承层级中使用时才会被声明为虚类 [GLOBAL-VIRTBASECLASS-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP.html">高完整性c++ [HICPP]</a></b>
<ul>
<li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-10_1_1.html">HIC++ 10.1.1 确保访问基类子对象不需要显式消除歧义 [HICPP-10_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-10_1_1-a.html">对于多重继承使用虚公共基类 [HICPP-10_1_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-10_2_1.html">HIC++ 10.2.1 当重写虚拟函数时，使用覆盖特殊标识符 [HICPP-10_2_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-10_2_1-a.html">使用override关键字标识函数覆盖 [HICPP-10_2_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-10_3_1.html">HIC++ 10.3.1 确保派生类最多只有一个基类，而基类不是接口类 [HICPP-10_3_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-10_3_1-a.html">要小心使用不是抽象接口的类的多重继承 [HICPP-10_3_1-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-11_1_1.html">HIC++ 11.1.1 声明所有数据成员为私有状态 [HICPP-11_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-11_1_1-a.html">避免 "public" 数据成员 [HICPP-11_1_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-11_1_1-b.html">避免 'protected' 数据成员 [HICPP-11_1_1-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-11_2_1.html">HIC++ 11.2.1 不要使用朋友声明 [HICPP-11_2_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-11_2_1-a.html">避免使用友元(friend)机制 [HICPP-11_2_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-12_1_1.html">HIC++ 12.1.1 不声明隐式用户定义的转换 [HICPP-12_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-12_1_1-a.html">允许转换的构造函数应该是使用 explicit 修饰 [HICPP-12_1_1-a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-12_1_1-b.html">自定义类型转换函数需要使用标识符标识 [HICPP-12_1_1-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-12_2_1.html">HIC++ 12.2.1 声明虚拟、私有或受保护的类型的析构函数作为基类 [HICPP-12_2_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-12_2_1-a.html">在基类中将析构函数设置为虚拟的 [HICPP-12_2_1-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-12_3_1.html">HIC++ 12.3.1 正确地为操作符 new 和 delete 声明重载 [HICPP-12_3_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-12_3_1-a.html">如果写了 new 操作符应该对应写 delete 操作符 [HICPP-12_3_1-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-12_3_1-b.html">如果写了 new[] 操作符应该对应写 delete[] 操作符 [HICPP-12_3_1-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-12_4_1.html">HIC++ 12.4.1 不要使用对象的动态类型，除非对象被完全构造为 [HICPP-12_4_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-12_4_1-a.html">对象的动态类型不能够从它的构造函数和析构函数的函数体中使用 [HICPP-12_4_1-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-12_4_1-b.html">不要从类的任何构造函数中调用类的虚函数 [HICPP-12_4_1-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-12_4_1-c.html">不要从类的析构函数中调用类的虚函数 [HICPP-12_4_1-c-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-12_4_2.html">HIC++ 12.4.2 确保构造函数显式初始化所有基类和非静态数据成员 [HICPP-12_4_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-12_4_2-a.html">所有成员变量都应该在构造函数中初始化 [HICPP-12_4_2-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-12_4_3.html">HIC++ 12.4.3 在同一个非静态成员的构造函数中，不要同时指定 NSDMI 和成员初始化器 [HICPP-12_4_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-12_4_3-a.html">有默认值的非静态成员不能在构造函数初始化列表中使用 [HICPP-12_4_3-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-12_4_4.html">HIC++ 12.4.4 在初始化列表中按照的顺序写入成员 [HICPP-12_4_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-12_4_4-a.html">在初始化列表中按声明成员的顺序列出成员 [HICPP-12_4_4-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-12_4_5.html">HIC++ 12.4.5 使用委托构造函数来减少代码重复 [HICPP-12_4_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-12_4_5-a.html">使用授权的构造器减少代码重复 [HICPP-12_4_5-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-12_5_1.html">HIC++ 12.5.1 明确定义 =default 或  =delete具体类的隐式特殊成员函数 [HICPP-12_5_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-12_5_1-a.html">显式定义 =default or =delete 由编译器隐式提供的具体类的特殊成员函数 [HICPP-12_5_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-12_5_2.html">HIC++ 12.5.2 如果行为是等效的，定义特殊成员 =default [HICPP-12_5_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-12_5_2-a.html">如果行为等效，则定义特殊成员=default [HICPP-12_5_2-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-12_5_3.html">HIC++ 12.5.3 确保用户定义的 move/copy 构造函数仅移动 /copie 基对象和成员对象 [HICPP-12_5_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-12_5_3-a.html">拷贝构造函数应仅对其基类型及该类型的非静态成员进行初始化 [HICPP-12_5_3-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-12_5_4.html">HIC++ 12.5.4 除 move 构造函数和 move 赋值运算符外，声明不存在 [HICPP-12_5_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-12_5_4-a.html">所有用户提供的移动构造函数和移动分配操作符都不应异常退出 [HICPP-12_5_4-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-12_5_7.html">HIC++ 12.5.7 使用 ref 限定符 &amp;声明赋值运算符 [HICPP-12_5_7]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-12_5_7-a.html">使用引用修饰符&amp;(ref-qualifier)来声明赋值运算符 [HICPP-12_5_7-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-12_5_8.html">HIC++ 12.5.8 对受保护的抽象类进行复制赋值操作，或定义其 =delete [HICPP-12_5_8]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-12_5_8-a.html">在抽象类中拷贝赋值运算符应该被声明为 protected 或 private [HICPP-12_5_8-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-13_1_1.html">HIC++ 13.1.1 确保从调用函数的地方可以看到函数的所有重载 [HICPP-13_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-13_1_1-a.html">使用命名空间(using)声明来重新定义重载的函数 [HICPP-13_1_1-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-13_1_2.html">HIC++ 13.1.2 如果一组可调用函数的成员包含一个通用引用参数，请确保其中一个出现在所有其他成员的相同位置 [HICPP-13_1_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-13_1_2-a.html">避免在转发引用上使用重载 [HICPP-13_1_2-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-13_2_1.html">HIC++ 13.2.1 不要重载具有特殊语义的运算符 [HICPP-13_2_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-13_2_1-a.html">避免重载逻辑操作符AND, OR (&amp;&amp;, ||) [HICPP-13_2_1-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-13_2_1-b.html">避免重载逗号运算符 "," [HICPP-13_2_1-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-13_2_2.html">HIC++ 13.2.2 确保重载二进制操作符的返回类型与内置对应的匹配 [HICPP-13_2_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-13_2_2-a.html">关系运算符应返回布尔值 [HICPP-13_2_2-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-13_2_2-b.html">二进制算术运算符和位运算符应返回一个 'prvalue' [HICPP-13_2_2-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-13_2_3.html">HIC++ 13.2.3 将二进制算术和位运算符声明为非成员 [HICPP-13_2_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-13_2_3-a.html">将二进制算术和位运算符声明为非成员 [HICPP-13_2_3-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-13_2_4.html">HIC++ 13.2.4 当重载下标运算符( operator[] )时，实现 const 和非 const 版本 [HICPP-13_2_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-13_2_4-a.html">重载 [] 运算符函数时，必须同时实现const和非const版本 [HICPP-13_2_4-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-13_2_5.html">HIC++ 13.2.5 实现最小操作符集，并使用它们实现所有其他相关操作符 [HICPP-13_2_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-13_2_5-a.html">二进制过载操作符应该用其对应的复合赋值运算符实现 [HICPP-13_2_5-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-14_1_1.html">HIC++ 14.1.1 使用可变参数模板，而不是省略号 [HICPP-14_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-14_1_1-a.html">避免使用有可变数量参数的函数 [HICPP-14_1_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-14_2_1.html">HIC++ 14.2.1 将模板专门化声明在与其专门化的主模板相同的文件中。 [HICPP-14_2_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-14_2_1-a.html">模板所有的部分和显式专门化都应在与其主模板声明相同的文件中声明 [HICPP-14_2_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-14_2_2.html">HIC++ 14.2.2 不要显式地专门化用其他模板重载的函数模板 [HICPP-14_2_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-14_2_2-a.html">重载函数模板不应该明确专用 [HICPP-14_2_2-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-14_2_3.html">HIC++ 14.2.3 声明外部显式实例化模板 [HICPP-14_2_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-14_2_3-a.html">声明 'extern' 一个显式实例化的模板 [HICPP-14_2_3-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-15_1_1.html">HIC++ 15.1.1 仅对异常使用 std::exception 的实例 [HICPP-15_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-15_1_1-a.html">只能使用 std::exception 异常 [HICPP-15_1_1-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-15_1_1-b.html">始终抛出创建的 std::exception 对象 [HICPP-15_1_1-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-15_2_1.html">HIC++ 15.2.1 不要从析构函数中抛出异常 [HICPP-15_2_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-15_2_1-a.html">不要从析构器中抛出 [HICPP-15_2_1-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-15_3_1.html">HIC++ 15.3.1 不要从构造函数/析构函数 try 块的 catch 处理程序访问非静态成员 [HICPP-15_3_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-15_3_1-a.html">以 function-try-block 实现的类构造函数或析构函数的处理程序不应引用该类或其基类的非静态成员 [HICPP-15_3_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-15_3_2.html">HIC++ 15.3.2 确保程序不会导致调用 std::terminate [HICPP-15_3_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-15_3_2-a.html">始终捕获异常 [HICPP-15_3_2-a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-15_3_2-b.html">至少应该有一个异常处理程序来捕获所有其他未处理的异常 [HICPP-15_3_2-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-15_3_2-c.html">避免从声明不抛出异常的函数中抛出异常 [HICPP-15_3_2-c-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-16_1_1.html">HIC++ 16.1.1 只使用预处理器来实现包含保护，包括包含保护的头文件 [HICPP-16_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-16_1_1-a.html">避免使用宏 [HICPP-16_1_1-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-16_1_1-b.html">#ifndef 和 #endif 预处理指令将仅用于防止重复地包含相同的头文件 [HICPP-16_1_1-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-16_1_1-c.html">只有下列预处理器指令才能被使用: #ifndef, #define, #endif, #include [HICPP-16_1_1-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-16_1_1-d.html">使用多个包含保护 [HICPP-16_1_1-d-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-16_1_2.html">HIC++ 16.1.2 在 #include 命令中提供的文件名中不包含路径说明符 [HICPP-16_1_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-16_1_2-a.html">不允许在 #include 语句中带有相对路径名 [HICPP-16_1_2-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-16_1_2-b.html">字符 \ 不得出现在头文件的名称中 [HICPP-16_1_2-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-16_1_3.html">HIC++ 16.1.3 将 #include 指令中的文件名与文件系统上的匹配 [HICPP-16_1_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-16_1_3-a.html">将 #include 指令中的文件名与文件系统上的文件名匹配 [HICPP-16_1_3-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-16_1_4.html">HIC++ 16.1.4 对系统和标准库标头使用 &lt;&gt; 的方括号。对所有其他标题使用引号 [HICPP-16_1_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-16_1_4-a.html">对于系统和标准库头文件，使用&lt;&gt;方括号。对所有其他头文件使用引号 [HICPP-16_1_4-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-16_1_5.html">HIC++ 16.1.5 直接包含编译所需的最小头数 [HICPP-16_1_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-16_1_5-a.html">避免重复的 #include 指令 [HICPP-16_1_5-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-17_1_1.html">HIC++ 17.1.1 不要使用 std::vector&lt; bool&gt; [HICPP-17_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-17_1_1-a.html">避免使用 vector&lt;bool&gt; [HICPP-17_1_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-17_2_1.html">HIC++ 17.2.1 包装使用 C 标准库 [HICPP-17_2_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-17_2_1-a.html">包装使用的 C 标准库 [HICPP-17_2_1-a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-17_2_1-b.html">不得使用错误指示 'errno' [HICPP-17_2_1-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-17_3_1.html">HIC++ 17.3.1 不要在 const 或 const &amp; 声明的对象上使用 std::move 移动 [HICPP-17_3_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-17_3_1-a.html">不要对常量或常量类型对象使用 std::move [HICPP-17_3_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-17_3_2.html">HIC++ 17.3.2 使用 std::forward 到  forward 的通用引用 [HICPP-17_3_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-17_3_2-a.html">'std::forward' 函数应用来转发通用引用 [HICPP-17_3_2-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-17_3_3.html">HIC++ 17.3.3 以后不要将参数用于 std::forward [HICPP-17_3_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-17_3_3-a.html">后续不要使用传递给参数 std::forward [HICPP-17_3_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-17_3_4.html">HIC++ 17.3.4 不要创建数组类型的智能指针 [HICPP-17_3_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-17_3_4-a.html">不要创建数组类型的智能指针 [HICPP-17_3_4-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-17_3_5.html">HIC++ 17.3.5 不要创建 std::array 的 rvalue 引用 [HICPP-17_3_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-17_3_5-a.html">不要创建引用 std::array 的右值 [HICPP-17_3_5-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-17_3_5-b.html">不要创建std :: array的右值引用 [HICPP-17_3_5-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-17_4_1.html">HIC++ 17.4.1 当结果立即转换为 const 迭代器时，使用 const 容器调用 [HICPP-17_4_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-17_4_1-a.html">当结果转换为const迭代器时，使用const容器调用 [HICPP-17_4_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-17_4_2.html">HIC++ 17.4.2 使用 API 在适当的位置调用构造对象 [HICPP-17_4_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-17_4_2-a.html">建议使用 'std::make_shared' 而不是直接使用 new [HICPP-17_4_2-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-17_5_1.html">HIC++ 17.5.1 不要忽略 std::remove, std::remove if 或 std::unique 的结果 [HICPP-17_5_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-17_5_1-a.html">如果进行删除操作，采取类似 remove 的算法 [HICPP-17_5_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-18_1_1.html">HIC++ 18.1.1 不要使用特定平台的多线程工具 [HICPP-18_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-18_1_1-a.html">不使用特定平台的多线程工具 [HICPP-18_1_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-18_2_1.html">HIC++ 18.2.1 使用高完整性 ::thread 替代 std::thread [HICPP-18_2_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-18_2_1-a.html">使用 high_integrity::thread 而不是 std::thread [HICPP-18_2_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-18_2_2.html">HIC++ 18.2.2 使用单个锁同步访问线程间共享的数据 [HICPP-18_2_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-18_2_2-a.html">不要使用具有不同的锁集的全局变量 [HICPP-18_2_2-a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-18_2_2-b.html">使 const 成员函数是线程安全的 [HICPP-18_2_2-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-18_2_3.html">HIC++ 18.2.3 不要在线程间共享易变数据 [HICPP-18_2_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-18_2_3-a.html">不要在线程间共享不稳定的数据 [HICPP-18_2_3-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-18_2_4.html">HIC++ 18.2.4 使用 std::call_once 而不是双重检查锁定模式 [HICPP-18_2_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-18_2_4-a.html">使用std::call_once，而不是双重检查锁定模式 [HICPP-18_2_4-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-18_3_1.html">HIC++ 18.3.1 在锁的范围内，确保没有静态路径导致同一个互斥锁的锁 [HICPP-18_3_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-18_3_1-a.html">避免双重锁定 [HICPP-18_3_1-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-18_3_2.html">HIC++ 18.3.2 确保项目中的锁嵌套顺序形成  DAG [HICPP-18_3_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-18_3_2-a.html">不要以不同的顺序获取锁 [HICPP-18_3_2-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-18_3_3.html">HIC++ 18.3.3 不要使用 std::recursive 互斥锁 [HICPP-18_3_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-18_3_3-a.html">不要使用std::recursive_mutex [HICPP-18_3_3-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-18_3_4.html">HIC++ 18.3.4 当 std::lock 防卫无法使用时，只能使用 std::unique 的锁 [HICPP-18_3_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-18_3_4-a.html">当 std::lock 守护不能使用时，只使用std::unique lock [HICPP-18_3_4-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-18_3_5.html">HIC++ 18.3.5 不要直接访问 std::mutex 对象的成员 [HICPP-18_3_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-18_3_5-a.html">不要直接访问std::mutex [HICPP-18_3_5-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-18_3_6.html">HIC++ 18.3.6 不要使用轻松原子 [HICPP-18_3_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-18_3_6-a.html">不要使用松弛原子 [HICPP-18_3_6-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-18_4_1.html">HIC++ 18.4.1 不要在 std::mutex 上使用 std::condition 变量 [HICPP-18_4_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-18_4_1-a.html">不要对std::mutex使用 std::condition_variable_any [HICPP-18_4_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-1_2_1.html">HIC++ 1.2.1 确保所有语句都是可访问的 [HICPP-1_2_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-1_2_1-a.html">在 "else" 语句块中不应存在执行不到的代码 [HICPP-1_2_1-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-1_2_1-b.html">在 'return', 'break', 'continue', 和 'goto' 语句之后不应存在执行不到的代码 [HICPP-1_2_1-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-1_2_1-c.html">在 "if/else/while/for" 语句块中不应存在执行不到的代码 [HICPP-1_2_1-c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-1_2_1-d.html">在 switch 语句中不应存在执行不到的代码 [HICPP-1_2_1-d-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-1_2_1-e.html">在 'for' 循环中不应存在执行不到的代码 [HICPP-1_2_1-e-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-1_2_1-f.html">在 'if' 或 'switch' 语句后不应存在不可访问的代码 [HICPP-1_2_1-f-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-1_2_1-g.html">在 while/for/do...while 循环内的 "if" 或 "switch" 语句后不应存在执行不到的代码 [HICPP-1_2_1-g-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-1_2_1-h.html">避免无法到达的方法 [HICPP-1_2_1-h-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-1_2_1-i.html">避免始终计算为相同值的条件 [HICPP-1_2_1-i-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-1_2_1-j.html">避免具有无法到达分支的开关语句 [HICPP-1_2_1-j-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-1_2_2.html">HIC++ 1.2.2 确保没有表达式或子表达式是冗余的 [HICPP-1_2_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-1_2_2-a.html">所有非 null 语句应该至少有一个执行或者导致控制流变化的附加作用 [HICPP-1_2_2-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-1_3_1.html">HIC++ 1.3.1  对于布尔类型的变量，不要使用递增操作符(++) [HICPP-1_3_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-1_3_1-a.html">不要在 'bool' 类型的操作数上使用递增操作符（++） [HICPP-1_3_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-1_3_2.html">HIC++ 1.3.2 不要使用 register 关键字 [HICPP-1_3_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-1_3_2-a.html">不应使用'register'存储类说明符 [HICPP-1_3_2-a-5]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-1_3_3.html">HIC++ 1.3.3 不要使用 C 标准库 .h 标题 [HICPP-1_3_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-1_3_3-a.html">不能使用C语言库 [HICPP-1_3_3-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-1_3_4.html">HIC++ 1.3.4 不使用已弃用的 STL 库特性 [HICPP-1_3_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-1_3_4-a.html">不要使用已弃用的STL库功能 [HICPP-1_3_4-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-1_3_5.html">HIC++ 1.3.5 不使用抛出异常规范 [HICPP-1_3_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-1_3_5-a.html">不使用throw异常规范 [HICPP-1_3_5-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-2_1_1.html">HIC++ 2.1.1 不要在源文件中使用标签字符 [HICPP-2_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-2_1_1-a.html">禁止使用未用 ASCII 空格的 Tab 字符 [HICPP-2_1_1-a-5]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-2_2_1.html">HIC++ 2.2.1 不要使用有向图或三向图 [HICPP-2_2_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-2_2_1-a.html">不要使用下列合体字母 &lt;%, %&gt;, &lt;:, :&gt;, %:, %:%: [HICPP-2_2_1-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-2_2_1-b.html">禁止使用三字母词 [HICPP-2_2_1-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-2_3_1.html">HIC++ 2.3.1 不要使用C注释分隔符 /* ... */ [HICPP-2_3_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-2_3_1-a.html">推荐使用 C++ 风格的注释 [HICPP-2_3_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-2_3_2.html">HIC++ 2.3.2 不要注释掉代码 [HICPP-2_3_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-2_3_2-a.html">不要使用注释来删除部分代码 [HICPP-2_3_2-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-2_4_1.html">HIC++ 2.4.1 确保每个标识符不同于任何其他可见标识符 [HICPP-2_4_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-2_4_1-a.html">不同的标识符应该是书写明确的 [HICPP-2_4_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-2_5_1.html">HIC++ 2.5.1 不连接具有不同编码前缀的字符串 [HICPP-2_5_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-2_5_1-a.html">不应连接具有不同编码前缀的字符串文字 [HICPP-2_5_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-2_5_2.html">HIC++ 2.5.2 不要使用八进制常量 （除了 0） [HICPP-2_5_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-2_5_2-a.html">不应该使用八进制常数（除零外） [HICPP-2_5_2-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-2_5_3.html">HIC++ 2.5.3 对空指针常量使用 nullptr [HICPP-2_5_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-2_5_3-a.html">使用nullptr代替null和0 [HICPP-2_5_3-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-3_1_1.html">HIC++ 3.1.1 不要隐藏声明 [HICPP-3_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-3_1_1-a.html">在局部或者函数原型体范围内声明的标识符不应该隐藏一个在全局或者命名空间范围内声明的标识符 [HICPP-3_1_1-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-3_1_1-b.html">在内层的局部范围内声明的标识符不应该隐藏在外层的局部范围内声明的标识符 [HICPP-3_1_1-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-3_1_1-c.html">在一个局部范围内声明的标识符不应该隐藏在一个类作用域中声明的标识符 [HICPP-3_1_1-c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-3_1_1-d.html">在类的作用域中声明的标识符不应该隐藏在全局或命名空间范围内声明的标识符 [HICPP-3_1_1-d-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-3_1_1-e.html">在一个内部类作用域中声明的标识符不应该隐藏在外部类作用域中声明的标识符 [HICPP-3_1_1-e-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-3_2_1.html">HIC++ 3.2.1 不要在块范围内声明函数 [HICPP-3_2_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-3_2_1-a.html">在文件的范围内声明函数 [HICPP-3_2_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-3_3_1.html">HIC++ 3.3.1 不要使用静态存储时间的变量 [HICPP-3_3_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-3_3_1-a.html">不要使用具有静态存储期的函数 [HICPP-3_3_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-3_4_1.html">HIC++ 3.4.1 不得将引用或指针返回到函数中定义的自动变量 [HICPP-3_4_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-3_4_1-a.html">不得从函数中返回具有自动存储的对象的地址 [HICPP-3_4_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-3_4_2.html">HIC++ 3.4.2 不要将变量的地址分配给寿命更长的指针 [HICPP-3_4_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-3_4_2-a.html">自动存储对象的地址不应分配给在第一个对象不再存在后可能持久存在的另一个对象 [HICPP-3_4_2-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-3_4_3.html">HIC++ 3.4.3 资源使用 RAII [HICPP-3_4_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-3_4_3-a.html">选择使用智能指针而不是原始局部指针 [HICPP-3_4_3-a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-3_4_3-b.html">不要直接在互斥锁上调用lock() [HICPP-3_4_3-b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-3_4_3-c.html">使用 RAII 防止资源泄漏 [HICPP-3_4_3-c-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-3_5_1.html">HIC++ 3.5.1 不得对值或对象的内部做任何假设 [HICPP-3_5_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-3_5_1-a.html">禁止使用联合体 [HICPP-3_5_1-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-3_5_1-b.html">typedefs 应该被用于替代基本类型 [HICPP-3_5_1-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-3_5_1-c.html">只有指向数组或数组元素地址的指针才能进行指针运算 [HICPP-3_5_1-c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-3_5_1-d.html">&gt;, &gt;=, &lt;, &lt;= 不应用于指针类型，除非它们指向相同的数组 [HICPP-3_5_1-d-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-4_1_1.html">HIC++ 4.1.1 确保函数参数不进行 array-to-pointer 转换 [HICPP-4_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-4_1_1-a.html">作为函数实参传递的数组类型标识符不得退化为一个指针 [HICPP-4_1_1-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-4_1_1-b.html">不要将具有数组类型的表达式传递给一个具有指针或者数组类型参数的函数 [HICPP-4_1_1-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-4_2_1.html">HIC++ 4.2.1 确保将 U 后缀应用于需要无符号整型表达式的上下文中使用的文字 [HICPP-4_2_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-4_2_1-a.html">将U后缀应用到需要无符号整型表达式的上下文中 [HICPP-4_2_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-4_2_2.html">HIC++ 4.2.2 确保在整数表达式中不会出现数据丢失 [HICPP-4_2_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-4_2_2-a.html">一个移位操作符的右操作数应该位于 0 到 1 之间，小于左操作数底层类型的位宽 [HICPP-4_2_2-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-4_2_2-b.html">避免使用显式类型转换(强制类型转换) [HICPP-4_2_2-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-4_2_2-c.html">'+'， '-'， '*' 运算符常量表达式中的整数溢出或下溢 [HICPP-4_2_2-c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-4_2_2-d.html">'&lt;&lt;' 运算符常量表达式中的整数溢出或下溢 [HICPP-4_2_2-d-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-4_2_2-e.html">避免整数溢出 [HICPP-4_2_2-e-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-4_2_2-f.html">避免不正确的位移操作 [HICPP-4_2_2-f-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-4_3_1.html">HIC++ 4.3.1 不要将更宽的浮点类型的表达式转换为更窄的浮点类型 [HICPP-4_3_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-4_3_1-a.html">避免宽字段到窄字段浮点型数据的隐式转换 [HICPP-4_3_1-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-4_3_1-b.html">避免将浮点数从较宽的浮点类型隐式转换为较窄的浮点类型 [HICPP-4_3_1-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-4_4_1.html">HIC++ 4.4.1 除非使用标准库函数，否则不要将浮动值转换为整数类型 [HICPP-4_4_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-4_4_1-a.html">避免浮点型到整型的隐式转换 [HICPP-4_4_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_1_1.html">HIC++ 5.1.1 在代码中使用符号名而不是文字值 [HICPP-5_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_1_1-a.html">避免使用幻数 [HICPP-5_1_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_1_2.html">HIC++ 5.1.2 不依赖于表达式中的求值序列 [HICPP-5_1_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_1_2-a.html">表达式的值应该在任何标准允许的赋值顺序下是一样的 [HICPP-5_1_2-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_1_2-b.html">不要编写依赖于函数参数求值顺序的代码 [HICPP-5_1_2-b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_1_2-c.html">不要编写依赖于函数标志符和函数参数的求值顺序的代码 [HICPP-5_1_2-c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_1_2-d.html">涉及一个函数调用时，不要编写依赖表达式求值顺序的代码 [HICPP-5_1_2-d-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_1_2-e.html">在序列点之间，对象的存储值最多只能通过表达式的计算来修改一次 [HICPP-5_1_2-e-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_1_2-f.html">不要在两个相邻的序列点之间使用多个 volatile [HICPP-5_1_2-f-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_1_2-g.html">不要编写依赖于函数调用求值顺序的代码 [HICPP-5_1_2-g-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_1_2-h.html">禁止在同一个表达式中混合使用递加符 (++) 和递减符 (--) 与其他运算符 [HICPP-5_1_2-h-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_1_2-i.html">不应该使用逗号运算符 [HICPP-5_1_2-i-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_1_2-j.html">不得使用一个内置赋值运算符的结果 [HICPP-5_1_2-j-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_1_3.html">HIC++ 5.1.3 在表达式中使用括号来指定表达式的意图 [HICPP-5_1_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_1_3-a.html">除非表达式中的所有运算符都相同，否则使用圆括号 [HICPP-5_1_3-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_1_3-b.html">逻辑运算符 &amp;&amp; 或者 || 的操作数应该是基本表达式 [HICPP-5_1_3-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_1_4.html">HIC++ 5.1.4 不要在 lambda 中隐式捕获变量 [HICPP-5_1_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_1_4-a.html">不要在lambda中隐式地捕获变量 [HICPP-5_1_4-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_1_5.html">HIC++ 5.1.5 在每个 lambda 表达式中包含(可能为空)参数列表 [HICPP-5_1_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_1_5-a.html">在每个 lambda 表达式中包含一个参数列表 [HICPP-5_1_5-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_1_6.html">HIC++ 5.1.6 不要将副作用编码到右边的操作数中： &amp;&amp;, ||, sizeof, typeid， 或传递给条件变量的函数 ::wait [HICPP-5_1_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_1_6-a.html">sizeof运算符的操作数不应包含任何有副作用的表达式 [HICPP-5_1_6-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_1_6-b.html">不应在sizeof运算符的操作数中访问由volatile左值指定的对象 [HICPP-5_1_6-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_1_6-c.html">会导致副作用的函数调用不应该用作 sizeof 运算符的操作数 [HICPP-5_1_6-c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_1_6-d.html">逻辑&amp;&amp;或||运算符的右操作数不得含有副作用 [HICPP-5_1_6-d-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_1_6-e.html">typeid 操作符的操作数不能包含任何有副作用的表达式 [HICPP-5_1_6-e-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_1_6-f.html">'typeid' 操作符的操作数不应包含导致副作用的函数调用 [HICPP-5_1_6-f-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_2_1.html">HIC++ 5.2.1 确保指针或数组访问在有效对象的范围内 [HICPP-5_2_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_2_1-a.html">避免访问数组越界 [HICPP-5_2_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_2_1-b.html">避免访问数组和指针越界 [HICPP-5_2_1-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_2_1-c.html">避免空指针引用 [HICPP-5_2_1-c-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_2_2.html">HIC++ 5.2.2 确保函数本身不直接或间接调用 [HICPP-5_2_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_2_2-a.html">函数不应该直接或者间接地调用自己 [HICPP-5_2_2-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_2_2-b.html">不要使用递归 [HICPP-5_2_2-b-5]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_3_1.html">HIC++ 5.3.1 不对无符号类型的操作数应用一元减号 [HICPP-5_3_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_3_1-a.html">一元减法运算符不得适用于其原始类型是无符号型的表达式 [HICPP-5_3_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_3_2.html">HIC++ 5.3.2 使用 new 分配内存，使用 delete 释放内存 [HICPP-5_3_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_3_2-a.html">不要使用 calloc, malloc, realloc 和 free 函数 [HICPP-5_3_2-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_3_3.html">HIC++ 5.3.3 确保 delete 格式与 new 格式匹配，new 用于分配内存 [HICPP-5_3_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_3_3-a.html">释放非数组内存时 delete 不能使用括号([]) [HICPP-5_3_3-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_3_3-b.html">释放数组内存时 delete 必须使用空括号([]) [HICPP-5_3_3-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_3_3-c.html">正确地动态释放分配的资源 [HICPP-5_3_3-c-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_4_1.html">HIC++ 5.4.1 仅使用转换表单: static cast (excl. void*), dynamic cast 或explicit constructor call [HICPP-5_4_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_4_1-a.html">建议使用 C++ 风格的强制类型转换 [HICPP-5_4_1-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_4_1-b.html">避免使用强制类型转换符 reinterpret_cast [HICPP-5_4_1-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_4_1-c.html">强制转换不得从指针或引用类型中删除任何“const”或“volatile”限定条件 [HICPP-5_4_1-c-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_4_2.html">HIC++ 5.4.2 不要将表达式转换为枚举类型 [HICPP-5_4_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_4_2-a.html">不要将表达式转换为枚举类型 [HICPP-5_4_2-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_4_3.html">HIC++ 5.4.3 不要将基类转换为派生类 [HICPP-5_4_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_4_3-a.html">向下的强制转换(基类到衍生类的转换)是不允许的 [HICPP-5_4_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_5_1.html">HIC++ 5.5.1 确保除法操作符或余数操作符的右边操作数是非零的 [HICPP-5_5_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_5_1-a.html">避免除零错误 [HICPP-5_5_1-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_6_1.html">HIC++ 5.6.1 不要使用带符号操作数的位操作符 [HICPP-5_6_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_6_1-a.html">位运算符应只适用于无符号的基本类型操作数 [HICPP-5_6_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_7_1.html">HIC++ 5.7.1 不要期望编写浮点运算产生精确结果的代码 [HICPP-5_7_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_7_1-a.html">禁止对浮点数类型的表达式做相等或不相等的比较 [HICPP-5_7_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_7_2.html">HIC++ 5.7.2 确保指向虚拟函数成员的指针仅与 nullptr 进行比较(==) [HICPP-5_7_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_7_2-a.html">指向成员虚函数的指针只应该被测试是否与空指针常量相等 [HICPP-5_7_2-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_8_1.html">HIC++ 5.8.1 不使用条件运算符 (?:)作为子表达式 [HICPP-5_8_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-5_8_1-a.html">三元运算符的条件不能是三元运算符表达式 [HICPP-5_8_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-6_1_1.html">HIC++ 6.1.1 在复合语句中包含选择语句或迭代语句的主体 [HICPP-6_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-6_1_1-a.html">'switch', 'while', 'do...while' 或 'for' 语句的主体应该是复合语句 [HICPP-6_1_1-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-6_1_1-b.html">'if' 和 'else' 语句后应跟一个复合句 [HICPP-6_1_1-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-6_1_2.html">HIC++ 6.1.2 通过多路选择语句明确覆盖所有路径 [HICPP-6_1_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-6_1_2-a.html">所有 'if...else-if' 结构应使用一个 'else' 子句终止 [HICPP-6_1_2-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-6_1_2-b.html">switch 语句中最后必须为 default 子句 [HICPP-6_1_2-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-6_1_3.html">HIC++ 6.1.3 确保非 null 的 case 语句块不会进入下一个标签 [HICPP-6_1_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-6_1_3-a.html">非条件 throw 或 break 语句应终止每个非空的 switch 语句 [HICPP-6_1_3-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-6_1_4.html">HIC++ 6.1.4 确保 switch 语句至少有两个 case 标签，区别于默认标签 [HICPP-6_1_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-6_1_4-a.html">每个 switch 语句至少有两个 case 分支和一个潜在的 default 分支 [HICPP-6_1_4-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-6_1_4-b.html">switch 表达式不应该出现一个实际为布尔的值 [HICPP-6_1_4-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-6_2_1.html">HIC++ 6.2.1 实现一个循环，该循环只使用元素值作为基于范围的循环 [HICPP-6_2_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-6_2_1-a.html">将一个只使用元素值的循环实现为基于范围的循环 [HICPP-6_2_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-6_2_2.html">HIC++ 6.2.2 确保一个循环有一个循环计数器，一个可选的控制变量，并且不简并 [HICPP-6_2_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-6_2_2-a.html">for循环中只能有一个循环计数器，并且不能再循环体中修改 [HICPP-6_2_2-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-6_2_3.html">HIC++ 6.2.3 循环中不超过一次的修改控制或计数器变量 [HICPP-6_2_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-6_2_3-a.html">禁止在循环体中修改循环计数器 [HICPP-6_2_3-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-6_2_4.html">HIC++ 6.2.4 仅在 for 表达式中修改 for 循环计数器 [HICPP-6_2_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-6_2_4-a.html">for循环的第三部分应该是格式良好的 [HICPP-6_2_4-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-6_3_1.html">HIC++ 6.3.1 确保跳转语句或切换条件的标签稍后出现在相同或封闭的块中 [HICPP-6_3_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-6_3_1-a.html">只有当最紧密封闭的复合语句是 switch 语句主体的时才能使用 switch 标签 [HICPP-6_3_1-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-6_3_1-b.html">goto 语句应该跳转到同一个函数体中位于 goto 语句后面声明的标签 [HICPP-6_3_1-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-6_3_1-c.html">任何由 goto 语句引用的标签应该声明在同一个模块中，或者在一个包含 goto 语句的模块中 [HICPP-6_3_1-c-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-6_3_2.html">HIC++ 6.3.2 确保非空返回类型函数的执行以带有返回值的返回语句结束 [HICPP-6_3_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-6_3_2-a.html">非 void 返回类型的函数的所有退出路径应该有一个明确的包含表达式的返回语句 [HICPP-6_3_2-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-6_4_1.html">HIC++ 6.4.1 尽可能推迟变量定义 [HICPP-6_4_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-6_4_1-a.html">尽可能地声明局部化的变量 [HICPP-6_4_1-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-6_4_1-b.html">尽可能推迟变量定义 [HICPP-6_4_1-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_1_1.html">HIC++ 7.1.1 在单独的声明中在单独一行上声明每个标识符 [HICPP-7_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_1_1-a.html">不允许在同一行声明多个变量 [HICPP-7_1_1-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_1_1-b.html">每个变量都要在单独的声明语句中被声明 [HICPP-7_1_1-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_1_10.html">HIC++ 7.1.10 对包含编译时常量的断言使用静态断言 [HICPP-7_1_10]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_1_10-a.html">对于涉及编译时常量的断言使用static_assert [HICPP-7_1_10-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_1_2.html">HIC++ 7.1.2 尽可能使用const [HICPP-7_1_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_1_2-a.html">尽可能将参数或局部变量声明为const [HICPP-7_1_2-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_1_3.html">HIC++ 7.1.3 在声明中，不要在非类型说明符前放置类型说明符 [HICPP-7_1_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_1_3-a.html">在声明中不要将类型说明符放在非类型说明符之前 [HICPP-7_1_3-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_1_4.html">HIC++ 7.1.4 将 CV-qualifiers 放置在类型的右侧 [HICPP-7_1_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_1_4-a.html">将CV限定符放在它们所应用的类型的右边 [HICPP-7_1_4-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_1_5.html">HIC++ 7.1.5 不要内联大型函数 [HICPP-7_1_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_1_5-a.html">不要内联大型函数 [HICPP-7_1_5-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_1_6.html">HIC++ 7.1.6 使用 class 类型或 typedef 来抽象标量和标准整数类型 [HICPP-7_1_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_1_6-a.html">普通字符(plain char)类型只能用于存储和使用字符值 [HICPP-7_1_6-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_1_6-b.html">使用类类型或typedef来定义标量或标准整数类型 [HICPP-7_1_6-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_1_6-c.html">使用class类型或typedef来抽象基础类型 [HICPP-7_1_6-c-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_1_7.html">HIC++ 7.1.7 优先使用尾部返回类型来使用 typename 类型消除歧义 [HICPP-7_1_7]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_1_7-a.html">如果返回类型前面带有 'typename' 关键字，使用尾随返回类型语法 [HICPP-7_1_7-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_1_8.html">HIC++ 7.1.8 在声明变量时使用 auto id = expr，使其具有与初始化器函数调用相同的类型 [HICPP-7_1_8]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_1_8-a.html">使用 auto 关键字声明通过函数调用初始化的变量 [HICPP-7_1_8-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_1_9.html">HIC++ 7.1.9 不明确指定 lambda 的返回类型 [HICPP-7_1_9]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_1_9-a.html">没有显式地指定lambda的返回类型 [HICPP-7_1_9-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_2_1.html">HIC++ 7.2.1 使用显式枚举库并确保它足够大，可以存储所有枚举器 [HICPP-7_2_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_2_1-a.html">使用明确的枚举基础并确保它足够大以存储所有枚举器 [HICPP-7_2_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_2_2.html">HIC++ 7.2.2在枚举中初始化 none、第一个或所有的计数器 [HICPP-7_2_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_2_2-a.html">初始化枚举中的所有枚举数时，只初始化第一个枚举数，或不初始化枚举数 [HICPP-7_2_2-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_3_1.html">HIC++ 7.3.1 不要使用指令 [HICPP-7_3_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_3_1-a.html">不得使用 using 指示符 [HICPP-7_3_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_4_1.html">HIC++ 7.4.1 确保在主源文件中未命名的命名空间中定义来自单个转换单元的任何对象、函数或类型 [HICPP-7_4_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_4_1-a.html">不要使用 static 关键字，除非在函数或者类中 [HICPP-7_4_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_4_2.html">HIC++ 7.4.2 确保在单个头文件中定义内联函数、函数模板或来自多个转换单元的类型 [HICPP-7_4_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_4_2-a.html">在多个编译单元中使用的内联函数应该只能在一个文件中定义 [HICPP-7_4_2-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_4_2-b.html">在多个编译单元中使用的函数模板应该只能在一个文件中定义 [HICPP-7_4_2-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_4_2-c.html">在多个编译单元中使用的类型应该只能在一个文件中定义 [HICPP-7_4_2-c-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_4_3.html">HIC++ 7.4.3 确保来自多个转换单元的对象或函数在一个头文件中进行声明 [HICPP-7_4_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_4_3-a.html">在多个翻译单元中使用的类型，对象或函数应该只能在一个文件中声明 [HICPP-7_4_3-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_5_1.html">HIC++ 7.5.1 不要使用 asm 进行声明 [HICPP-7_5_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-7_5_1-a.html">不要使用asm声明 [HICPP-7_5_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-8_1_1.html">HIC++ 8.1.1 不要使用多层次的指针指向 [HICPP-8_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-8_1_1-a.html">声明不得包含超过一级的间接指针 [HICPP-8_1_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-8_2_1.html">HIC++ 8.2.1 在所有声明中使参数名不存在或完全相同 [HICPP-8_2_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-8_2_1-a.html">禁止函数声明中使用的标识符与实际定义中的标识符不一致 [HICPP-8_2_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-8_2_2.html">HIC++ 8.2.2 不要声明参数过多的函数 [HICPP-8_2_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-8_2_2-a.html">避免函数的参数数目超过5个 [HICPP-8_2_2-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-8_2_3.html">HIC++ 8.2.3 通过值传递带有简单复制构造函数的小对象 [HICPP-8_2_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-8_2_3-a.html">通过值传递带有普通复制构造函数的小对象 [HICPP-8_2_3-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-8_2_3-b.html">通过值传递带有推导拷贝构造函数的小类型对象 [HICPP-8_2_3-b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-8_2_4.html">HIC++ 8.2.4 通过对 const 的引用，进而不通过 std::unique ptr  [HICPP-8_2_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-8_2_4-a.html">不要传递 const 引用类型的 std::unique_ptr 对象 [HICPP-8_2_4-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-8_3_1.html">HIC++ 8.3.1 不要编写复杂程度过高的 McCabe 圈复杂度的函数 [HICPP-8_3_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-8_3_1-a.html">将圈复杂度限制在 10 之内 [HICPP-8_3_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-8_3_3.html">HIC++ 8.3.3 不要使用默认参数 [HICPP-8_3_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-8_3_3-a.html">不要使用缺省参数 [HICPP-8_3_3-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-8_3_4.html">HIC++ 8.3.4 引用 const 定义参数类型为 rvalu e的 =delete 函数 [HICPP-8_3_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-8_3_4-a.html">将有 const 参数的 rvalue 引用函数定义为 =delete [HICPP-8_3_4-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-8_4_1.html">HIC++ 8.4.1 不要访问无效对象或不确定值的对象 [HICPP-8_4_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-8_4_1-a.html">避免在初始化之前使用 [HICPP-8_4_1-a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-8_4_1-b.html">不得使用已经释放掉的资源 [HICPP-8_4_1-b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-8_4_1-c.html">所有自动变量在使用之前都必须被赋值 [HICPP-8_4_1-c-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-8_4_2.html">HIC++ 8.4.2 确保已加固的聚合初始化程序与聚合对象的布局匹配 [HICPP-8_4_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-8_4_2-a.html">聚合体和共同体的初始化对象应该用大括号括起来 [HICPP-8_4_2-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-9_1_1.html">HIC++ 9.1.1 声明任何不需要此功能的静态成员函数。或者，声明不修改对象的外部可见状态的任何常量成员函数 [HICPP-9_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-9_1_1-a.html">如果一个成员函数可以被设为 static 那么它应该被设为 static，否则如果可以被设为 const 那么它应该被设为 const [HICPP-9_1_1-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-9_1_2.html">HIC++ 9.1.2 在覆盖虚拟函数时，使默认参数保持相同或不存在 [HICPP-9_1_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-9_1_2-a.html">禁止使用不同的默认参数值来重定义继承的虚拟函数 [HICPP-9_1_2-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-9_1_3.html">HIC++ 9.1.3 不要从 const 成员函数返回非 const 句柄到类数据中 [HICPP-9_1_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-9_1_3-a.html">Const 成员函数不得返回指向类数据的非 const 指针或引用 [HICPP-9_1_3-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-9_1_4.html">HIC++ 9.1.4 不要编写将非 const 句柄返回到比成员函数更难访问的数据的成员函数 [HICPP-9_1_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-9_1_4-a.html">公共成员函数不应该返回指向私有的/受保护的类数据的非常量句柄 [HICPP-9_1_4-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-9_1_5.html">HIC++ 9.1.5 在最终类中不引入虚拟函数 [HICPP-9_1_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-9_1_5-a.html">不要在final类中引入虚函数 [HICPP-9_1_5-a-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-9_2_1.html">HIC++ 9.2.1 使用显式无符号整数或枚举类型声明位字段 [HICPP-9_2_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/HICPP-9_2_1-a.html">位域只应该有显式的无符号整数或者枚举类型 [HICPP-9_2_1-a-3]</a>
</li></ul>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/INIT.html">初始化 [INIT]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/INIT-01.html">头文件中不应该初始化带有external链接类型的对象 [INIT-01-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/INIT-02.html">不能用有符号常量初始化无符号整型变量 [INIT-02-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/INIT-03.html">初始化所有变量 [INIT-03-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/INIT-04.html">初始化所有指针变量 [INIT-04-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/INIT-05.html">不要对可以更改其地址的对象的引用进行初始化 [INIT-05-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/INIT-06.html">所有成员变量都应该在构造函数中初始化 [INIT-06-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/INIT-07.html">通过用户自定义的构造函数显式初始化类成员 [INIT-07-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/INIT-08.html">用户自定义的构造函数必须初始化动态分配的类对象 [INIT-08-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/INIT-09.html">初始化类的静态成员变量 [INIT-09-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/INIT-10.html">在初始化列表中按声明成员的顺序列出成员 [INIT-10-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/INIT-11.html">赋值运算符应赋值所有数据成员 [INIT-11-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/INIT-12.html">通过用局部静态对象替换非局部静态对象来避免跨越编译单元的初始化顺序问题 [INIT-12-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/INIT-13.html">不能假设在构造函数中成员的初始化顺序 [INIT-13-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/INIT-13_a.html">禁止在基类构造函数中使用未初始化的非静态成员变量 [INIT-13_a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/INIT-13_b.html">不要在虚拟基类构造函数中使用非虚拟基类未初始化的非静态成员变量 [INIT-13_b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/INIT-13_c.html">禁止在基类构造函数中使用基类的可能未初始化的非静态成员变量 [INIT-13_c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/INIT-14.html">在构造函数中推荐使用初始化列表而非赋值 [INIT-14-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/INIT-15.html">考虑添加构造函数来初始化 'struct' 结构体成员变量 [INIT-15-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/INIT-16.html">聚合体和共同体的初始化对象应该用大括号括起来 [INIT-16-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/INIT-17.html">在所有构造函数中,使用相同常量值初始化数据成员的用户定义的构造函数应使用NSDMI进行初始化 [INIT-17-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF.html">联合攻击战斗机 [JSF]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-001.html">任何函数或方法应该不包含超过200行的逻辑代码行数 (L-SLOC) [JSF-001-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-003.html">限制圈复杂度在 20 之内 [JSF-003-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-003_b.html">遵循基本复杂度为 1 的限制 [JSF-003_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-009.html">只使用 ISO C 标准中定义的字符 [JSF-009-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-010.html">字符类型值必须是严格定义和记录的 ISO 10646-1 标准的子集 [JSF-010-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-011.html">禁止使用三字母词 [JSF-011-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-012.html">不要使用下列合体字母 &lt;%, %&gt;, &lt;:, :&gt;, %:, %:%: [JSF-012-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-013.html">不要使用宽字符串字面量 [JSF-013-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-014.html">使用大写 'L' 而非小写 'l' 来指定长整型 [JSF-014-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-015.html">应当作出适当的运行时检查的规定 [JSF-015-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-017.html">不得使用错误指示 'errno' [JSF-017-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-018.html">不应该使用库文件 stddef.h 中的 offsetof 宏 [JSF-018-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-019.html">不要使用 setlocale 函数 [JSF-019-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-019_b.html">不应包含 &lt;locale.h&gt; 头文件 [JSF-019_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-020.html">不使用 setjmp 宏和 longjmp 函数 [JSF-020-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-020_b.html">不要使用标准头文件 &lt;setjmp.h&gt; [JSF-020_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-021.html">禁止使用标准库文件 &lt;signal.h&gt; 中的处理函数 [JSF-021-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-021_b.html">禁止使用信号处理文件 &lt;signal.h&gt; 中的处理函数 [JSF-021_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-022.html">不应该包含标准输入/输出库 stdio.h [JSF-022-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-023.html">不得使用库stdlib.h中的库函数atof，atoi和atol [JSF-023-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-024.html">不得使用 'stdlib.h' 或 'cstdlib' 库中的 'abort()' 函数 [JSF-024-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-024_b.html">不得使用 'stdlib.h' &nbsp;或 'cstdlib' 库中的 'exit()' 函数 [JSF-024_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-024_c.html">不得使用 'stdlib.h' 或 'cstdlib' 库中的 'getenv()' 函数 [JSF-024_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-024_d.html">不得使用 'stdlib.h' 或 'cstdlib' 库中的 'system()' 函数 [JSF-024_d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-025.html">禁止使用库文件 time.h 中的时间处理库函数 [JSF-025-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-026.html">只有下列预处理器指令才能被使用: #ifndef, #define, #endif, #include [JSF-026-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-027.html">使用多个包含保护 [JSF-027-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-028.html">#ifndef 和 #endif 预处理指令将仅用于防止重复地包含相同的头文件 [JSF-028-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-029.html">函数应该优先于宏函数的使用 [JSF-029-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-030.html">不要通过 #define 定义常量 [JSF-030-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-031.html">避免使用宏 [JSF-031-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-032.html">仅可以在包含头文件(*.h)时使用 #include 预处理指令 [JSF-032-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-033.html">#include 指令只能使用 &lt;filename.h&gt; 符号来包含头文件 [JSF-033-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-035.html">使用多个包含保护 [JSF-035-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-037.html">文件应该只包含(include)具有编译该文件所需的声明和定义的头文件 [JSF-037-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-039_a.html">在头文件中不能定义具有链接属性的实体 [JSF-039_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-041.html">源代码行应该保持在 120 个字符之内 [JSF-041-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-042.html">每行只允许有一条语句 [JSF-042-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-043.html">禁止使用未用 ASCII 空格的 Tab 字符 [JSF-043-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-044.html">同级语句行应该缩进到相同的位置 [JSF-044-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-046.html">用户指定的标识符(内部或者外部的)不能多于 64 个字符 [JSF-046-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-047.html">标识符的名字不能以一个下划线 (`_') 或两个下划线 (`__') 开头 [JSF-047-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-048.html">不能使用大小写字母，下划线区分标识符，也不能使用容易与数字混淆的字母做为标识符名字 [JSF-048-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-050.html">类，结构，联合，枚举和自定义类型(typedef)的名字必须以大写字母开头 [JSF-050-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-051_a.html">局部变量名应以小写字母开头 [JSF-051_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-051_b.html">全局变量名应以小写字母开头 [JSF-051_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-051_c.html">成员变量名应以小写字母开头 [JSF-051_c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-051_d.html">全局函数名必须以小写字母开头 [JSF-051_d-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-051_e.html">成员函数名必须以小写字母开头 [JSF-051_e-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-052.html">常量和枚举(enum)类型的标识符必须是小写 [JSF-052-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-053.html">确保头文件应该始终具有扩展名 '.h' [JSF-053-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-053.1.html">下列的字符序列不得出现在头文件名中： ', \, /*, //, 或 " [JSF-053.1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-054.html">C++ 的实现文件应该总是具有扩展名 ".cpp" [JSF-054-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-057_a.html">在一个类中作用范围的顺序为: public 位置应在最前面 [JSF-057_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-057_b.html">在一个类中作用范围的顺序: protected 位于 private 之前 [JSF-057_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-058.html">当函数的形参超过两个的时候，前括号和第一个参数应该和函数名写在一行,其他参数应该再单独一行写一个 [JSF-058-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-059_a.html">'switch', 'while', 'do...while' 或 'for' 语句的主体应该是复合语句 [JSF-059_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-059_b.html">'if' 和 'else' 语句后应跟一个复合句 [JSF-059_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-060_a.html">用于包住一个代码模块的括号 ("{}") 在同一行上除了注释以外不应该有其它代码 [JSF-060_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-060_b.html">大括号 ("{}") 将把一个块放在同一列中 [JSF-060_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-060_c.html">用于包住一个代码模块的括号 ("{}") 不允许在 "{" 之后或 "}" 之前有空行 [JSF-060_c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-061.html">用于包住一个代码模块的括号 ("{}") 在同一行上除了注释以外不应该有其它代码 [JSF-061-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-062.html">解引用运算符 '*' 和地址运算符 '&amp;' 应直接与类型连接在一起 [JSF-062-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-063_a.html">在 '.' 或 '-&gt;' 操作符之后不能有空白格 [JSF-063_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-063_b.html">在 '.' 或 '-&gt;' 操作符之前不能有空白格 [JSF-063_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-063_c.html">在一元运算符 "!" 或 "~" 及其操作数之间不能有空格 [JSF-063_c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-063_d.html">在自增/自减运算符 (++/--) 和其操作数之间不能有空格 [JSF-063_d-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-063_e.html">在一元运算符 "&amp;", "*", "+", "-" 及其操作数之间不能有空格 [JSF-063_e-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-063_f.html">在宏定义中的自增/自减运算符 (++/--) 及其操作数之间不能有空格 [JSF-063_f-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-067_a.html">避免 "public" 数据成员 [JSF-067_a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-067_b.html">避免 'protected' 数据成员 [JSF-067_b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-068.html">私有的拷贝构造函数和拷贝赋值运算符要同时声明 [JSF-068-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-069.html">成员函数应该被尽可能的声明为 const [JSF-069-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-070.html">避免使用友元(friend)机制 [JSF-070-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-070.1.html">被释放的内存在任何情况下都不应该被访问 [JSF-070.1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-070.1_b.html">不应该手动调用析构函数 [JSF-070.1_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-071.html">public 和 protected 的方法不应被类的构造函数调用 [JSF-071-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-071.1.html">避免从构造函数调用虚函数 [JSF-071.1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-071.1_b.html">避免从析构函数调用虚函数 [JSF-071.1_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-071_b.html">所有成员变量都应该在构造函数中初始化 [JSF-071_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-071_c.html">避免从构造函数调用虚函数 [JSF-071_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-071_d.html">禁止在基类构造函数中使用未初始化的非静态成员变量 [JSF-071_d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-071_e.html">不要在虚拟基类构造函数中使用非虚拟基类未初始化的非静态成员变量 [JSF-071_e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-071_f.html">禁止在基类构造函数中使用基类的可能未初始化的非静态成员变量 [JSF-071_f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-074.html">在构造函数中推荐使用初始化列表而非赋值 [JSF-074-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-075.html">在初始化列表中按声明成员的顺序列出成员 [JSF-075-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-076.html">应为包含指向数据项或非平凡析构函数的指针的类声明一个拷贝构造函数和一个拷贝赋值操作符 [JSF-076-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-077.html">拷贝构造函数应复制所有的数据成员以及基类成员 [JSF-077-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-077.1.html">构造函数的定义中不能包含特定的缺省参数，这些参数可能产生与隐性声明的复制构造函数完全一样的签名 [JSF-077.1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-078.html">在具有虚函数的基类中定义虚拟析构函数 [JSF-078-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-079.html">在析构函数中调用 fclose() 函数来关闭用于打开文件的指针成员 [JSF-079-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-079_b.html">在析构函数中对指针成员调用delete [JSF-079_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-081.html">在operator=中检查对self的赋值 [JSF-081-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-082.html">赋值操作符返回一个 *this 指向的引用；使赋值操作符的返回类型是指向自身 class 类型的非 const 引用 [JSF-082-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-083_a.html">赋值运算符应赋值所有数据成员 [JSF-083_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-083_b.html">赋值运算符必须对基类型中的成员进行赋值 [JSF-083_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-085.html">当两个操作符是对立的(例如==和!=)时，可以同时定义它们 [JSF-085-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-085_a.html">如果在一个类中定义了两个相对相等的操作符('=='，'!=')，则其中一个操作符应以另一个操作符的形式定义 [JSF-085_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-087.html">层次结构应该基于抽象类 [JSF-087-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-088.html">多重继承应该限制为之多1个受保护的实现 [JSF-088-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-088.1.html">有状态的虚拟类应该在每个访问该类的衍生类中进行显式地声明 [JSF-088.1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-088_b.html">多重继承不应该使用任何public实现 [JSF-088_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-089.html">在同一层次结构中，基类不能同时具有虚拟及非虚拟的属性 [JSF-089-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-094.html">禁止对继承的非虚拟函数进行重定义 [JSF-094-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-094_b.html">派生类里声明的成员函数不应该隐藏基类中声明的函数 [JSF-094_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-095.html">禁止使用不同的默认参数值来重定义继承的虚拟函数 [JSF-095-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-096.html">指向派生类对象数组的指针不应转换为基类指针 [JSF-096-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-097.html">在接口中不应该使用数组类型参数 [JSF-097-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-097.1.html">判等运算符 (== 或 !=)的任何一个操作数都不应该是一个指向虚成员函数的指针 [JSF-097.1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-097_b.html">私有方法和被保护的方法不应该用数组类型声明参数 [JSF-097_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-097_c.html">全局函数不能声明数组类型的参数 [JSF-097_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-097_d.html">不要将具有数组类型的表达式传递给一个具有指针或者数组类型参数的函数 [JSF-097_d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-097_e.html">使用数组参数调用的函数不应该声明具有指针参数 [JSF-097_e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-098.html">全局命名空间应该只包含 main() 和命名空间声明 [JSF-098-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-099.html">命名空间的嵌套不能超过两层 [JSF-099-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-100.html">不要在头文件中或 #include 之前写 namespace usings [JSF-100-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-104.html">模板所有的部分和显式专门化都应在与其主模板声明相同的文件中声明 [JSF-104-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-105.html">在含有依赖基础的类模板中，任何可能在这个依赖类中被发现的名称都应该引用使用限定标识（qualified-id）或 -&gt; [JSF-105-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-107.html">在文件的范围内声明函数 [JSF-107-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-108.html">避免使用有可变数量参数的函数 [JSF-108-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-109.html">非模板类的定义中不能定义成员函数 [JSF-109-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-110.html">不要使用多于 7 个参数的函数 [JSF-110-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-111.html">不得从函数中返回具有自动存储的对象的地址 [JSF-111-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-111_a.html">函数不得返回一个引用或指针给通过引用或 常数引用传递的参数 [JSF-111_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-112.html">禁止返回函数范围内的new运算符初始化的解引用本地指针 [JSF-112-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-113.html">函数末端应只提供一个出口点 [JSF-113-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-114.html">非 void 返回类型的函数的所有退出路径应该有一个明确的包含表达式的返回语句 [JSF-114-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-115.html">如果函数返回错误信息，该错误信息必须经过测试 [JSF-115-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-115_a.html">从不是重载运算符函数得到的非 void 类型的返回值应该始终被使用 [JSF-115_a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-116.html">通过值传递内置类型，除非你想要修改这些参数 [JSF-116-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-117.html">使用引用而非值传递对象 [JSF-117-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-117.1.html">尽可能声明引用参数为 const 引用 [JSF-117.1-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-117_a.html">避免切片函数参数/返回值 [JSF-117_a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-117_b.html">如果类中含有非静态指针并且没有声明过拷贝构造函数，就应使用引用传递类对象 [JSF-117_b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-118.html">如果函数参数中指针参数在函数中不用来修改地址对象，则应声明为 const 类型 [JSF-118-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-118_b.html">如果指针不用于修改指向地址的对象则声明参数的类型为 typedef 的 const 指针 [JSF-118_b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-119.html">函数不应该直接或者间接地调用自己 [JSF-119-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-121.html">应只将有 1 个或 2 个语句的函数考虑为内联函数的候选函数 [JSF-121-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-122.html">短小且简单的 accessor/mutator 语句应该为内联函数 [JSF-122-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-123.html">不允许仅存在 getters/setters(accessors/mutators) 的类 [JSF-123-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-124.html">应该内联普通的转发函数 [JSF-124-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-125_a.html">使用引用而非值传递对象 [JSF-125_a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-125_b.html">使用 op= 而非单独的操作符 [JSF-125_b-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-126.html">推荐使用 C++ 风格的注释 [JSF-126-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-127.html">代码段不应该被“注释掉” [JSF-127-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-132_a.html">每一个变量声明都应该进行注解 [JSF-132_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-132_b.html">每一个类型定义(typedef)都应该进行注释 [JSF-132_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-132_c.html">每一个枚举值都应该进行注释 [JSF-132_c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-132_d.html">每一个结构成员变量都应该进行注释 [JSF-132_d-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-133_a.html">每个源文件将被记录提供有关文件信息 [JSF-133_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-133_b.html">提供版权信息 [JSF-133_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-134.html">在函数定义之前的注释中记录函数 [JSF-134-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-134_b.html">在函数声明之前的注释中记录函数 [JSF-134_b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-135_a.html">在局部或者函数原型体范围内声明的标识符不应该隐藏一个在全局或者命名空间范围内声明的标识符 [JSF-135_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-135_b.html">在内层的局部范围内声明的标识符不应该隐藏在外层的局部范围内声明的标识符 [JSF-135_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-135_c.html">在一个局部范围内声明的标识符不应该隐藏在一个类作用域中声明的标识符 [JSF-135_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-135_d.html">在类的作用域中声明的标识符不应该隐藏在全局或命名空间范围内声明的标识符 [JSF-135_d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-135_e.html">在一个内部类作用域中声明的标识符不应该隐藏在外部类作用域中声明的标识符 [JSF-135_e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-136_a.html">如果对象只在一个单独的函数中访问那么应定义其在代码块范围 [JSF-136_a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-136_b.html">尽可能地声明局部化的变量 [JSF-136_b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-137.html">具有外部链接的对象或函数应该在头文件中声明 [JSF-137-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-138_a.html">标识符在同一编译单元中不能同时具有内部和外部链接 [JSF-138_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-138_b.html">静态存储类说明符应该用于具有内部链接的对象和函数的定义和声明 [JSF-138_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-139.html">外部对象不得声明在多个文件中 [JSF-139-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-139_b.html">外部对象不应该在实现文件中声明 [JSF-139_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-140.html">不应使用'register'存储类说明符 [JSF-140-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-141.html">类，结构体或枚举不应该在其类型定义中被声明 [JSF-141-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-142_a.html">所有自动变量在使用之前都必须被赋值 [JSF-142_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-142_b.html">初始化所有变量 [JSF-142_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-143.html">如果变量不能被初始化为有意义的值就不应引入 [JSF-143-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-143_a.html">避免使用不必要的局部变量 [JSF-143_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-144.html">聚合体和共同体的初始化对象应该用大括号括起来 [JSF-144-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-145.html">在枚举类型中，要么仅对第一个元素进行显式地初始化，要么所有元素都进行显式的初始化 [JSF-145-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-147.html">不得使用浮点型数向下转换表示 [JSF-147-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-148.html">Case 语句的标签应该使用枚举(enum)类型而不是使用整数类型(和常量) [JSF-148-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-149.html">不应该使用八进制常数（除零外） [JSF-149-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-150.html">十六进制常量应该全部使用大写字母表示 [JSF-150-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-151.html">避免使用幻数 [JSF-151-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-151.1.html">字符串文字不应被修改 [JSF-151.1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-152.html">不允许在同一行声明多个变量 [JSF-152-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-153.html">禁止使用联合体 [JSF-153-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-154.html">位域只应该有显式的无符号整数或者枚举类型 [JSF-154-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-156.html">结构体或联合体或类的所有成员变量应该被命名 [JSF-156-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-157.html">逻辑&amp;&amp;或||运算符的右操作数不得含有副作用 [JSF-157-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-158.html">如果逻辑 &amp;&amp; 或 || 的操作数包含二元运算符则操作数应该被括起来 [JSF-158-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-159.html">避免重载逻辑操作符AND, OR (&amp;&amp;, ||) [JSF-159-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-159_b.html">一元 &amp; 运算符不得被重载 [JSF-159_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-160.html">禁止在产生布尔值的表达式中使用赋值运算符 [JSF-160-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-162_a.html">在比较运算中不允许混合使用有符号值和无符号值 [JSF-162_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-162_b.html">在条件运算符的第二个和第三个操作数中不允许混合使用有符号和无符号值 [JSF-162_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-162_c.html">在算术运算中不允许混合使用有符号值和无符号值 [JSF-162_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-163.html">不要使用无符号算术 [JSF-163-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-164.html">一个移位操作符的右操作数应该位于 0 到 1 之间，小于左操作数底层类型的位宽 [JSF-164-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-164.1.html">右移位操作符的左操作数不能是负数 [JSF-164.1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-165.html">一元减法运算符不得适用于其原始类型是无符号型的表达式 [JSF-165-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-166.html">sizeof运算符的操作数不应包含任何有副作用的表达式 [JSF-166-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-166_b.html">不应在sizeof运算符的操作数中访问由volatile左值指定的对象 [JSF-166_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-166_c.html">会导致副作用的函数调用不应该用作 sizeof 运算符的操作数 [JSF-166_c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-167.html">整数除法操作语句之前必须有注释 [JSF-167-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-167_a.html">不能将两个整数相除之后的结果赋给浮点类型 [JSF-167_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-168_b.html">不应该使用逗号运算符 [JSF-168_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-169.html">应该尽可能避免使用指向指针的指针 [JSF-169-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-170.html">对象的声明应该包含不超过 2 层的指针嵌套 [JSF-170-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-171.html">&gt;, &gt;=, &lt;, &lt;= 不应用于指针类型，除非它们指向相同的数组 [JSF-171-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-173.html">自动存储对象的地址不应分配给在第一个对象不再存在后可能持久存在的另一个对象 [JSF-173-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-174_a.html">空指针不得解引用 [JSF-174_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-174_b.html">空指针不得解引用 [JSF-174_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-175.html">不要使用 NULL 标识符; 而是使用 0 替代 [JSF-175-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-176.html">当声明函数指针时使用 typedef 来简化程序语法 [JSF-176-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-177.html">不要使用用户自定义的转换函数 [JSF-177-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-177_b.html">允许转换的构造函数应该是使用 explicit 修饰 [JSF-177_b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-178.html">向下的强制转换(基类到衍生类的转换)是不允许的 [JSF-178-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-179.html">指向虚拟基类型的指针只能通过dynamic_cast的方式转换为指向其衍生类的指针 [JSF-179-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-180_a.html">不应使用可能导致信息丢失的从较宽到较窄的整数类型的隐式转换 [JSF-180_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-180_b.html">避免浮点型到整型的隐式转换 [JSF-180_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-180_c.html">避免宽字段到窄字段浮点型数据的隐式转换 [JSF-180_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-180_d.html">避免将常数值转换为一个窄类型 [JSF-180_d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-180_e.html">避免从有符号类型到无符号类型的隐式变换 [JSF-180_e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-180_f.html">不应使用可能导致信息丢失的从整型到浮点型的隐式转换 [JSF-180_f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-180_g.html">不应使用可能会导致信息丢失的从整数常量到浮点类型的隐式转换 [JSF-180_g-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-181_a.html">不允许冗余显式转换为同一类型 [JSF-181_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-181_b.html">避免从衍生类到基类的显式类型转换 [JSF-181_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-182.html">不得使用从任何类型到指针或者指针到任何类型的类型转换 [JSF-182-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-183.html">避免使用显式类型转换(强制类型转换) [JSF-183-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-183_a.html">避免在指针上使用 static_cast [JSF-183_a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-183_b.html">避免使用强制类型转换符 reinterpret_cast [JSF-183_b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-184_a.html">避免浮点型到整型的隐式转换 [JSF-184_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-185.html">不得使用 C 语言风格的强制类型转换(除 void 强制类型转换外)和函数符号式强制类型转换(除了显式的构造函数调用外) [JSF-185-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-186_a.html">在 "else" 语句块中不应存在执行不到的代码 [JSF-186_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-186_b.html">在 'return', 'break', 'continue', 和 'goto' 语句之后不应存在执行不到的代码 [JSF-186_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-186_c.html">在 "if/else/while/for" 语句块中不应存在执行不到的代码 [JSF-186_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-186_d.html">在 switch 语句中不应存在执行不到的代码 [JSF-186_d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-186_e.html">在 'for' 循环中不应存在执行不到的代码 [JSF-186_e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-186_f.html">在 'if' 或 'switch' 语句后不应存在不可访问的代码 [JSF-186_f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-186_g.html">在 while/for/do...while 循环内的 "if" 或 "switch" 语句后不应存在执行不到的代码 [JSF-186_g-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-186_h.html">每个定义的具有内部链接的函数应该至少被使用一次 [JSF-186_h-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-187.html">所有非 null 语句应该至少有一个执行或者导致控制流变化的附加作用 [JSF-187-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-188.html">避免使用标签 [JSF-188-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-189.html">不应该使用 goto 语句 [JSF-189-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-190.html">不要使用 continue 语句 [JSF-190-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-191.html">请勿使用 break 语句 [JSF-191-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-191_a.html">对任何循环语句，都应存在不止一个用于循环终止的 break 或 goto 语句 [JSF-191_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-192.html">所有的 'if...else if' 结构应该包含一个最后的 'else' 分支或明确的注释表示为什么不需要最后的 'else' 分支。 [JSF-192-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-193.html">无条件的 break 语句应该作为每一个非空 case 子句的结束 [JSF-193-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-194.html">在 switch 语句中的最后分支应该是 default 分支，除非所有枚举值都被测试 [JSF-194-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-195.html">switch 表达式不应该出现一个实际为布尔的值 [JSF-195-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-196.html">每个 switch 语句至少有两个 case 分支和一个潜在的 default 分支 [JSF-196-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-197.html">不得使用浮点变量作为循环计数器 [JSF-197-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-198.html">除了初始化单个for循环参数的值外，for循环中的初始化表达式将不执行任何操作 [JSF-198-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-199.html">在 for 循环中的增量表达式除了改变单个循环参数到下一个值外，不应该执行其他任何操作 [JSF-199-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-200.html">如果 'for' 语句中无初始化或者无增量表达式; 应该使用 while 循环替代 [JSF-200-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-201.html">禁止在循环体中修改循环计数器 [JSF-201-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-202.html">禁止对浮点数类型的表达式做相等或不相等的比较 [JSF-202-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-203.html">对常量无符号整数表达式的求值不应该导致循环 [JSF-203-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-204.1_a.html">表达式的值应该在任何标准允许的赋值顺序下是一样的 [JSF-204.1_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-204.1_b.html">不要编写依赖于函数参数求值顺序的代码 [JSF-204.1_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-204.1_c.html">不要编写依赖于函数标志符和函数参数的求值顺序的代码 [JSF-204.1_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-204.1_d.html">涉及一个函数调用时，不要编写依赖表达式求值顺序的代码 [JSF-204.1_d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-204.1_e.html">在序列点之间，对象的存储值最多只能通过表达式的计算来修改一次 [JSF-204.1_e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-204.1_f.html">不要在两个相邻的序列点之间使用多个 volatile [JSF-204.1_f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-204.1_g.html">不要编写依赖于函数调用求值顺序的代码 [JSF-204.1_g-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-204_a.html">具有副作用的单一操作只能在适当的情况下使用 [JSF-204_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-204_b.html">具有副作用的函数调用只能在适当的上下文中使用 [JSF-204_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-204_d.html">三元运算符 '?:' 的第二个或第三个操作数不得含有副作用 [JSF-204_d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-205.html">不要使用 volatile 关键字 [JSF-205-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-206.html">禁止使用动态内存分配 [JSF-206-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-207.html">避免未封装的全局变量 (包括在命名空间中声明的变量和 public static 公共静态成员) [JSF-207-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-208.html">在程序中不要运用 C++ 异常处理函数(例如,不得使用 throw, catch 和 try 等) [JSF-208-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-209.html">用 typedef 定义基本类型应该在名称中包含数字 [JSF-209-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-209_b.html">typedefs 应该被用于替代基本类型 [JSF-209_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-210.1.html">算法中不应假设由访问标识符分隔的非静态数据成员的分配顺序 [JSF-210.1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-211.html">不允许不同的指针对象之间进行强制转换 [JSF-211-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-213_e.html">如果操作符的优先级低于算术运算符，应该使用圆括号明确表达式的操作顺序 [JSF-213_e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-214.html">通过用局部静态对象替换非局部静态对象来避免跨越编译单元的初始化顺序问题 [JSF-214-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/JSF-215.html">不应该使用指针算法 [JSF-215-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS.html">度量指标 [METRICS]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-01.html">避免函数超过 50 行 [METRICS-01-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-02.html">避免 switch 代码段包含过多 case [METRICS-02-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-03.html">函数内的代码块 [METRICS-03-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-04.html">函数中有过多函数调用 [METRICS-04-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-05.html">类的继承级别 [METRICS-05-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-06.html">每个函数的成员变量数不应该超过 15个 [METRICS-06-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-07.html">每个类的方法数 [METRICS-07-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-08.html">每个方法参数不应该超过10 [METRICS-08-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-09.html">每个类的私有成员变量数目 [METRICS-09-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-10.html">每个类的私有方法数 [METRICS-10-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-11.html">每个类的 protected 成员变量数 [METRICS-11-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-12.html">每个类的 protected 方法的数量 [METRICS-12-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-13.html">每个类的公共成员变量数目 [METRICS-13-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-14.html">每个类的公共方法数目 [METRICS-14-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-15.html">避免函数的参数数目超过5个 [METRICS-15-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-16.html">宏参数应该不超过 5个 [METRICS-16-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-17.html">避免 structs, unions, 或类有超过20个范围 [METRICS-17-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-18.html">将圈复杂度限制在 10 之内 [METRICS-18-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-19.html">注释行占模块行总数的百分比应该在 20 到 60 之间 [METRICS-19-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-20.html">避免太长的函数声明和代码段 [METRICS-20-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-21.html">避免太长的函数块 [METRICS-21-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-22.html">避免函数的行数超过75行 [METRICS-22-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-23.html">嵌套块深度不应高于 5 [METRICS-23-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-24.html">避免超过 500 行的源代码 [METRICS-24-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-25.html">任何函数或方法应该不包含超过200行的逻辑代码行数 (L-SLOC) [METRICS-25-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-26.html">源代码行应该保持在 120 个字符之内 [METRICS-26-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-27.html">不要使用多于 7 个参数的函数 [METRICS-27-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-28.html">限制圈复杂度在 20 之内 [METRICS-28-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-29.html">报告圈复杂度 [METRICS-29-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-30.html">函数不应该超过 60 行代码 [METRICS-30-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-31.html">代码的断言密度应该平均到每个函数应至少有两个断言 [METRICS-31-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-32.html">所有超过 20 行的函数应该包含至少两个断言 [METRICS-32-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-33.html">报告基本复杂度 [METRICS-33-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-34.html">遵守基本复杂度为 4 的限制 [METRICS-34-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-35.html">遵守基本复杂度为 10 的限制 [METRICS-35-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-36.html">函数不得从超过 5 个不同的函数中调用 [METRICS-36-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-37.html">函数不得调用超过 7 个不同的函数 [METRICS-37-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-38.html">函数中的语句数量应该介于 1-50 的范围之间 [METRICS-38-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-39.html">函数的 VOCF 度量指标值不应该高于 4 [METRICS-39-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-40.html">函数中语句的嵌套深度不得超过 4 层 [METRICS-40-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-41.html">函数前面和内部的注释模块的数量与函数内语句的数量之比应该 &gt; 0.2 [METRICS-41-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-42.html">遵循基本复杂度为 1 的限制 [METRICS-42-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/METRICS-43.html">报告函数的霍尔斯特德交付错误 (B) 值 [METRICS-43-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA.html">MISRA C 1998 [MISRA]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-004_a.html">应当作出适当的运行时检查的规定 [MISRA-004_a-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-004_b.html">应当作出适当的运行时检查的规定 [MISRA-004_b-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-005.html">只使用 ISO C 标准中定义的字符 [MISRA-005-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-006.html">字符类型值必须是严格定义和记录的 ISO 10646-1 标准的子集 [MISRA-006-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-008.html">不要使用宽字符串字面量 [MISRA-008-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-013.html">不应该使用 char, int, short, long, float and double 的基本类型, 而是应该用 typedef 来定义特定长度的等量 [MISRA-013-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-014.html">显式地声明 'char' 类型为有符号类型或者无符号类型 [MISRA-014-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-016.html">不得使用浮点型数向下转换表示 [MISRA-016-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-018_a.html">数字常量必须使用类型后缀 [MISRA-018_a-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-018_b.html">数字常量必须使用类型后缀 [MISRA-018_b-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-018_c.html">数字常量必须使用类型后缀 [MISRA-018_c-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-018_d.html">数字常量必须使用类型后缀 [MISRA-018_d-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-020.html">所有对象和函数必须先声明再使用 [MISRA-020-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-022.html">在函数范围内声明对象 [MISRA-022-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-023.html">具有外部链接的对象或函数应该在头文件中声明 [MISRA-023-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-024.html">标识符在同一编译单元中不能同时具有内部和外部链接 [MISRA-024-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-027.html">外部对象不得声明在多个文件中 [MISRA-027-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-027_b.html">外部对象不应该在实现文件中声明 [MISRA-027_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-028.html">不应使用'register'存储类说明符 [MISRA-028-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-029.html">标签的使用应当与其声明一致 [MISRA-029-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-030.html">所有自动变量在使用之前都必须被赋值 [MISRA-030-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-038.html">移位运算符右操作数的无效范围 [MISRA-038-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-041.html">整数除法操作语句之前必须有注释 [MISRA-041-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-042.html">除了在 FOR 循环的控制表达式之外，不得使用逗号运算符 [MISRA-042-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-043.html">不应使用可能导致信息丢失的从较宽到较窄的整数类型的隐式转换 [MISRA-043-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-043_b.html">避免在同一个表达式中混合使用不同精度的算术运算 [MISRA-043_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-043_c.html">不应使用可能导致信息丢失的从整型到浮点型的隐式转换 [MISRA-043_c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-043_d.html">不应使用可能会导致信息丢失的从整数常量到浮点类型的隐式转换 [MISRA-043_d-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-044.html">不允许冗余显式转换为同一类型 [MISRA-044-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-046_a.html">不要使用 volatile 关键字 [MISRA-046_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-046_b.html">赋值语句不应该嵌套使用在赋值语句中 [MISRA-046_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-048_a.html">避免在将结果转换为更广泛的整数类型的表达式中可能出现的整数溢出 [MISRA-048_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-048_b.html">不要将两个整数的被除数强制类型转换为一个浮点类型 [MISRA-048_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-048_c.html">避免在将结果赋给更大整数类型的变量的表达式中可能出现的整数溢出 [MISRA-048_c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-048_d.html">避免无意地丢弃整数除法的余数 [MISRA-048_d-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-051.html">对常量无符号整数表达式的求值不应该导致循环 [MISRA-051-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-054.html">空语句只能单独出现在一行之中并且在同一行中禁止出现其他字符 [MISRA-054-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-055.html">避免使用标签 [MISRA-055-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-058.html">请勿使用 break 语句 [MISRA-058-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-065.html">不得使用浮点变量作为循环计数器 [MISRA-065-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-069.html">避免使用有可变数量参数的函数 [MISRA-069-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-071_a.html">函数应该有函数原型并且该原型应该对函数定义和调用可见 [MISRA-071_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-071_b.html">在函数调用时，函数总是有可见的原型 [MISRA-071_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-073.html">函数的参数要么不提供标识符要么提供所有标识符 [MISRA-073-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-083.html">非 void 函数的返回语句必须提供表达式 [MISRA-083-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-084.html">避免 void 函数中存在 return 语句表达式。 [MISRA-084-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-089.html">#include 指令后面应当添加 &lt;filename&gt; 或是 "filename" [MISRA-089-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-096.html">必须把类函数形式的宏定义放进括号中 [MISRA-096-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-100.html">只能使用没有歧义性的预处理操作符格式 [MISRA-100-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-101.html">不应该使用指针算法 [MISRA-101-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-104.html">不要使用非常量指针指向函数 [MISRA-104-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-105.html">函数指针应该与其指向的所有函数的参数个数，参数类型和返回值类型相同 [MISRA-105-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-107_a.html">空指针不得解引用 [MISRA-107_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-107_b.html">空指针不得解引用 [MISRA-107_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-108.html">结构体和联合体中的所有成员必须完全指定 [MISRA-108-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-110.html">不能使用联合体访问大数据结构的子部分 [MISRA-110-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-113.html">结构体或联合体或类的所有成员变量应该被命名 [MISRA-113-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-115.html">不得重复使用标准库函数的名称 [MISRA-115-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-121_a.html">不要使用 setlocale 函数 [MISRA-121_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA-121_b.html">不应包含 &lt;locale.h&gt; 头文件 [MISRA-121_b-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004.html">MISRA C 2004 [MISRA2004]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-10_1_a.html">避免无符号整型和有符号整型之间隐式地转换 [MISRA2004-10_1_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-10_1_b.html">避免隐式的整型和浮点类型的转换 [MISRA2004-10_1_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-10_1_c.html">避免隐式的复合表达式的数据类型转换 [MISRA2004-10_1_c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-10_1_d.html">避免从更宽到更窄的类型的隐式转换 [MISRA2004-10_1_d-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-10_1_e.html">避免隐式的函数返回表达式类型转换 [MISRA2004-10_1_e-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-10_1_f.html">避免隐式的复合表达式的类型转换 [MISRA2004-10_1_f-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-10_1_g.html">避免函数参数进行隐式地类型转换 [MISRA2004-10_1_g-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-10_1_h.html">避免隐式的无符号整型和有符号整型的转换 [MISRA2004-10_1_h-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-10_1_i.html">避免隐式的复合表达式的数据类型转换 [MISRA2004-10_1_i-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-10_2_a.html">避免浮点型到整型的隐式转换 [MISRA2004-10_2_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-10_2_b.html">避免宽字段到窄字段浮点型数据的隐式转换 [MISRA2004-10_2_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-10_2_c.html">避免隐式的窄字段到宽字段浮点型数据转换 [MISRA2004-10_2_c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-10_2_d.html">避免将浮点数从较宽的浮点类型隐式转换为较窄的浮点类型 [MISRA2004-10_2_d-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-10_3.html">整型复合表达式的值只能被强制转换到较短的类型，或者与该表达式类型相同的有符号类型 [MISRA2004-10_3-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-10_4.html">浮点类型的复杂表达式的值只能转换为精度较低的浮点类型 [MISRA2004-10_4-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-10_5.html">如果对无符号字符型或无符号短整型进行 ~ &nbsp;和 &lt;&lt; 位运算后，其结果应立即强制转换成操作数的基本类型 [MISRA2004-10_5-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-10_6.html">无符号类型的所有常量应该使用 'U' 后缀 [MISRA2004-10_6-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-11_1.html">除了整数类型外不允许其他类型和函数指针进行类型转换 [MISRA2004-11_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-11_2.html">对象指针只能被转换成整数类型，与对象同类型的指针和 void 指针 [MISRA2004-11_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-11_2_b.html">对象指针只能被转换成整数类型，与对象同类型的指针和 void 指针 [MISRA2004-11_2_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-11_2_c.html">对象指针只能被转换成整数类型，与对象同类型的指针和 void 指针 [MISRA2004-11_2_c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-11_3_a.html">不允许指针类型和整数类型之间进行类型转换 [MISRA2004-11_3_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-11_3_b.html">禁止将其它类型变量强制转换成指针变量 [MISRA2004-11_3_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-11_4.html">不允许不同的指针对象之间进行强制转换 [MISRA2004-11_4-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-11_5.html">强制转换不得从指针或引用类型中删除任何“const”或“volatile”限定条件 [MISRA2004-11_5-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-12_10.html">不应该使用逗号运算符 [MISRA2004-12_10-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-12_12.html">禁止对浮点数值进行位操作 [MISRA2004-12_12-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-12_13.html">禁止在同一个表达式中混合使用递加符 (++) 和递减符 (--) 与其他运算符 [MISRA2004-12_13-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-12_1_a.html">谨慎使用 C 语言中表达式的优先运算规则 [MISRA2004-12_1_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-12_1_b.html">谨慎使用 C 语言中表达式的优先运算规则 [MISRA2004-12_1_b-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-12_1_c.html">一元运算符的操作数不需要括号 [MISRA2004-12_1_c-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-12_1_d.html">谨慎使用 C 语言中表达式的优先运算规则 [MISRA2004-12_1_d-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-12_1_e.html">除非表达式中的所有运算符都相同，否则使用圆括号 [MISRA2004-12_1_e-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-12_1_f.html">谨慎使用 C 语言中表达式的优先运算规则 [MISRA2004-12_1_f-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-12_2_a.html">表达式的值应该在任何标准允许的赋值顺序下是一样的 [MISRA2004-12_2_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-12_2_b.html">不要编写依赖于函数参数求值顺序的代码 [MISRA2004-12_2_b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-12_2_c.html">不要编写依赖于函数标志符和函数参数的求值顺序的代码 [MISRA2004-12_2_c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-12_2_d.html">涉及一个函数调用时，不要编写依赖表达式求值顺序的代码 [MISRA2004-12_2_d-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-12_2_e.html">在序列点之间，对象的存储值最多只能通过表达式的计算来修改一次 [MISRA2004-12_2_e-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-12_2_f.html">不要在两个相邻的序列点之间使用多个 volatile [MISRA2004-12_2_f-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-12_2_g.html">不要编写依赖于函数调用求值顺序的代码 [MISRA2004-12_2_g-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-12_3.html">sizeof运算符的操作数不应包含任何有副作用的表达式 [MISRA2004-12_3-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-12_3_b.html">不应在sizeof运算符的操作数中访问由volatile左值指定的对象 [MISRA2004-12_3_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-12_3_c.html">会导致副作用的函数调用不应该用作 sizeof 运算符的操作数 [MISRA2004-12_3_c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-12_4_a.html">逻辑&amp;&amp;或||运算符的右操作数不得含有副作用 [MISRA2004-12_4_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-12_5.html">逻辑运算符 &amp;&amp; 或者 || 的操作数应该是基本表达式 [MISRA2004-12_5-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-12_6_a.html">逻辑运算符 (&amp;&amp;, || 和 !) 的操作数应该是有效的布尔值 [MISRA2004-12_6_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-12_6_b.html">有效布尔值的表达式不应该用作除 (&amp;&amp;, ||, !, =, ==, !=, ?:) 之外的运算符的操作数。 [MISRA2004-12_6_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-12_7.html">禁止对有符号类型使用位操作 [MISRA2004-12_7-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-12_8.html">一个移位操作符的右操作数应该位于 0 到 1 之间，小于左操作数底层类型的位宽 [MISRA2004-12_8-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-12_9.html">一元减法运算符不得适用于其原始类型是无符号型的表达式 [MISRA2004-12_9-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_1.html">禁止在产生布尔值的表达式中使用赋值运算符 [MISRA2004-13_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_2.html">测试一个值是否为零应该是显式的，除非操作数实际上是布尔值 [MISRA2004-13_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_3.html">禁止对浮点数类型的表达式做相等或不相等的比较 [MISRA2004-13_3-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_4.html">for 循环语句中的控制表达式不能包含浮点类型对象 [MISRA2004-13_4-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_5.html">for 循环语句的三个表达式应该仅与循环控制相关 [MISRA2004-13_5-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_6.html">禁止在循环体中修改循环计数器 [MISRA2004-13_6-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_7_a.html">不允许其结果是不变的布尔运算 [MISRA2004-13_7_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_7_aa.html">不允许其结果是不变的布尔运算 [MISRA2004-13_7_aa-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_7_ab.html">不允许其结果是不变的布尔运算 [MISRA2004-13_7_ab-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_7_ac.html">不允许其结果是不变的布尔运算 [MISRA2004-13_7_ac-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_7_ad.html">不允许其结果是不变的布尔运算 [MISRA2004-13_7_ad-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_7_ae.html">不允许其结果是不变的布尔运算 [MISRA2004-13_7_ae-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_7_af.html">不允许其结果是不变的布尔运算 [MISRA2004-13_7_af-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_7_ag.html">不允许其结果是不变的布尔运算 [MISRA2004-13_7_ag-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_7_ah.html">不允许其结果是不变的布尔运算 [MISRA2004-13_7_ah-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_7_ai.html">不允许其结果是不变的布尔运算 [MISRA2004-13_7_ai-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_7_aj.html">不允许其结果是不变的布尔运算 [MISRA2004-13_7_aj-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_7_ak.html">不允许其结果是不变的布尔运算 [MISRA2004-13_7_ak-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_7_b.html">不允许其结果是不变的布尔运算 [MISRA2004-13_7_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_7_c.html">不允许其结果是不变的布尔运算 [MISRA2004-13_7_c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_7_d.html">不允许其结果是不变的布尔运算 [MISRA2004-13_7_d-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_7_j.html">不允许其结果是不变的布尔运算 [MISRA2004-13_7_j-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_7_k.html">不允许其结果是不变的布尔运算 [MISRA2004-13_7_k-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_7_l.html">不允许其结果是不变的布尔运算 [MISRA2004-13_7_l-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_7_m.html">不允许其结果是不变的布尔运算 [MISRA2004-13_7_m-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_7_n.html">不允许其结果是不变的布尔运算 [MISRA2004-13_7_n-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_7_s.html">不允许其结果是不变的布尔运算 [MISRA2004-13_7_s-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_7_t.html">不允许其结果是不变的布尔运算 [MISRA2004-13_7_t-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_7_u.html">不允许其结果是不变的布尔运算 [MISRA2004-13_7_u-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_7_v.html">不允许其结果是不变的布尔运算 [MISRA2004-13_7_v-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_7_w.html">包含枚举的条件始终为 'true' 或 'false' [MISRA2004-13_7_w-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_7_x.html">不允许其结果是不变的布尔运算 [MISRA2004-13_7_x-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_7_y.html">不允许其结果是不变的布尔运算 [MISRA2004-13_7_y-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-13_7_z.html">不允许其结果是不变的布尔运算 [MISRA2004-13_7_z-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-14_10.html">所有 'if...else-if' 结构应使用一个 'else' 子句终止 [MISRA2004-14_10-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-14_1_a.html">在 "else" 语句块中不应存在执行不到的代码 [MISRA2004-14_1_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-14_1_b.html">在 'return', 'break', 'continue', 和 'goto' 语句之后不应存在执行不到的代码 [MISRA2004-14_1_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-14_1_c.html">在 "if/else/while/for" 语句块中不应存在执行不到的代码 [MISRA2004-14_1_c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-14_1_d.html">在 switch 语句中不应存在执行不到的代码 [MISRA2004-14_1_d-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-14_1_e.html">在 'for' 循环中不应存在执行不到的代码 [MISRA2004-14_1_e-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-14_1_f.html">在 'if' 或 'switch' 语句后不应存在不可访问的代码 [MISRA2004-14_1_f-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-14_1_g.html">在 while/for/do...while 循环内的 "if" 或 "switch" 语句后不应存在执行不到的代码 [MISRA2004-14_1_g-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-14_2.html">所有非 null 语句应该至少有一个执行或者导致控制流变化的附加作用 [MISRA2004-14_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-14_3.html">空语句只允许单独存在一行或者可以在其后面跟着注释 [MISRA2004-14_3-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-14_4.html">不应该使用 goto 语句 [MISRA2004-14_4-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-14_5.html">不要使用 continue 语句 [MISRA2004-14_5-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-14_6.html">对任何循环语句，最多不应超过一个 break 语句用于循环终止 [MISRA2004-14_6-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-14_7.html">函数末端应只提供一个出口点 [MISRA2004-14_7-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-14_8.html">'switch', 'while', 'do...while' 或 'for' 语句的主体应该是复合语句 [MISRA2004-14_8-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-14_9.html">'if' 和 'else' 语句后应跟一个复合句 [MISRA2004-14_9-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-15_0_a.html">break 语句应只出现在 switch 子句末端 [MISRA2004-15_0_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-15_0_b.html">switch 语句应该只包含 switch 标签和 switch 子句，不能包含其他代码 [MISRA2004-15_0_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-15_1.html">只有当最紧密封闭的复合语句是 switch 语句主体的时才能使用 switch 标签 [MISRA2004-15_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-15_2.html">无条件的 break 语句应该作为每一个非空 case 子句的结束 [MISRA2004-15_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-15_2_b.html">无条件的 break 语句应作为所有非空 default 条件的结束 [MISRA2004-15_2_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-15_3.html">switch 语句中最后必须为 default 子句 [MISRA2004-15_3-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-15_4.html">switch 表达式不应该出现一个实际为布尔的值 [MISRA2004-15_4-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-15_4_b.html">switch 表达式不应该出现一个实际为布尔的值 [MISRA2004-15_4_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-15_5.html">每一个 switch 语句至少有一个 case 子句 [MISRA2004-15_5-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-16_1.html">函数不应使用可变数量的参数定义 [MISRA2004-16_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-16_10.html">如果函数返回错误信息，该错误信息必须经过测试 [MISRA2004-16_10-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-16_2.html">函数不应该直接或者间接地调用自己 [MISRA2004-16_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-16_3.html">在函数原型声明中应该为所有参数提供标识符 [MISRA2004-16_3-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-16_4.html">禁止函数声明中使用的标识符与实际定义中的标识符不一致 [MISRA2004-16_4-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-16_5.html">没有参数的函数必须声明参数类型为 void [MISRA2004-16_5-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-16_6.html">传递给函数的参数个数必须与函数定义的参数一致 [MISRA2004-16_6-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-16_7.html">如果函数参数中指针参数在函数中不用来修改地址对象，则应声明为 const 类型 [MISRA2004-16_7-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-16_7_b.html">如果指针不用于修改指向地址的对象则声明参数的类型为 typedef 的 const 指针 [MISRA2004-16_7_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-16_8.html">非 void 返回类型的函数的所有退出路径应该有一个明确的包含表达式的返回语句 [MISRA2004-16_8-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-16_9.html">函数标识符只能与前面的 &nbsp;'&amp;' 一起使用，或者与括号中的参数列表一起使用，参数列表可以是空的 [MISRA2004-16_9-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-17_1.html">不要对那些没有指向数组或数组元素地址的指针进行指针运算 [MISRA2004-17_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-17_2.html">只有指向数组或数组元素地址的指针才能进行指针运算 [MISRA2004-17_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-17_3.html">&gt;, &gt;=, &lt;, &lt;= 不应用于指针类型，除非它们指向相同的数组 [MISRA2004-17_3-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-17_4.html">只有数组索引才能进行算术指针操作 [MISRA2004-17_4-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-17_5.html">对象的声明应该包含不超过 2 层的指针嵌套 [MISRA2004-17_5-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-17_6_a.html">不得从函数中返回具有自动存储的对象的地址 [MISRA2004-17_6_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-17_6_b.html">自动存储对象的地址不应分配给在第一个对象不再存在后可能持久存在的另一个对象 [MISRA2004-17_6_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-18_1.html">在转换单元结束之前，所有的结构体和联合体必须有完整的声明 [MISRA2004-18_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-18_2.html">不应该将结构体自身的一个成员变量赋给另一个成员变量 [MISRA2004-18_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-18_2_b.html">结构体的每个成员不应该赋值给自己的其他成员变量 [MISRA2004-18_2_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-18_4.html">禁止使用联合体 [MISRA2004-18_4-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-19_1.html">#include 之前只允许有预处理命令和注释 [MISRA2004-19_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-19_10.html">在函数式宏定义中，每个参数的实例应该被括号括起来，除非它被用于 # 或 ## 操作符 [MISRA2004-19_10-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-19_11_b.html">不要使用在编译单元中未定义的预编译器指令 #if 和 #elif &nbsp;宏 [MISRA2004-19_11_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-19_12.html">禁止宏定义中使用多个 # 和 ## [MISRA2004-19_12-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-19_13.html">禁止使用预处理操作符 # 和 ## [MISRA2004-19_13-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-19_14.html">预处理操作符只能用在两种标准格式之一 [MISRA2004-19_14-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-19_15.html">必须采取预防措施以防止头文件的内容被引用两次 [MISRA2004-19_15-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-19_16.html">预处理指令即使被预处理器排除也必须有语法意义 [MISRA2004-19_16-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-19_17.html">在同一个文件中 #else, #elif 和 #endif 必须对应有 #if 或 #ifdef 预处理指令 [MISRA2004-19_17-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-19_2.html">非标准字符不应该用于 #include 指令的头文件名称中 [MISRA2004-19_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-19_3.html">#include 指令后面应当添加 &lt;filename&gt; 或是 "filename" [MISRA2004-19_3-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-19_4.html">避免宏定义中存在关键字和基本类型 [MISRA2004-19_4-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-19_5.html">禁止在块中使用 #define 或 #undef [MISRA2004-19_5-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-19_6.html">禁止使用 #undef [MISRA2004-19_6-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-19_7.html">函数应该优先于宏函数的使用 [MISRA2004-19_7-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-19_8.html">类似函数的宏在调用时参数个数必须一致 [MISRA2004-19_8-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-19_9.html">类似函数的宏的参数不应该包含类似预处理命令的标识 [MISRA2004-19_9-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-20_10.html">不得使用库stdlib.h中的库函数atof，atoi和atol [MISRA2004-20_10-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-20_11.html">不得使用 'stdlib.h' 或 'cstdlib' 库中的 'abort()' 函数 [MISRA2004-20_11-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-20_11_b.html">不得使用 'stdlib.h' &nbsp;或 'cstdlib' 库中的 'exit()' 函数 [MISRA2004-20_11_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-20_11_c.html">不得使用 'stdlib.h' 或 'cstdlib' 库中的 'getenv()' 函数 [MISRA2004-20_11_c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-20_11_d.html">不得使用 'stdlib.h' 或 'cstdlib' 库中的 'system()' 函数 [MISRA2004-20_11_d-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-20_12.html">禁止使用库文件 time.h 中的时间处理库函数 [MISRA2004-20_12-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-20_1_a.html">不要使用以下划线开头的带有#define 或 #undef 名称的标识符 [MISRA2004-20_1_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-20_1_b.html">不要重新定义保留字 [MISRA2004-20_1_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-20_1_c.html">在标准程序库中的保留标识符，宏以及函数不应该被定义，重定义或取消定义（C90代码 [MISRA2004-20_1_c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-20_1_e.html">不要#define也不要#undef '已定义'的标识 [MISRA2004-20_1_e-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-20_2.html">标准库宏、对象和函数的名称不应该被重用 [MISRA2004-20_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-20_2_a.html">不应该重复使用标准库中的宏，对象和函数(C90) [MISRA2004-20_2_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-20_2_b.html">标准库宏，对象和函数的名称不得重复使用（C99） [MISRA2004-20_2_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-20_3.html">应检查传递给库函数的值的有效性 [MISRA2004-20_3-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-20_4.html">禁止使用动态内存分配 [MISRA2004-20_4-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-20_5.html">不得使用错误指示 'errno' [MISRA2004-20_5-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-20_6.html">不应该使用库文件 stddef.h 中的 offsetof 宏 [MISRA2004-20_6-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-20_7.html">不使用 setjmp 宏和 longjmp 函数 [MISRA2004-20_7-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-20_7_b.html">不要使用标准头文件 &lt;setjmp.h&gt; [MISRA2004-20_7_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-20_8.html">禁止使用标准库文件 &lt;signal.h&gt; 中的处理函数 [MISRA2004-20_8-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-20_8_b.html">禁止使用信号处理文件 &lt;signal.h&gt; 中的处理函数 [MISRA2004-20_8_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-20_9.html">禁止使用库文件 stdio.h 中的输入/输出函数 [MISRA2004-20_9-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-2_1.html">汇编代码应该是封装且独立的 [MISRA2004-2_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-2_2.html">源代码只能使用 /* ... */ 来注释 [MISRA2004-2_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-2_3.html">禁止在 C 语言风格的注释中使用 /* 字符序列 [MISRA2004-2_3-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-2_4.html">代码段不应该被“注释掉” [MISRA2004-2_4-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-3_4.html">使用 #pragma 语句必须进行说明 [MISRA2004-3_4-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-3_5.html">不要把位域和其他数据混合在同一个结构体里 [MISRA2004-3_5-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-4_1.html">应只使用 ISO C 标准中定义的转义字符 [MISRA2004-4_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-4_2.html">禁止使用三字母词 [MISRA2004-4_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-5_1.html">标识符的长度不能超过 31 个字符 [MISRA2004-5_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-5_2_a.html">在局部或者函数原型体范围内声明的标识符不应该隐藏一个在全局或者命名空间范围内声明的标识符 [MISRA2004-5_2_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-5_2_b.html">在内层的局部范围内声明的标识符不应该隐藏在外层的局部范围内声明的标识符 [MISRA2004-5_2_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-5_3_a.html">不能重用 typedef 名称 [MISRA2004-5_3_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-5_3_b.html">不能将 typedef 的名称重用在另一个 typedef 名称 [MISRA2004-5_3_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-5_4_a.html">在程序中标记(tag)的名称不得重用于其它目的 [MISRA2004-5_4_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-5_4_b.html">标记(tag)的名称不得被重用于定义一个不同的标号 [MISRA2004-5_4_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-5_4_c.html">typedef 的名称不应该与 typdef 指定的类型名称相同 [MISRA2004-5_4_c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-5_5_a.html">禁止重用静态存储周期的对象或函数的标识符 [MISRA2004-5_5_a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-5_5_b.html">禁止重用静态存储周期的对象或函数的标识符 [MISRA2004-5_5_b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-5_6.html">除结构和联合成员名字外，一个命名空间内的标识符不能与另一个命名空间里面的标识符重名 [MISRA2004-5_6-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-5_7.html">禁止重用标识符名称 [MISRA2004-5_7-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-6_1.html">普通字符(plain char)类型只能用于存储和使用字符值 [MISRA2004-6_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-6_2.html">带符号的 char 和 不带符号的 char 类型只能用于存储和数值类型 [MISRA2004-6_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-6_3.html">用 typedef 定义基本类型应该在名称中包含数字 [MISRA2004-6_3-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-6_3_b.html">typedefs 应该被用于替代基本类型 [MISRA2004-6_3_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-6_4.html">只能将位域定义为有符号的整型或无符号的整型 [MISRA2004-6_4-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-6_5.html">具有带符号的整数类型且已命名的位域应该有超过一位的长度 [MISRA2004-6_5-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-6_5_a.html">signed整数型的未命名位域的长度应大于1bit [MISRA2004-6_5_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-7_1_a.html">不应该使用八进制常数（除零外） [MISRA2004-7_1_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-7_1_b.html">八进制转义序列不应该被使用 [MISRA2004-7_1_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-8_10.html">具有外部链接的对象或函数应该在头文件中声明 [MISRA2004-8_10-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-8_11.html">静态存储类说明符应该用于具有内部链接的对象和函数的定义和声明 [MISRA2004-8_11-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-8_12.html">当数组声明具有外部链接，其大小应该显式地说明或者在初始化时隐性地定义 [MISRA2004-8_12-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-8_1_a.html">函数应该有函数原型并且该原型应该对函数定义和调用可见 [MISRA2004-8_1_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-8_1_b.html">在函数调用时，函数总是有可见的原型 [MISRA2004-8_1_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-8_2_a.html">声明或定义某个函数时，必须显式地规定其类型 [MISRA2004-8_2_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-8_2_b.html">声明或定义某个对象时，必须显式地规定其类型 [MISRA2004-8_2_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-8_3_a.html">在声明和定义中使用相同的类型 [MISRA2004-8_3_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-8_3_b.html">函数的声明与原型的类型必须一致 [MISRA2004-8_3_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-8_4.html">如果对象或者函数被声明了一次以上，那么他们的类型应该是兼容的 [MISRA2004-8_4-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-8_5.html">在头文件中不应定义函数和对象 [MISRA2004-8_5-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-8_6.html">在文件的范围内声明函数 [MISRA2004-8_6-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-8_7.html">如果对象只在一个单独的函数中访问那么应定义其在代码块范围 [MISRA2004-8_7-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-9_1.html">所有自动变量在使用之前都必须被赋值 [MISRA2004-9_1-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-9_2.html">聚合体和共同体的初始化对象应该用大括号括起来 [MISRA2004-9_2-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-9_2_b.html">数组不应该部分初始化 [MISRA2004-9_2_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-9_2_c.html">结构的非零初始化要求每个元素都有显示初始化器 [MISRA2004-9_2_c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2004-9_3.html">在枚举类型中，要么仅对第一个元素进行显式地初始化，要么所有元素都进行显式的初始化 [MISRA2004-9_3-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008.html">MISRA C++ 2008 [MISRA2008]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_10.html">每个被定义的函数应该至少被调用一次 [MISRA2008-0_1_10-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_10_b.html">每个定义的具有外部连接的函数应该被使用 [MISRA2008-0_1_10_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_11.html">在非虚函数中不得存在没有被使用的参数（命名的和未命名的） [MISRA2008-0_1_11-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_12.html">在虚函数和覆盖它的所有函数中参数集合中应该没有未使用的参数(命名的或未命名的) [MISRA2008-0_1_12-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_1_a.html">项目不得在 else 模块中包含不能到执行到的代码 [MISRA2008-0_1_1_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_1_b.html">项目不得在 return, break, continue 和 goto 语句之后包含不能执行到的代码 [MISRA2008-0_1_1_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_1_c.html">项目不得在 if/else/while/for 模块中包含不能执行到的代码 [MISRA2008-0_1_1_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_1_d.html">项目不得在 switch 语句中包含不能执行到的代码 [MISRA2008-0_1_1_d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_1_e.html">项目不得在 for 循环中包含不能执行到的代码 [MISRA2008-0_1_1_e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_1_f.html">项目不得在 for/while/catch 模块外部的 if 或 switch 之后包含不能执行到的代码 [MISRA2008-0_1_1_f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_1_g.html">项目不得在 while/for/catch 模块内部的 if 或 switch 之后包含不能执行到的代码 [MISRA2008-0_1_1_g-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_2_a.html">项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_2_b.html">项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_2_c.html">项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_2_d.html">项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_2_e.html">项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_2_f.html">项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_2_g.html">项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_g-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_2_h.html">项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_h-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_2_i.html">项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_i-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_2_j.html">项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_j-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_2_k.html">项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_k-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_2_l.html">项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_l-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_2_m.html">项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_m-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_2_n.html">项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_n-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_2_o.html">项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_o-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_2_p.html">项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_p-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_2_q.html">项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_q-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_2_r.html">项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_r-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_2_rz.html">项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_rz-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_2_s.html">项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_s-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_2_sz.html">项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_sz-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_2_t.html">项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_t-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_2_u.html">项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_u-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_2_v.html">项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_v-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_2_w.html">项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_w-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_2_x.html">项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_x-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_2_y.html">项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_y-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_2_z.html">项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_z-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_3_a.html">项目中不得包含未使用的变量 [MISRA2008-0_1_3_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_3_b.html">项目中不得包含未使用的变量 [MISRA2008-0_1_3_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_4.html">项目不应包含只有一个用途的非 volatile POD变量 [MISRA2008-0_1_4-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_5.html">项目不应包含未使用的类型声明 [MISRA2008-0_1_5-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_6.html">避免未使用的值 [MISRA2008-0_1_6-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_7.html">从不是重载运算符函数得到的非 void 类型的返回值应该始终被使用 [MISRA2008-0_1_7-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_8.html">所有 void 返回类型的函数应该有外部的作用 [MISRA2008-0_1_8-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_8_b.html">所有具有 void 返回类型的函数应该具有外部副作用 [MISRA2008-0_1_8_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_1_9.html">所有非空语句至少有一个附带作用，要么无论如何被执行到要么导致控制流发生变化 [MISRA2008-0_1_9-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_2_1_a.html">对象不能被指定给一个重叠的对象 [MISRA2008-0_2_1_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_2_1_b.html">对象不能被指定给一个重叠的对象 [MISRA2008-0_2_1_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_3_1_a.html">避免访问数组越界 [MISRA2008-0_3_1_a-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_3_1_b.html">避免空指针引用 [MISRA2008-0_3_1_b-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_3_1_c.html">避免除零错误 [MISRA2008-0_3_1_c-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_3_1_d.html">避免由于定义不正确的格式限制导致的缓冲区溢出 [MISRA2008-0_3_1_d-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_3_1_e.html">避免由于读取非零终止字符串导致的溢出 [MISRA2008-0_3_1_e-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_3_1_f.html">取消引用后不检查空值 [MISRA2008-0_3_1_f-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_3_1_g.html">避免在读取缓冲区时溢出 [MISRA2008-0_3_1_g-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_3_1_h.html">避免在写入缓冲区时溢出 [MISRA2008-0_3_1_h-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_3_1_i.html">指针算法只适用于指向数组或数组元素地址的指针 [MISRA2008-0_3_1_i-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_3_1_j.html">&gt;, &gt;=, &lt;, &lt;= 不应作用于指针类型的对象，除非它们指向相同的数组 [MISRA2008-0_3_1_j-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_3_2.html">如果一个函数生成错误信息，那么这个错误信息应该被测试 [MISRA2008-0_3_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-0_4_2.html">使用浮点型算法应该被注释说明 [MISRA2008-0_4_2-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-10_1_1.html">类不得从虚类派生而来 [MISRA2008-10_1_1-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-10_1_2.html">基类只有在菱形继承层级中使用时才会被声明为虚类 [MISRA2008-10_1_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-10_1_3.html">能够访问的基础类在同一个层级中不得既是虚类又是非虚类 [MISRA2008-10_1_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-10_2_1.html">多个继承层次结构中的所有可访问实体名称都应该是惟一的 [MISRA2008-10_2_1-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-10_3_1.html">在通过继承层级的各条路径上每个虚函数不得有多于一个的定义 [MISRA2008-10_3_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-10_3_2.html">每个覆盖的虚函数应该被声明有虚拟关键字 [MISRA2008-10_3_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-10_3_3.html">如果一个虚函数本身被声明为纯虚函数，那它只能被纯虚函数所覆盖 [MISRA2008-10_3_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-11_0_1.html">非 POD 类的成员数据应该是私有的 [MISRA2008-11_0_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-12_1_1.html">对象的动态类型不能够从它的构造函数和析构函数的函数体中使用 [MISRA2008-12_1_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-12_1_2.html">一个类的所有构造函数应该显式地为它的所有直接基类和所有虚基类调用一个构造函数 [MISRA2008-12_1_2-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-12_1_3.html">能够通过单一基本类型实参调用的所有构造函数应该显式地被声明 [MISRA2008-12_1_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-12_8_1.html">拷贝构造函数应该只初始化它的基类和自身是类成员的非静态成员 [MISRA2008-12_8_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-12_8_2.html">在抽象类中拷贝赋值运算符应该被声明为受保护的或私有的 [MISRA2008-12_8_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-14_5_1.html">在相关命名空间中不得声明非成员通用函数 [MISRA2008-14_5_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-14_5_2.html">当存在一个包含单个泛型参数的模板构造函数时，拷贝构造函数应该被声明 [MISRA2008-14_5_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-14_5_3.html">当存在一个包含泛型参数的模板赋值运算符时，拷贝赋值运算符应该被声明 &nbsp;[MISRA2008-14_5_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-14_6_1.html">在含有依赖基础的类模板中，任何可能在这个依赖类中被发现的名称都应该引用使用限定标识或 -&gt; [MISRA2008-14_6_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-14_6_2.html">函数应该解析为在编译单元前面中声明的函数 [MISRA2008-14_6_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-14_7_1.html">所有的类模板、函数模板、类模板成员函数和类模板静态成员都应该被实例化至少一次 [MISRA2008-14_7_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-14_7_3.html">一个模板的所有局部和显式的特化应该在它们原始模板的同一个文件中被定义 [MISRA2008-14_7_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-14_8_1.html">重载函数模板不得显式地特化 [MISRA2008-14_8_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-14_8_2.html">函数调用的可行函数集合应该要么不包括函数特化，要么只包括函数特化 [MISRA2008-14_8_2-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-15_0_2.html">一个例外对象不得有指针类型 [MISRA2008-15_0_2-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-15_0_3.html">不得使用 goto 或 switch 开关语句将控制传递到 try 或 catch 模块中 [MISRA2008-15_0_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-15_1_1.html">throw 语句的赋值表达式不得自身引起一个异常抛出 [MISRA2008-15_1_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-15_1_2.html">NULL 不得被显式地抛出 [MISRA2008-15_1_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-15_1_3.html">null 的抛出 (throw;) 应该只用于 catch 处理程序的复合语句中 [MISRA2008-15_1_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-15_3_1.html">应该只能在程序启动之后和终止之前引起异常 [MISRA2008-15_3_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-15_3_2.html">应该至少有一个异常处理程序来捕获所有其他未处理的异常 [MISRA2008-15_3_2-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-15_3_3.html">类的构造函数或析构函数中执行 try 功能模块的处理程序不得引用来自此类或其基础类的非静态成员 [MISRA2008-15_3_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-15_3_4_a.html">代码中显式地抛出的每个异常应该在可能导致这一点的所有调用路径上存在兼容类型的处理程序 [MISRA2008-15_3_4_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-15_3_4_b.html">代码中显式地抛出的每个异常应该在可能导致这一点的所有调用路径上存在兼容类型的处理程序 [MISRA2008-15_3_4_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-15_3_5.html">类类型的异常应该始终被引用捕获 [MISRA2008-15_3_5-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-15_3_6.html">如果在单独的 try-catch 语句或 try 功能模块中提供多个处理程序给派生类和部分或全部的基类时，这些处理程序应该遵循从最底层的派生类到基类的顺序。 [MISRA2008-15_3_6-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-15_3_7.html">如果在一个 try-catch 语句或 function-try-block 中提供多个处理程序，那么任何省略号（catch-all）处理程序都应最后执行 [MISRA2008-15_3_7-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-15_4_1.html">如果一个函数被声明为包含异常规范，那么同一个函数的所有声明(在其他编译单元中)将使用相同的类型 id 声明 [MISRA2008-15_4_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-15_5_1.html">类的析构函数不得带有异常退出 [MISRA2008-15_5_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-15_5_2.html">如果一个函数的声明包括一个异常规范，这个函数应该只能抛出所指明类型的异常。 [MISRA2008-15_5_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-15_5_2_b.html">避免从声明为不抛出异常的函数中抛出异常 [MISRA2008-15_5_2_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-15_5_3.html">注册为 'std::atexit()' 或 'std::at_quick_exit()' 的函数的执行不应该通过异常退出 [MISRA2008-15_5_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-15_5_3_b.html">绝不允许从析构函数, 释放和交换抛出异常 [MISRA2008-15_5_3_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-15_5_3_c.html">不要从析构函数中抛出 [MISRA2008-15_5_3_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-15_5_3_d.html">至少应该有一个异常处理程序来捕获所有其他未处理的异常 [MISRA2008-15_5_3_d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-15_5_3_e.html">空抛出 (throw;) 只能用于 catch 处理程序的复合语句中 [MISRA2008-15_5_3_e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-15_5_3_f.html">只有在程序启动后和终止前才应该抛出异常 [MISRA2008-15_5_3_f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-15_5_3_g.html">每个在代码中显式地抛出的异常都应该在所有可能导致这一点的调用路径中有一个兼容类型的处理程序 [MISRA2008-15_5_3_g-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-15_5_3_h.html">如果函数的声明包含异常规范，则该函数只能抛出指定类型的异常 [MISRA2008-15_5_3_h-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-15_5_3_i.html">在全局或命名空间作用域中调用的函数不能抛出未处理的异常 [MISRA2008-15_5_3_i-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-15_5_3_j.html">始终捕获异常 [MISRA2008-15_5_3_j-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-15_5_3_k.html">正确定义退出处理程序 [MISRA2008-15_5_3_k-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-15_5_3_l.html">避免从声明为不抛出异常的函数中抛出异常 [MISRA2008-15_5_3_l-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-16_0_1.html">文件中的 #include 指示符应该只能在其他预处理指令或注释之前 [MISRA2008-16_0_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-16_0_2.html">应该只能在全局的命名空间中使用 #define 或 #undef 宏 [MISRA2008-16_0_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-16_0_3.html">不得使用 #undef [MISRA2008-16_0_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-16_0_4.html">不得定义类函数宏 [MISRA2008-16_0_4-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-16_0_5.html">传递给类函数宏的实参不得包括看起来像预处理指令的符号 [MISRA2008-16_0_5-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-16_0_6.html">在类函数宏的定义中，每个参数的实例应该置于括号内，除非它是作为 # 或 ## 的操作数 [MISRA2008-16_0_6-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-16_0_7_b.html">不要使用在编译单元中未定义的预编译器指令 #if 和 #elif &nbsp;宏 [MISRA2008-16_0_7_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-16_0_8.html">如果符号 # 作为一行的第一个符号出现，那么预处理符号应该紧接着 [MISRA2008-16_0_8-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-16_1_1.html">defined 预处理运算符应该只能用于两个标准形式之一 [MISRA2008-16_1_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-16_1_2.html">所有的 #else, #elif 和 #endif 预处理指令应该存在于和 #if 或 #ifdef 指示符相关的相同文件中 [MISRA2008-16_1_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-16_2_1_a.html">不得使用宏 [MISRA2008-16_2_1_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-16_2_1_b.html">#ifndef 和 #endif 预处理指令将仅用于防止重复地包含相同的头文件 [MISRA2008-16_2_1_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-16_2_1_c.html">以下的预处理器指令不得使用: #if, #elif, #else, #ifdef, #undef, #pragma [MISRA2008-16_2_1_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-16_2_2.html">C++ 宏应该只能用于: 包含保护，类型修饰符，或存储类限定符 [MISRA2008-16_2_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-16_2_3.html">应该提供包含保护 [MISRA2008-16_2_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-16_2_4.html">字符 ', ", /* 或 // 不得出现在头文件的名称中 [MISRA2008-16_2_4-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-16_2_5.html">字符 \ 不得出现在头文件的名称中 [MISRA2008-16_2_5-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-16_2_6.html">包含 #include 指令应该遵循要么是 &lt;filename&gt; 要么是 "filename" 序列 [MISRA2008-16_2_6-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-16_3_1.html">在单个的宏定义中应该最多出现一个 # 或 ## 操作符 [MISRA2008-16_3_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-16_3_2.html">不得使用 # 和 ## 操作符 [MISRA2008-16_3_2-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-16_6_1.html">所有使用 #pragma 指示符应该被注释说明 [MISRA2008-16_6_1-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-17_0_1_a.html">不得定义，重定义或取消定义标准库中的保留标识符，宏和函数 [MISRA2008-17_0_1_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-17_0_1_b.html">不得定义，重定义或取消定义标准库中的保留标识符，宏和函数 [MISRA2008-17_0_1_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-17_0_1_c.html">不得定义，重定义或取消定义标准库中的保留标识符，宏和函数 [MISRA2008-17_0_1_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-17_0_1_d.html">不得定义，重定义或取消定义标准库中的保留标识符，宏和函数 [MISRA2008-17_0_1_d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-17_0_1_e.html">不得定义，重定义或取消定义标准库中的保留标识符，宏和函数 [MISRA2008-17_0_1_e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-17_0_2.html">不得重复使用标准库宏和对象的名称 [MISRA2008-17_0_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-17_0_3.html">不得覆盖标准库宏和对象的名称 [MISRA2008-17_0_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-17_0_5.html">不得使用 setjmp 宏和 longjmp 函数 [MISRA2008-17_0_5-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-17_0_5_b.html">不得使用标准数据头文件 &lt;setjmp.h&gt; [MISRA2008-17_0_5_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-18_0_1.html">不得使用 C 语言库 [MISRA2008-18_0_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-18_0_2.html">不得使用来自于 &lt;cstdlib&gt; 库的 atof, atoi 和 atol 库函数 [MISRA2008-18_0_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-18_0_3.html">不得使用 &lt;stdlib.h&gt; 的 'abort' 库函数 [MISRA2008-18_0_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-18_0_3_b.html">不得使用 &lt;stdlib.h&gt; 的 'exit' 库函数 [MISRA2008-18_0_3_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-18_0_3_c.html">不得使用 &lt;stdlib.h&gt; 的 'getenv' 库函数 [MISRA2008-18_0_3_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-18_0_3_d.html">不得使用 &lt;stdlib.h&gt; 的 'system' 库函数 [MISRA2008-18_0_3_d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-18_0_4.html">不得使用 &lt;ctime&gt; 库的时间处理函数 [MISRA2008-18_0_4-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-18_0_5.html">不得使用 &lt;cstring&gt; 库的无限制函数 [MISRA2008-18_0_5-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-18_2_1.html">不得使用 offsetof 宏 [MISRA2008-18_2_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-18_4_1.html">不得使用动态堆内存分配 [MISRA2008-18_4_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-18_7_1.html">不得使用 &lt;csignal&gt; 库的信号处理功能 [MISRA2008-18_7_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-18_7_1_b.html">不得使用信号处理条件文件 &lt;csignal&gt; 中的处理函数 [MISRA2008-18_7_1_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-19_3_1.html">不得使用 errno 错误标识 [MISRA2008-19_3_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-27_0_1.html">不得使用 &lt;cstdio&gt; 库的输入/输出流 [MISRA2008-27_0_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-2_10_1.html">不同的标识符应该是外观上可以清晰区别的 [MISRA2008-2_10_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-2_10_2_a.html">声明在内部范围的标识符不得掩盖声明在外部范围的标识符 [MISRA2008-2_10_2_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-2_10_2_b.html">声明在内部范围的标识符不得掩盖声明在外部范围的标识符 [MISRA2008-2_10_2_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-2_10_3.html">typedef 的名称 (如果有其他修饰符，也包括) 应该是一个唯一的标识符 [MISRA2008-2_10_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-2_10_4.html">类，联合体，枚举型名称 (如果有其他修饰符，也包括) 应该是一个唯一的标识符 [MISRA2008-2_10_4-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-2_10_5_a.html">非成员对象或具有静态存储期的函数的标识符名称不得被重复使用 [MISRA2008-2_10_5_a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-2_10_5_b.html">非成员对象或具有静态存储期的函数的标识符名称不得被重复使用 [MISRA2008-2_10_5_b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-2_10_6_a.html">如果一个标识符指向一个类型，它不得再指向在同一个范围内的一个对象或函数 [MISRA2008-2_10_6_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-2_10_6_b.html">如果一个标识符指向一个类型，它不得再指向在同一个范围内的一个对象或函数 [MISRA2008-2_10_6_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-2_10_6_c.html">如果一个标识符指向一个类型，它不得再指向在同一个范围内的一个对象或函数 [MISRA2008-2_10_6_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-2_10_6_d.html">typedef 的名称不应该与其基本类型的名称相同 [MISRA2008-2_10_6_d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-2_13_1.html">只得使用那些定义在 ISO/IEC 14882:2003 中的转义序列 [MISRA2008-2_13_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-2_13_2_a.html">不得使用八进制字面量(除了零) [MISRA2008-2_13_2_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-2_13_2_b.html">不得使用八进制转义序列(除了 "\0") [MISRA2008-2_13_2_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-2_13_3.html">后缀 "U" 应该适用于所有无符号类型的八进制或十六进制整型字面量 [MISRA2008-2_13_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-2_13_4.html">字面量后缀应该是大写 [MISRA2008-2_13_4-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-2_13_5.html">不得级联狭义的和广义的字符串字面量 [MISRA2008-2_13_5-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-2_3_1.html">不得使用三元字符 [MISRA2008-2_3_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-2_5_1.html">不得使用二元字符 [MISRA2008-2_5_1-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-2_7_1.html">字符序列 /* 不得被用于 C 语言风格的注释中 [MISRA2008-2_7_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-2_7_2.html">代码部分不得使用 C 语言风格的注释 "添加注释 " [MISRA2008-2_7_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-2_7_3.html">代码部分不得使用 C++ 语言风格的注释 "添加注释 " [MISRA2008-2_7_3-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-3_1_1.html">应该尽可能包含在多个不违反单定义规则的编译单元的任何头文件 [MISRA2008-3_1_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-3_1_2.html">函数不得声明在语句块范围内 [MISRA2008-3_1_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-3_1_3.html">当一个数组被声明的时候，其大小应该被显式地指定或通过初始化隐式地定义 [MISRA2008-3_1_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-3_2_1.html">一个对象或函数的所有声明都应该具有兼容的类型 [MISRA2008-3_2_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-3_2_2.html">单定义规则不应被违反 [MISRA2008-3_2_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-3_2_3.html">在多个编译单元中使用的类型、对象或函数应该只在一个文件中声明 [MISRA2008-3_2_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-3_2_4.html">具有外部链接的标识符应该只有一个外部定义 [MISRA2008-3_2_4-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-3_3_1.html">具有外部链接的对象或函数应该被定义在头文件中 [MISRA2008-3_3_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-3_3_2.html">如果一个函数有内部链接，那么所有的再声明应该包括静态存储类限定符 [MISRA2008-3_3_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-3_4_1_a.html">声明为一个对象或类型的标识符应该定义在一个模块中，以最小化其可见性 [MISRA2008-3_4_1_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-3_4_1_b.html">声明为一个对象或类型的标识符应该定义在一个模块中，以最小化其可见性 [MISRA2008-3_4_1_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-3_9_1.html">作为对象，函数返回类型，或函数参数使用的类型在所有定义和再定义中字符应该相同 [MISRA2008-3_9_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-3_9_2.html">指定大小和符号属性的 typedef 应该用来代替基本数值类型 [MISRA2008-3_9_2-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-3_9_3.html">不得使用表示浮点型的原始位 [MISRA2008-3_9_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-4_10_1.html">NULL 不得用作一个整型值 [MISRA2008-4_10_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-4_10_2.html">字面量零 (0) 不得用作空指针常量 [MISRA2008-4_10_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-4_5_1.html">布尔类型的表达式不得用作除了赋值运算符 = ，逻辑运算符 &amp;&amp;, ||, ! ，等号运算符 == 和 != ，一元 &amp; 运算符和条件运算符以外的内置运算符的操作数 [MISRA2008-4_5_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-4_5_2.html">枚举类型的表达式不得用作除了 [ ], =, &nbsp;==, !=, &lt;, &lt;=, &gt;, &gt;=, 和一元 &amp; 运算符以外的内置运算符的操作数 [MISRA2008-4_5_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-4_5_3.html">普通的 char 类型和 wchar_t 型的表达式不得用作除了赋值运算符 = ， 等号运算符 == 和 !=， 一元 &amp; 运算符以外的内置运算符的操作数 [MISRA2008-4_5_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_10.html">如果按位运算符 ~ 和 &lt;&lt; 适用于无符号字符型或无符号短整型的操作数，其结果应该立即强制转换成相应的原始类型 [MISRA2008-5_0_10-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_11.html">普通的 char 类型应该只能用于字符值的存储和使用 [MISRA2008-5_0_11-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_12.html">signed char 和 unsigned char 类型应该只能用于数值的存储和使用 [MISRA2008-5_0_12-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_13.html">if 语句的条件和迭代语句的条件应该是布尔类型 [MISRA2008-5_0_13-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_14.html">条件运算符的第一个操作数应该是布尔类型 [MISRA2008-5_0_14-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_15.html">数组索引应该是指针运算的唯一形式 [MISRA2008-5_0_15-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_16_a.html">避免访问数组越界 [MISRA2008-5_0_16_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_16_b.html">一个指针操作数和使用该操作数的指针算法所产生的任何指针都应该指向同一个数组的元素地址 [MISRA2008-5_0_16_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_17.html">指针之间的减法操作应该只能适用于指向相同数组元素的指针 [MISRA2008-5_0_17-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_18.html">&gt;, &gt;=, &lt;, &lt;= 不得适用于指针类型的对象，除非它们指向同一个数组 [MISRA2008-5_0_18-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_19.html">对象的声明应该包含不超过二级的指针间接寻址 [MISRA2008-5_0_19-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_1_a.html">表达式的值在标准允许的任何计算顺序下应该相同 [MISRA2008-5_0_1_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_1_b.html">表达式的值在标准允许的任何计算顺序下应该相同 [MISRA2008-5_0_1_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_1_c.html">表达式的值在标准允许的任何计算顺序下应该相同 [MISRA2008-5_0_1_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_1_d.html">表达式的值在标准允许的任何计算顺序下应该相同 [MISRA2008-5_0_1_d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_1_e.html">表达式的值在标准允许的任何计算顺序下应该相同 [MISRA2008-5_0_1_e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_1_f.html">表达式的值在标准允许的任何计算顺序下应该相同 [MISRA2008-5_0_1_f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_1_g.html">表达式的值在标准允许的任何计算顺序下应该相同 [MISRA2008-5_0_1_g-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_20.html">二进制位运算符的非常量的操作数应该具有相同的原始类型 [MISRA2008-5_0_20-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_21.html">位运算符应该只能适用于无符号原始类型的操作数 [MISRA2008-5_0_21-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_2_a.html">限制依赖 C++ 语言表达式中的运算符优先级规则 [MISRA2008-5_0_2_a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_2_b.html">限制依赖 C++ 语言表达式中的运算符优先级规则 [MISRA2008-5_0_2_b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_2_c.html">限制依赖 C++ 语言表达式中的运算符优先级规则 [MISRA2008-5_0_2_c-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_2_d.html">限制依赖 C++ 语言表达式中的运算符优先级规则 [MISRA2008-5_0_2_d-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_2_e.html">限制依赖 C++ 语言表达式中的运算符优先级规则 [MISRA2008-5_0_2_e-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_2_f.html">限制依赖 C++ 语言表达式中的运算符优先级规则 [MISRA2008-5_0_2_f-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_3_a.html">cvalue 表达式不得隐式地转换成不同的原始类型 [MISRA2008-5_0_3_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_3_b.html">cvalue 表达式不得隐式地转换成不同的原始类型 [MISRA2008-5_0_3_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_3_c.html">cvalue 表达式不得隐式地转换成不同的原始类型 [MISRA2008-5_0_3_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_4_a.html">整型的隐式转换不得改变原始类型的符号属性 [MISRA2008-5_0_4_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_4_b.html">整型的隐式转换不得改变原始类型的符号属性 [MISRA2008-5_0_4_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_5_a.html">不得有浮点型-整型的隐式转换 [MISRA2008-5_0_5_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_5_b.html">不得有浮点型-整型的隐式转换 [MISRA2008-5_0_5_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_6_a.html">整型或浮点型的隐式转换不得减少原始类型的长度 [MISRA2008-5_0_6_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_6_b.html">整型或浮点型的隐式转换不得减少原始类型的长度 [MISRA2008-5_0_6_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_6_c.html">整型或浮点型的隐式转换不得减少原始类型的长度 [MISRA2008-5_0_6_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_7_a.html">cvalue 表达式不得有显式地浮点型-整型转换 [MISRA2008-5_0_7_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_7_b.html">cvalue 表达式不得有显式地浮点型-整型转换 [MISRA2008-5_0_7_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_8.html">整型或浮点型的显式转换不得增加 cvalue 表达式的原始类型的长度 [MISRA2008-5_0_8-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_0_9.html">整型或浮点型的显式转换不得增加 cvalue 表达式的原始类型的长度 [MISRA2008-5_0_9-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_14_1.html">逻辑运算符 &amp;&amp; 或 || 的右边操作数不得包含副作用 [MISRA2008-5_14_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_17_1.html">重载的二元运算符应该用相应的复合赋值运算符来实现 [MISRA2008-5_17_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_18_1.html">不得使用逗号操作符 [MISRA2008-5_18_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_19_1_a.html">在 '+', '-', '*' 操作符的常量表达式中发生整数溢出或下溢 [MISRA2008-5_19_1_a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_19_1_b.html">在 '&lt;&lt;' 操作符的常量表达式中发生整数溢出或下溢 [MISRA2008-5_19_1_b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_2_1.html">逻辑运算符 &amp;&amp; 或 || 的每个操作数应该都是后缀表达式 [MISRA2008-5_2_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_2_10.html">递加 (++) 和递减 (--) 运算符不得在表达式中和其他运算符混合使用 [MISRA2008-5_2_10-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_2_11.html">&amp;&amp; 运算符和 || 运算符不得被重载 [MISRA2008-5_2_11-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_2_11_b.html">逗号 "," 运算符不得被重载 [MISRA2008-5_2_11_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_2_12.html">作为函数实参传递的数组类型标识符不得退化为一个指针 [MISRA2008-5_2_12-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_2_2.html">指向虚基类的指针应该只能通过 dynamic_cast 的方式强制类型转换为指向派生类的指针 [MISRA2008-5_2_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_2_3.html">从基类到派生类的强制类型转换不得在多态类型上进行 [MISRA2008-5_2_3-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_2_4.html">不得使用 C 语言风格的强制类型转换(除 void 强制类型转换)和函数符号式强制类型转换(除了显式的构造函数调用) [MISRA2008-5_2_4-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_2_5.html">强制类型转换不得从指针或引用类型中移除任何 const 或 volatile 的修饰 [MISRA2008-5_2_5-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_2_6.html">强制类型转换不得转换指向函数的指针为任何其他类型的指针，包括指向函数的指针 [MISRA2008-5_2_6-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_2_7.html">一个指针类型的对象不得直接或间接地被转换为无关的指针类型 [MISRA2008-5_2_7-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_2_8.html">整数类型的对象或指向 void 类型的指针的对象不得被转换为指针类型的对象 [MISRA2008-5_2_8-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_2_9.html">强制类型转换不得转换一个指针类型为整型 [MISRA2008-5_2_9-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_3_1.html">! 运算符, 逻辑 &amp;&amp; 或逻辑 || 运算符的每个操作数应该都是布尔类型 [MISRA2008-5_3_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_3_2.html">一元减法运算符不得适用于其原始类型是无符号型的表达式 [MISRA2008-5_3_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_3_3.html">一元 &amp; 运算符不得被重载 [MISRA2008-5_3_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_3_4.html">sizeof 运算符的操作数求值不得包含副作用 [MISRA2008-5_3_4-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_3_4_b.html">sizeof 运算符的操作数求值不得包含副作用 [MISRA2008-5_3_4_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_3_4_c.html">sizeof 运算符的操作数求值不得包含副作用 [MISRA2008-5_3_4_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-5_8_1.html">移位运算符的右边操作数的位宽应该介于零和一个小于左操作数的原始类型的位宽之间 [MISRA2008-5_8_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-6_2_1.html">赋值运算符不得被用于子表达式 [MISRA2008-6_2_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-6_2_2.html">浮点表达式不得直接或间接地作为相等或不相等的判定 [MISRA2008-6_2_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-6_2_3.html">预处理之前，空语句应该只能独自地出现在一行上；它可能后接一个注释，但是紧接空语句的第一个字符应该是空格 [MISRA2008-6_2_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-6_3_1.html">构成 switch, while, do &nbsp;while 或者 for 语句体的语句应该是一个复合语句 [MISRA2008-6_3_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-6_4_1.html">if (条件) 结构应该后接一个复合语句。 else 关键字必须后接一个复合语句，或者另外的 if 语句 [MISRA2008-6_4_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-6_4_2.html">所有的 if ... else if 结构应该由 else 子句结束 [MISRA2008-6_4_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-6_4_3_a.html">switch 语句应该是一个格式规范的 switch 语句 [MISRA2008-6_4_3_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-6_4_3_b.html">switch 语句应该是一个格式规范的 switch 语句 [MISRA2008-6_4_3_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-6_4_3_c.html">switch 语句应该是一个格式规范的 switch 语句 [MISRA2008-6_4_3_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-6_4_3_d.html">switch 语句应该是一个格式规范的 switch 语句 [MISRA2008-6_4_3_d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-6_4_3_e.html">switch 语句应该是一个格式规范的 switch 语句 [MISRA2008-6_4_3_e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-6_4_4.html">switch-标签应该只能用在当紧接着的复合语句是 switch 语句体的时候 [MISRA2008-6_4_4-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-6_4_5.html">无条件的 throw 或 break 语句应该结束任何非 null 的 switch-子句 [MISRA2008-6_4_5-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-6_4_6.html">switch 语句的最后子句应该是 default-子句 [MISRA2008-6_4_6-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-6_4_7.html">switch 语句的条件不得含有布尔类型 [MISRA2008-6_4_7-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-6_4_8.html">每个 switch 语句应该至少有一个 case-子句 [MISRA2008-6_4_8-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-6_5_1.html">for 循环应该包含一个没有浮动类型的单一的循环计数器 [MISRA2008-6_5_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-6_5_2.html">如果循环计数器不是被 -- 或 ++ 修改，那么在条件中此循环计数器应该只能被用作 &lt;=, &lt;, &gt; or &gt;= 的操作数 [MISRA2008-6_5_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-6_5_3.html">循环计数器不得在判定条件或循环体语句中被修改 [MISRA2008-6_5_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-6_5_4.html">循环计数器应该被 --, ++, -=n, 或 +=n; 之一修改；这里的 n 在整个循环期间保持不变 [MISRA2008-6_5_4-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-6_5_5.html">循环计数器以外的循环控制变量不得在判定条件或运算表达式中被修改 [MISRA2008-6_5_5-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-6_5_6.html">在循环体语句中被修改的非循环计数器的循环控制变量应该是布尔类型的 [MISRA2008-6_5_6-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-6_6_1.html">任何 goto 语句引用的标签应该被声明在相同的块中，或在关闭 goto 语句的块中 [MISRA2008-6_6_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-6_6_2.html">goto 语句应该跳转到稍后在相同的函数体中声明的标签 [MISRA2008-6_6_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-6_6_3.html">continue 语句应该只能被用于一个格式规范的 for 循环中 [MISRA2008-6_6_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-6_6_4.html">对于任何迭代语句不得有超过一个用于循环终止的 break 或 goto 语句 [MISRA2008-6_6_4-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-6_6_5.html">一个函数应该在函数末尾有单一的出口点 [MISRA2008-6_6_5-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-7_1_1.html">一个不被修改的变量应该使用 const 限定 [MISRA2008-7_1_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-7_1_2_a.html">如果函数的指针参数对应的对象不被修改，那么应该被声明为指针常量 [MISRA2008-7_1_2_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-7_1_2_b.html">如果函数的引用参数对应的对象不被修改，那么应该被声明为引用常量 [MISRA2008-7_1_2_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-7_1_2_c.html">如果指针不用于修改指向地址的对象则声明参数的类型为 typedef 的 const 指针 [MISRA2008-7_1_2_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-7_2_1.html">包含潜在枚举类型的表达式只应该具有与枚举的枚举器对应的值 [MISRA2008-7_2_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-7_3_1.html">全局的命名空间应该只能包含 main，命名空间的声明和外部的 "C" 声明 [MISRA2008-7_3_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-7_3_2.html">标识符 main 不得用于除全局 main 函数以外的函数 [MISRA2008-7_3_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-7_3_3.html">在头文件中不得有不具名命名空间 [MISRA2008-7_3_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-7_3_4.html">不得使用 using-指示符 [MISRA2008-7_3_4-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-7_3_5.html">在同一个命名空间中标识符的多重声明不得跨越该标识符的 using-声明 [MISRA2008-7_3_5-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-7_3_6.html">在头文件中不得使用 using 指令和 using 声明(不包括类范围或函数范围的 using 声明) [MISRA2008-7_3_6-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-7_4_1.html">所有汇编程序的使用应该被注释说明 [MISRA2008-7_4_1-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-7_4_2.html">汇编指令应该只能使用 asm 声明来引入 [MISRA2008-7_4_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-7_4_3.html">汇编语言应该被封装和隔离 [MISRA2008-7_4_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-7_5_1.html">函数不得返回一个指向定义在函数中自动变量的引用或指针(包括参数) [MISRA2008-7_5_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-7_5_2_a.html">具有自动存储方式的对象的地址不得被赋值给在第一个对象已不复存在之后还持续存在的对象 [MISRA2008-7_5_2_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-7_5_2_b.html">具有自动存储方式的对象的地址不得被赋值给在第一个对象已不复存在之后还持续存在的对象 [MISRA2008-7_5_2_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-7_5_3.html">函数不得返回一个指向通过引用或 const 引用传递参数的引用或指针 [MISRA2008-7_5_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-7_5_4.html">函数不得调用它们本身，无论是直接或间接 [MISRA2008-7_5_4-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-8_0_1.html">初始声明列表或成员声明列表应该分别由单一的初始声明或成员声明组成 [MISRA2008-8_0_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-8_3_1.html">在覆盖的虚函数中的参数应该使用同他们所覆盖的函数一样缺省的实参，否则不得指定任何缺省实参 [MISRA2008-8_3_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-8_4_1.html">函数不得使用省略符号定义 [MISRA2008-8_4_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-8_4_2.html">用于参数的标识符在函数的重声明中应该和声明中的相同 [MISRA2008-8_4_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-8_4_3.html">非 void 返回类型函数的所有退出路径应该有显式表达式的返回语句 [MISRA2008-8_4_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-8_4_4.html">函数的标示符应该要么用来调用函数或者在使用时被放在 '&amp;'操作符后 [MISRA2008-8_4_4-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-8_5_1.html">所有变量在被使用之前应该有一个定义的值 [MISRA2008-8_5_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-8_5_2.html">括号应该被用于指明和匹配在数组和结构体的非零初始化中的结构 [MISRA2008-8_5_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-8_5_2_b.html">数组不应该被部分初始化 [MISRA2008-8_5_2_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-8_5_2_c.html">结构体不应该被部分初始化 [MISRA2008-8_5_2_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-8_5_3.html">在枚举成员列表中，不得使用 = 结构显式地初始化除第一个以外的成员，除非所有项目都显式地被初始化 [MISRA2008-8_5_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-9_3_1.html">const 成员函数不得返回指向类数据成员的非 const 指针或引用 [MISRA2008-9_3_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-9_3_2_a.html">受保护 (Protected)的成员函数不得返回指向类数据的非 const 句柄(指针或引用) [MISRA2008-9_3_2_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-9_3_2_b.html">public 成员函数不得返回指向类数据的非 const 句柄(指针或引用) [MISRA2008-9_3_2_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-9_3_3.html">如果一个成员函数可以是 static 的那么就应该定义为 static，否则如果它可以是 const 那么它应该被定义为 const [MISRA2008-9_3_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-9_5_1.html">不得使用联合体 (union) [MISRA2008-9_5_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-9_6_2.html">位域应该是布尔类型或者显式地 unsigned 或 signed 整型 [MISRA2008-9_6_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-9_6_3.html">位域不得有枚举类型 [MISRA2008-9_6_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2008-9_6_4.html">由 signed 整型命名的位域应该有超过一位的长度 [MISRA2008-9_6_4-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012.html">MISRA C 2012 (遗留) [MISRA2012]</a></b>
<ul>
<li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR.html">MISRA C 2012 指令 [MISRA2012-DIR]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_10.html">应采取预防措施,以防止头文件的内容被包含多次 [MISRA2012-DIR-4_10-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_11.html">验证传递给库函数的值 [MISRA2012-DIR-4_11-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_12.html">不应使用动态内存分配 [MISRA2012-DIR-4_12-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_13_a.html">所有通过标准库函数动态获取的资源都应明确释放 [MISRA2012-DIR-4_13_a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_13_b.html">不得使用已释放的资源 [MISRA2012-DIR-4_13_b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_13_c.html">不得使用无效指针释放资源 [MISRA2012-DIR-4_13_c-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_13_d.html">不得丢弃未释放的锁 [MISRA2012-DIR-4_13_d-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_13_e.html">避免双重锁定 [MISRA2012-DIR-4_13_e-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_14_a.html">避免数组索引中受污染的数据 [MISRA2012-DIR-4_14_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_14_b.html">防止受污染数据中整数的溢出/下溢 [MISRA2012-DIR-4_14_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_14_c.html">避免受污染数据的缓冲区读溢出 [MISRA2012-DIR-4_14_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_14_d.html">避免受污染数据的缓冲区写溢出 [MISRA2012-DIR-4_14_d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_14_e.html">防止命令注入 [MISRA2012-DIR-4_14_e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_14_f.html">防止文件名注入 [MISRA2012-DIR-4_14_f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_14_g.html">防止 SQL 注入 [MISRA2012-DIR-4_14_g-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_14_h.html">防止受污染数据的缓冲区溢出 [MISRA2012-DIR-4_14_h-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_14_i.html">由于定义了不正确的格式限制,避免受污染数据的缓冲区溢出 [MISRA2012-DIR-4_14_i-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_14_j.html">防止环境注入 [MISRA2012-DIR-4_14_j-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_14_k.html">避免在输出控制台中打印受污染的数据 [MISRA2012-DIR-4_14_k-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_14_l.html">从格式字符串中排除未经消毒的用户输入 [MISRA2012-DIR-4_14_l-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_1_a.html">避免访问数组越界 [MISRA2012-DIR-4_1_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_1_b.html">避免空指针解引用 [MISRA2012-DIR-4_1_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_1_c.html">避免除以零 [MISRA2012-DIR-4_1_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_1_d.html">避免因定义不正确的格式限制而导致缓冲区溢出 [MISRA2012-DIR-4_1_d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_1_e.html">避免因读取非零终止字符串而导致溢出 [MISRA2012-DIR-4_1_e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_1_f.html">解引用后不要检查空值 [MISRA2012-DIR-4_1_f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_1_g.html">读取缓冲区时,避免溢出 [MISRA2012-DIR-4_1_g-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_1_h.html">写入缓冲区时,避免溢出 [MISRA2012-DIR-4_1_h-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_1_i.html">指针运算只能应用于处理数组或数组元素的指针 [MISRA2012-DIR-4_1_i-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_1_j.html">&gt;, &gt;=, &lt;, &lt;= 不能应用于指针类型的对象,除非它们指向同一个数组 [MISRA2012-DIR-4_1_j-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_2.html">所有汇编语言的使用都应记录下来 [MISRA2012-DIR-4_2-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_3.html">汇编语言应该被封装和隔离 [MISRA2012-DIR-4_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_4.html">代码部分不应是 "添加注释" [MISRA2012-DIR-4_4-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_5.html">在具有重叠可见性的同一名称空间中,标识符应在字面上是无歧义的 [MISRA2012-DIR-4_5-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_6_a.html">应该在基本类型 typedef 的名称中包含一些数字 [MISRA2012-DIR-4_6_a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_6_b.html">typedef 应该被用来代替基本类型 [MISRA2012-DIR-4_6_b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_6_c.html">应使用 stdint.h 中的 typedef,而不是用在 C99代码中自己声明的 [MISRA2012-DIR-4_6_c-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_7_a.html">始终检查 non-void 函数的返回值 [MISRA2012-DIR-4_7_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_7_b.html">总是检查 non-void 函数的返回值 [MISRA2012-DIR-4_7_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_8.html">如果指向结构或联合的指针从未在编译单元中解引用,那么对象的实现就被应该隐藏起来 [MISRA2012-DIR-4_8-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-DIR-4_9.html">当可互换的时候,比起类函数宏, 应优先使用函数 [MISRA2012-DIR-4_9-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE.html">MISRA C 2012 规则 [MISRA2012-RULE]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-10_1_a.html">在将操作数解释为布尔值的地方，应该始终使用基本布尔类型的表达式 [MISRA2012-RULE-10_1_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-10_1_b.html">在将操作数解释为数值的情况下，不应该使用本质上为布尔类型的操作数 [MISRA2012-RULE-10_1_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-10_1_c.html">在将操作数解释为数值时，不应使用本质上为字符类型的操作数 [MISRA2012-RULE-10_1_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-10_1_d.html">算术运算不应该使用枚举类型的操作数 [MISRA2012-RULE-10_1_d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-10_1_e.html">不应该在有符号的操作数或枚举类型上执行移位和按位运算操作 [MISRA2012-RULE-10_1_e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-10_1_f.html">有符号或枚举类型的操作数不应该用作按位运算的右侧操作数 [MISRA2012-RULE-10_1_f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-10_1_g.html">本质上是无符号类型的操作数不应该用作一元减号运算符的操作数 [MISRA2012-RULE-10_1_g-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-10_2.html">在加法和减法运算中，基本字符类型的表达式不能使用不当 [MISRA2012-RULE-10_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-10_3_a.html">表达式的值不应赋给狭义的基本类型对象 [MISRA2012-RULE-10_3_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-10_3_b.html">表达式的值不应赋给不同基本类型类别的对象 [MISRA2012-RULE-10_3_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-10_4_a.html">执行通常的算术转换运算的两个操作数应具有相同的基本类型类别 [MISRA2012-RULE-10_4_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-10_4_b.html">三元运算符的第二和第三操作数应具有相同的基本类型类别 [MISRA2012-RULE-10_4_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-10_5_a.html">不允许对枚举类型进行强制转换 [MISRA2012-RULE-10_5_a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-10_5_b.html">不要从基本布尔类型转换或转换成基本布尔类型 [MISRA2012-RULE-10_5_b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-10_5_c.html">不要在基本字符类型和基本浮动类型之间使用强制转换 [MISRA2012-RULE-10_5_c-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-10_6.html">复合表达式的值不应赋给广义基本类型的对象 [MISRA2012-RULE-10_6-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-10_7_a.html">如果一个复合表达式被用作运算符的一个操作数，在该操作数中执行通常的算术转换，那么另一个操作数不应该具有更广泛的基本类型 [MISRA2012-RULE-10_7_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-10_7_b.html">如果复合表达式被用作条件运算符的一个(第二或第三个)操作数，则另一个操作数不应具有更广泛的基本类型 [MISRA2012-RULE-10_7_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-10_8.html">复合表达式的值不应转换为不同的基本类型类别或更广泛的基本类型 [MISRA2012-RULE-10_8-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-11_1_a.html">不能在指向函数的指针和任何其他类型之间执行转换 [MISRA2012-RULE-11_1_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-11_1_b.html">不能在指向函数的指针和任何其他类型之间执行转换 [MISRA2012-RULE-11_1_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-11_2.html">不能在指向不完整类型的指针和任何其他类型之间执行转换 [MISRA2012-RULE-11_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-11_3.html">不能在指向对象类型的指针和指向不同对象类型的指针之间执行强制转换 [MISRA2012-RULE-11_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-11_4.html">不应该在指向对象的指针和整数类型之间执行转换 [MISRA2012-RULE-11_4-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-11_5.html">不应该执行从指针到无效指针对象的转换 [MISRA2012-RULE-11_5-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-11_6.html">在无效指针和算术类型之间不应该执行强制转换 [MISRA2012-RULE-11_6-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-11_7.html">不能在指向对象的指针和非整数算术类型之间执行强制转换 [MISRA2012-RULE-11_7-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-11_8.html">强制类型转换不应移除指针指向的类型中的任何常量或 volatile 限定条件 [MISRA2012-RULE-11_8-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-11_9_a.html">宏 NULL 应该是整数空指针常量的唯一允许形式 [MISRA2012-RULE-11_9_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-11_9_b.html">宏 NULL 应该是整数空指针常量的唯一允许形式 [MISRA2012-RULE-11_9_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-12_1_a.html">使用括号，除非表达式中的所有运算符都相同 [MISRA2012-RULE-12_1_a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-12_1_b.html">逻辑运算符 &amp;&amp;和||应该是基本表达式 [MISRA2012-RULE-12_1_b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-12_1_c.html">括号应与 'sieof'语句一起使用 [MISRA2012-RULE-12_1_c-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-12_2.html">移位运算符的右操作数应位于小于左操作数基本类型的位宽度的零到一的范围内。 [MISRA2012-RULE-12_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-12_3.html">不应该使用逗号操作符 [MISRA2012-RULE-12_3-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-12_4_a.html">'+'、'-'、'*'运算符中常量表达式中的整数溢出或下溢 [MISRA2012-RULE-12_4_a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-12_4_b.html">在 '&lt;&lt;'运算符中常量表达式中的整数溢出或下溢 [MISRA2012-RULE-12_4_b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-12_5.html">'sizeof' 运算符不应该有一个被声明为 "数组类型 "的函数参数的操作数 [MISRA2012-RULE-12_5-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-13_1_a.html">构造器列表不应包含持久的副作用 [MISRA2012-RULE-13_1_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-13_2_a.html">在标准允许的任何评求值顺序下，表达式的值应相同 [MISRA2012-RULE-13_2_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-13_2_b.html">不要编写依赖于函数参数求值顺序的代码 [MISRA2012-RULE-13_2_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-13_2_c.html">不要编写依赖于函数标识符和函数参数的求值顺序的代码 [MISRA2012-RULE-13_2_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-13_2_d.html">不要编写依赖于包含函数调用表达式的求值顺序的代码 [MISRA2012-RULE-13_2_d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-13_2_e.html">在序列点之间，对象的存储值应通过表达式的求值最多修改一次 [MISRA2012-RULE-13_2_e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-13_2_f.html">不要在一个表达式中使用多个 volatile 关键字 [MISRA2012-RULE-13_2_f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-13_2_g.html">不要编写依赖于函数调用求值顺序的代码 [MISRA2012-RULE-13_2_g-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-13_3.html">包含递增(++)或递减(-)运算符的完整表达式除了由递增或递减运算符引起的副作用外，应该没有其他潜在的副作用 [MISRA2012-RULE-13_3-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-13_4.html">不应使用赋值运算符的结果 [MISRA2012-RULE-13_4-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-13_5.html">逻辑运算符 &amp;&amp;或||运算符的右操作数不应含有持续的副作用 [MISRA2012-RULE-13_5-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-13_6_a.html">sizeof 算符的操作数不应包含任何可能产生副作用的表达式 [MISRA2012-RULE-13_6_a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-13_6_b.html">sizeof 运算符的操作数不应包含任何可能产生副作用的表达式 [MISRA2012-RULE-13_6_b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-13_6_c.html">sizeof 运算符的操作数不应包含任何可能产生副作用的表达式 [MISRA2012-RULE-13_6_c-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_1_a.html">for 循环中的循环计数器本质上不应该具有浮点数据类型 [MISRA2012-RULE-14_1_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_1_b.html">while 循环和 do-while 循环中的循环计数器本质上不应该具有浮点数据类型 [MISRA2012-RULE-14_1_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_2_a.html">'for' 循环中只能有一个循环计数器，不能在 'for'循环体中进行修改 [MISRA2012-RULE-14_2_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_2_b.html">for 循环的第一个子句应该是格式规范的 [MISRA2012-RULE-14_2_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_2_c.html">for 循环的第二句应该是格式规范的 [MISRA2012-RULE-14_2_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_2_d.html">for 循环的第三句应该是格式规范的 [MISRA2012-RULE-14_2_d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_3_a.html">控制表达式不应是不变的 [MISRA2012-RULE-14_3_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_3_b.html">控制表达式不应是不变的 [MISRA2012-RULE-14_3_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_3_c.html">控制表达式不应是不变的 [MISRA2012-RULE-14_3_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_3_d.html">控制表达式不应是不变的 [MISRA2012-RULE-14_3_d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_3_e.html">控制表达式不应是不变的 [MISRA2012-RULE-14_3_e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_3_f.html">控制表达式不应是不变的 [MISRA2012-RULE-14_3_f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_3_g.html">控制表达式不应是不变的 [MISRA2012-RULE-14_3_g-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_3_h.html">控制表达式不应是不变的 [MISRA2012-RULE-14_3_h-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_3_i.html">控制表达式不应是不变的 [MISRA2012-RULE-14_3_i-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_3_j.html">控制表达式不应是不变的 [MISRA2012-RULE-14_3_j-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_3_k.html">控制表达式不应是不变的 [MISRA2012-RULE-14_3_k-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_3_l.html">控制表达式不应是不变的 [MISRA2012-RULE-14_3_l-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_3_m.html">控制表达式不应是不变的 [MISRA2012-RULE-14_3_m-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_3_n.html">控制表达式不应是不变的 [MISRA2012-RULE-14_3_n-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_3_o.html">控制表达式不应是不变的 [MISRA2012-RULE-14_3_o-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_3_p.html">控制表达式不应是不变的 [MISRA2012-RULE-14_3_p-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_3_q.html">控制表达式不应是不变的 [MISRA2012-RULE-14_3_q-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_3_r.html">控制表达式不应是不变的 [MISRA2012-RULE-14_3_r-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_3_s.html">控制表达式不应是不变的 [MISRA2012-RULE-14_3_s-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_3_t.html">控制表达式不应是不变的 [MISRA2012-RULE-14_3_t-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_3_u.html">控制表达式不应是不变的 [MISRA2012-RULE-14_3_u-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_3_v.html">控制表达式不应是不变的 [MISRA2012-RULE-14_3_v-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_3_w.html">控制表达式不应是不变的 [MISRA2012-RULE-14_3_w-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_3_x.html">控制表达式不应是不变的 [MISRA2012-RULE-14_3_x-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_3_y.html">控制表达式不应是不变的 [MISRA2012-RULE-14_3_y-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_3_z.html">控制表达式不应是不变的 [MISRA2012-RULE-14_3_z-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_3_za.html">控制表达式不应是不变的 [MISRA2012-RULE-14_3_za-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_3_zb.html">控制表达式不应是不变的 [MISRA2012-RULE-14_3_zb-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_3_zc.html">控制表达式不应是不变的 [MISRA2012-RULE-14_3_zc-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_3_zd.html">避免不能被执行到的 switch 分支 [MISRA2012-RULE-14_3_zd-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-14_4.html">if 语句的控制表达式和迭代语句的控制表达式应该具有基本的布尔类型 [MISRA2012-RULE-14_4-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-15_1.html">goto 语句不应该被使用 [MISRA2012-RULE-15_1-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-15_2.html">goto 语句将跳转到后面在相同函数中声明的标签 [MISRA2012-RULE-15_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-15_3.html">goto 语句引用的任何标签都应声明在同一个块中，或包含 goto 语句的任何块中 [MISRA2012-RULE-15_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-15_4.html">用于终止任何迭代语句的 break 或 goto 语句不应该超过一个 [MISRA2012-RULE-15_4-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-15_5.html">函数的末尾应该有一个单独的出口点 [MISRA2012-RULE-15_5-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-15_6_a.html">迭代语句或选择语句的主体应该是复合语句 [MISRA2012-RULE-15_6_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-15_6_b.html">迭代语句或选择语句的主体应该是复合语句 [MISRA2012-RULE-15_6_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-15_7.html">所有 'if ...else if' 结构都应该以 else 语句结束 [MISRA2012-RULE-15_7-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-16_1_a.html">switch 语句只包含 switch 标签和 switch 子句，不包含其他代码 [MISRA2012-RULE-16_1_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-16_1_b.html">只有当最接近的复合语句是 switch 语句的主体时，才能使用 switch 标签 [MISRA2012-RULE-16_1_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-16_1_c.html">无条件 break 语句应该终止所有非 &nbsp;null 的 case 子句 [MISRA2012-RULE-16_1_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-16_1_d.html">无条件 break 语句应该终止所有非 &nbsp;null 的 default 子句 [MISRA2012-RULE-16_1_d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-16_1_e.html">始终为 switch 语句提供 default 分支 [MISRA2012-RULE-16_1_e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-16_1_f.html">在终止 'break' 之前， 'default' 标签应有声明或注释 [MISRA2012-RULE-16_1_f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-16_1_g.html">'default' 标签(如果存在的话)应该作为 switch 语句的第一个或最后一个 switch 子句出现 [MISRA2012-RULE-16_1_g-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-16_1_h.html">每个 switch 语句至少应有两个 switch 子句 [MISRA2012-RULE-16_1_h-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-16_2.html">只有当最接近的复合语句是switch语句的主体时，才能使用 switch 标签 [MISRA2012-RULE-16_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-16_3_a.html">无条件 break 语句应该终止所有 switch 子句 [MISRA2012-RULE-16_3_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-16_3_b.html">无条件 break 语句应该终止所有switch子句 [MISRA2012-RULE-16_3_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-16_4_a.html">每个 'switch' 语句都应该有一个 'default' 标签 [MISRA2012-RULE-16_4_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-16_4_b.html">在终止 'break' 之前， 'default' 标签应有声明或注释 [MISRA2012-RULE-16_4_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-16_5.html">default 标签应该作为 switch 语句的第一个或最后一个 switch 标签出现 [MISRA2012-RULE-16_5-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-16_6.html">每个 switch 语句至少应有两个 switch 子句 [MISRA2012-RULE-16_6-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-16_7_a.html">switch 表达式不应该具有基本的布尔类型 [MISRA2012-RULE-16_7_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-16_7_b.html">switch 表达式不应该具有基本的布尔类型 [MISRA2012-RULE-16_7_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-17_1_a.html">&lt;stdarg.h&gt; 不应该被使用 [MISRA2012-RULE-17_1_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-17_1_b.html">&lt;stdarg.h&gt; 不应该被使用 [MISRA2012-RULE-17_1_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-17_2.html">函数不能直接或间接的调用它本身 [MISRA2012-RULE-17_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-17_3.html">函数不能隐式声明 [MISRA2012-RULE-17_3-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-17_4.html">具有非 void 返回类型的函数的所有出口路径，都应该有一个带有表达式的显式返回语句 [MISRA2012-RULE-17_4-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-17_5.html">函数中被声明为数组类型的参数中应该有一定数量的元素 [MISRA2012-RULE-17_5-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-17_6.html">数组参数的声明在[ ]之间不应包含 'static' 关键字 [MISRA2012-RULE-17_6-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-17_7_a.html">使用具有返回非 void 类型的函数的返回值 [MISRA2012-RULE-17_7_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-17_7_b.html">使用具有返回非 void 类型的函数的返回值 [MISRA2012-RULE-17_7_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-17_8.html">不应修改函数参数 [MISRA2012-RULE-17_8-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-18_1_a.html">避免访问数组超出范围 [MISRA2012-RULE-18_1_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-18_1_b.html">避免访问数组和指针超出范围 [MISRA2012-RULE-18_1_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-18_1_c.html">指针操作数和使用该操作数的指针算术产生的任何指针都应同时指向同一数组的元素。 [MISRA2012-RULE-18_1_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-18_2.html">指针之间的减法只适用于处理相同数组元素的指针 [MISRA2012-RULE-18_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-18_3.html">&gt;, &gt;=, &lt;, &lt;= 不应用于指针类型的对象，除非它们指向同一个数组 [MISRA2012-RULE-18_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-18_4.html">不应将+、-、+=和-=运算符应用于指针类型的表达式 [MISRA2012-RULE-18_4-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-18_5.html">声明应该包含不超过两层的指针嵌套 [MISRA2012-RULE-18_5-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-18_6_a.html">具有自动存储功能的对象的地址不能从函数返回 [MISRA2012-RULE-18_6_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-18_6_b.html">具有自动存储功能的对象可能在第一个对象停止存在后仍然存在，它的地址不应分配给另一个对象 [MISRA2012-RULE-18_6_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-18_7.html">不应声明灵活的数组成员 [MISRA2012-RULE-18_7-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-18_8.html">不应使用可变长度的数组类型 [MISRA2012-RULE-18_8-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-19_1_a.html">一个对象不应该被分配或复制到一个重叠的对象 [MISRA2012-RULE-19_1_a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-19_1_b.html">一个对象不应该被分配或复制到一个重叠的对象 [MISRA2012-RULE-19_1_b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-19_1_c.html">不应将对象分配或复制到重叠的对象 [MISRA2012-RULE-19_1_c-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-19_2.html">不应该使用 union 关键字 [MISRA2012-RULE-19_2-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-1_1_a_c90.html">程序不应超过 The Standard (c90)规定的编译限制 [MISRA2012-RULE-1_1_a_c90-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-1_1_a_c99.html">程序不应超过 The Standard (c99)规定的编译限制 [MISRA2012-RULE-1_1_a_c99-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-1_1_b_c90.html">程序不应超过 The Standard (c90)规定的编译限制 [MISRA2012-RULE-1_1_b_c90-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-1_1_b_c99.html">程序不应超过 The Standard (c99)规定的编译限制 [MISRA2012-RULE-1_1_b_c99-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-1_3_a.html">避免除以零 [MISRA2012-RULE-1_3_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-1_3_b.html">避免在初始化前使用 [MISRA2012-RULE-1_3_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-1_3_c.html">不得使用已释放的资源 [MISRA2012-RULE-1_3_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-1_3_d.html">读取缓冲区时,避免溢出 [MISRA2012-RULE-1_3_d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-1_3_e.html">写入缓冲区时,避免溢出 [MISRA2012-RULE-1_3_e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-1_3_f.html">在规范标准允许的任何求值顺序下,表达式的值应相同 [MISRA2012-RULE-1_3_f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-1_3_g.html">不要编写依赖于函数参数求值顺序的代码 [MISRA2012-RULE-1_3_g-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-1_3_h.html">不要编写依赖于函数 designator 和函数参数的求值顺序的代码 [MISRA2012-RULE-1_3_h-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-1_3_i.html">不要编写依赖于含有函数调用的表达式求值顺序的代码 [MISRA2012-RULE-1_3_i-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-1_3_j.html">在序列点之间,对象应该有通过表达式的求值至多修改一次的存储值 [MISRA2012-RULE-1_3_j-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-1_3_k.html">不要在一个表达式中使用多个 volatile &nbsp;[MISRA2012-RULE-1_3_k-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-1_3_l.html">不要编写依赖于函数调用的求值顺序的代码 [MISRA2012-RULE-1_3_l-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-1_3_m.html">函数不应返回指向非静态局部对象的指针或引用 [MISRA2012-RULE-1_3_m-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-1_3_n.html">具有能自动存储的对象的地址不应分配给在对象不存在后仍然存在的对象 [MISRA2012-RULE-1_3_n-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-1_3_o.html">右移操作符的左操作数不应为负值 [MISRA2012-RULE-1_3_o-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-20_1.html">#include 指令前应该只有预处理指令或注释 [MISRA2012-RULE-20_1-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-20_10.html">不应该使用 # 和 ## 预处理器操作符 [MISRA2012-RULE-20_10-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-20_11.html">紧跟在 # 操作符后面的宏参数不应该紧跟在 ## 操作符后面 [MISRA2012-RULE-20_11-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-20_12.html">作为 # 或 ## 操作符的操作对象使用的宏参数，本身要进行进一步的宏替换，所以只能作为这些操作符的操作对象使用 [MISRA2012-RULE-20_12-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-20_13.html">第一个令牌为 # 的行应该是有效的预处理指令 [MISRA2012-RULE-20_13-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-20_14.html">所有的 #else, #elif 和 #endif 预处理器指令应该与它们相关的 #if, #ifdef 或 #ifndef 指令驻留在同一个文件中 [MISRA2012-RULE-20_14-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-20_2_a.html">在头文件名称中不应出现 ', &amp; 或者 \ 字符和 /* 或 // 字符序列 [MISRA2012-RULE-20_2_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-20_2_b.html">在头文件名称中不应出现 ', &amp; 或者 \ 字符和 /* 或 // 字符序列 [MISRA2012-RULE-20_2_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-20_3.html">#include 指令后面应该跟着一个 &lt;filename&gt; 或 "filename" 这样的序列 [MISRA2012-RULE-20_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-20_4_a.html">宏不能与关键字同名 [MISRA2012-RULE-20_4_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-20_4_b.html">宏不能与关键字同名 [MISRA2012-RULE-20_4_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-20_5.html">不应该使用 #undef [MISRA2012-RULE-20_5-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-20_6.html">看起来像预处理指令的标记不应该出现在宏参数中 [MISRA2012-RULE-20_6-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-20_7.html">宏参数展开产生的表达式应括在括号中 [MISRA2012-RULE-20_7-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-20_8.html">一个 #if 或 #elif 预处理指令的控制表达式应取值为 0 或 1 [MISRA2012-RULE-20_8-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-20_9_b.html">在 #if 或 #elif 预处理指令的控制表达式中使用的所有标识符都应该在计算前进行 #define'd [MISRA2012-RULE-20_9_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-21_10.html">标准库不得使用标准的时间和日期函数 [MISRA2012-RULE-21_10-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-21_11.html">不得使用 &lt;tgmath.h&gt; 的标准头文件 [MISRA2012-RULE-21_11-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-21_12.html">不得使用 &lt;fenv.h&gt; 的异常处理特性 [MISRA2012-RULE-21_12-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-21_13.html">在 &lt;ctype.h&gt; 中传递给函数的任何值可表示为 'unsigned char' 或 'EOF' 的值 [MISRA2012-RULE-21_13-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-21_14.html">标准库函数 'memcmp' 不能用于比较以 null 结尾的字符串 [MISRA2012-RULE-21_14-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-21_15.html">指向标准库函数 'memcmp', 'memmove' 和 'memcmp' 的指针参数应该是指向兼容类型的合格版或不合格版本的指针 [MISRA2012-RULE-21_15-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-21_16.html">本质上，标准库函数 'memcmp' 的指针参数应该指向指针类型、有符号类型、无符号类型、布尔类型或枚举类型 [MISRA2012-RULE-21_16-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-21_17_a.html">避免由于读取非零终止字符串而导致溢出 [MISRA2012-RULE-21_17_a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-21_17_b.html">写入缓冲区时避免溢出 [MISRA2012-RULE-21_17_b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-21_18.html">传递给 &lt;string.h&gt; 中的任何函数的 'size_t' 参数应具有适当的值 [MISRA2012-RULE-21_18-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-21_19_a.html">由标准库函数 'localeconv', 'getenv', 'setlocale' 或 'strerror' 返回的指针只能像它们具有指向 const-qualified 类型的指针一样使用 [MISRA2012-RULE-21_19_a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-21_19_b.html">由结构 'lconv' 成员指向的字符串不应被修改 [MISRA2012-RULE-21_19_b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-21_1_a.html">不得使用以下划线开头的有 #define 或 #undef 标识符这样的名称 [MISRA2012-RULE-21_1_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-21_1_b.html">#define 和 #undef 不能用于预留标识符或预留宏名( 对于 C90 代码) [MISRA2012-RULE-21_1_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-21_1_c.html">#define 和 #undef 不能用于预留标识符或预留宏名( 对于 C99 代码) [MISRA2012-RULE-21_1_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-21_1_d.html">不得使用 #define 或 #undef 标识符 'defined' [MISRA2012-RULE-21_1_d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-21_20.html">某些标准库函数返回的指针不应在对相同或相关函数的后续调用之后使用 [MISRA2012-RULE-21_20-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-21_2_a.html">不应声明以下划线开头的名称标识符 [MISRA2012-RULE-21_2_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-21_2_b.html">保留标识符或宏名不得声明(对于 C90 代码) [MISRA2012-RULE-21_2_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-21_2_c.html">保留标识符或宏名不得声明(对于 C99 代码) [MISRA2012-RULE-21_2_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-21_3.html">不得使用 &nbsp;&lt;stdlib.h&gt; 的内存分配和分配功能 [MISRA2012-RULE-21_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-21_4_a.html">不得使用 &lt;setjmp.h&gt; 的标准头文件 [MISRA2012-RULE-21_4_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-21_4_b.html">不得使用 &nbsp;&lt;setjmp.h&gt; 的标准头文件 [MISRA2012-RULE-21_4_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-21_5_a.html">不得使用 &nbsp;&lt;signal.h&gt; 的标准头文件 [MISRA2012-RULE-21_5_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-21_5_b.html">不得使用 &nbsp;&lt;signal.h&gt; 的标准头文件 [MISRA2012-RULE-21_5_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-21_6.html">不得使用标准库的输入/输出函数 [MISRA2012-RULE-21_6-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-21_7.html">不得使用 &nbsp;&lt;stdlib.h&gt; 的 atof, atoi, atol 和 atoll 功能 [MISRA2012-RULE-21_7-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-21_8.html">不得使用 &lt;stdlib.h&gt; 的 'abort' 库函数 [MISRA2012-RULE-21_8-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-21_8_b.html">不得使用 &lt;stdlib.h&gt; 的 'exit' 库函数 [MISRA2012-RULE-21_8_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-21_8_c.html">不得使用 &lt;stdlib.h&gt; 的 'getenv' 库函数 [MISRA2012-RULE-21_8_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-21_8_d.html">不得使用 &nbsp;&lt;stdlib.h&gt; 的 'system' 库函数 [MISRA2012-RULE-21_8_d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-21_9.html">不得使用标准库 &lt;stdlib.h&gt; 包括检索和检索的功能 [MISRA2012-RULE-21_9-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-22_1.html">所有通过标准库函数动态获取的资源都应明确释放 [MISRA2012-RULE-22_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-22_10.html">'errno' 的值只有在最后一个要调用的函数是 errno-setting-function 时才会被测试 [MISRA2012-RULE-22_10-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-22_2_a.html">不使用已释放的资源 [MISRA2012-RULE-22_2_a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-22_2_b.html">不使用无效指针释放资源 [MISRA2012-RULE-22_2_b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-22_3.html">不得在不同的流上同时打开同一文件进行读写访问 [MISRA2012-RULE-22_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-22_4.html">避免写入仅作为只读打开的流 [MISRA2012-RULE-22_4-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-22_5_a.html">指向文件对象的指针不应解除引用 [MISRA2012-RULE-22_5_a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-22_5_b.html">指向文件对象的指针不应由库函数解除引用 [MISRA2012-RULE-22_5_b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-22_6.html">指向一个 FILE 文件指针的值在关联的流关闭后不应使用 [MISRA2012-RULE-22_6-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-22_7.html">宏 'EOF' 应该与标准库函数未修改的返回值进行比较 [MISRA2012-RULE-22_7-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-22_8.html">'errno' 的值应该在调用 errno-setting-function 之前设置为 0 [MISRA2012-RULE-22_8-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-22_9.html">'errno' 的值在调用 errno-setting-function 后，应针对零进行测试 [MISRA2012-RULE-22_9-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-2_1_a.html">在 'else' 代码块中不应存在不可到达的代码 [MISRA2012-RULE-2_1_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-2_1_b.html">在 'return', 'break', 'continue',以及 'gotoThere' 语句之后,不应存在不可到达的代码 [MISRA2012-RULE-2_1_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-2_1_c.html">在 'if', 'else', 'while', 'for' 代码块中不应存在不可到达的代码 [MISRA2012-RULE-2_1_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-2_1_d.html">'switch' 语句中不应存在不可到达的代码 [MISRA2012-RULE-2_1_d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-2_1_e.html">'for' 循环中不应存在不可到达的代码 [MISRA2012-RULE-2_1_e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-2_1_f.html">'if' 或 'switch' 语句后不应存在不可到达的代码 [MISRA2012-RULE-2_1_f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-2_1_g.html">在 'while'/'for'/'do...while'循环内的 'if'或 'switch'语句后面不会有无法访问的代码 [MISRA2012-RULE-2_1_g-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-2_2_a.html">所有非空语句要么不管怎样执行至少有一个副作用，或者导致控制流程发生变化 [MISRA2012-RULE-2_2_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-2_2_b.html">避免未使用的值 [MISRA2012-RULE-2_2_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-2_3_a.html">函数不应包含未使用的类型声明 [MISRA2012-RULE-2_3_a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-2_3_b.html">源文件不应包含未使用的类型声明 [MISRA2012-RULE-2_3_b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-2_4_a.html">函数不应包含未使用的本地标记声明 [MISRA2012-RULE-2_4_a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-2_4_b.html">源文件不应包含未使用的标记声明 [MISRA2012-RULE-2_4_b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-2_5.html">源文件不应包含未使用的宏声明 [MISRA2012-RULE-2_5-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-2_6.html">函数不应包含未使用的标签声明 [MISRA2012-RULE-2_6-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-2_7.html">函数中应该没有未使用的参数 [MISRA2012-RULE-2_7-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-3_1_a.html">字符序列/*不得在 C 风格的注释中使用 [MISRA2012-RULE-3_1_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-3_1_b.html">字符序列//不得在 C 风格的注释中使用 [MISRA2012-RULE-3_1_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-3_1_c.html">字符序列/*不得在 C++ 风格的注释中使用 [MISRA2012-RULE-3_1_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-3_2.html">不应在//注释中使用行拼接 [MISRA2012-RULE-3_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-4_1.html">应结束八进制和十六进制转义序列 [MISRA2012-RULE-4_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-4_2.html">不应使用三联符 [MISRA2012-RULE-4_2-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-5_1.html">外部标识符应该是不同的 [MISRA2012-RULE-5_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-5_2_a_c90.html">在文件范围和同一命名空间中声明的标识符应是不同的（c90） [MISRA2012-RULE-5_2_a_c90-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-5_2_a_c99.html">在文件范围和同一命名空间中声明的标识符应是不同的（c99） [MISRA2012-RULE-5_2_a_c99-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-5_2_b_c90.html">在同一块范围和名称空间中声明的标识符应是不同的（c90） [MISRA2012-RULE-5_2_b_c90-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-5_2_b_c99.html">在同一块范围和命名空间中声明的标识符应是不同的（c99） [MISRA2012-RULE-5_2_b_c99-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-5_3_a.html">在内部作用域中声明的标识符不应隐藏在外部作用域中声明的标识符 [MISRA2012-RULE-5_3_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-5_3_b.html">在内部作用域中声明的标识符不应隐藏在外部作用域中声明的标识符 [MISRA2012-RULE-5_3_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-5_4_a_c90.html">宏的名称应与其参数的名称不同（c90） [MISRA2012-RULE-5_4_a_c90-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-5_4_a_c99.html">宏的名称应与其参数的名称不同（c99） [MISRA2012-RULE-5_4_a_c99-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-5_4_b_c90.html">宏的名称应与当前定义的其他宏的名称不同（c90） [MISRA2012-RULE-5_4_b_c90-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-5_4_b_c99.html">宏的名称应与当前定义的其他宏的名称不同（c99） [MISRA2012-RULE-5_4_b_c99-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-5_5_c90.html">标识符应与宏名称不同（c90） [MISRA2012-RULE-5_5_c90-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-5_5_c99.html">标识符应与宏名称不同（c99） [MISRA2012-RULE-5_5_c99-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-5_6_a.html">typedef 名称应该是唯一标识符 [MISRA2012-RULE-5_6_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-5_6_b.html">typedef 名称应该是唯一标识符 [MISRA2012-RULE-5_6_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-5_7_a.html">标签名称不得在程序中重复用于其他目的 [MISRA2012-RULE-5_7_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-5_7_b.html">标签名称不得重复用于定义不同的标签 [MISRA2012-RULE-5_7_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-5_8.html">使用外部链接定义对象或函数的标识符应该是唯一的 [MISRA2012-RULE-5_8-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-5_9_a.html">使用内部链接定义对象或函数的标识符应该是唯一的 [MISRA2012-RULE-5_9_a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-5_9_b.html">使用内部链接定义对象或函数的标识符应该是唯一的 [MISRA2012-RULE-5_9_b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-6_1.html">位字段只能用适当的类型声明 [MISRA2012-RULE-6_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-6_2.html">单个位命名的位字段不应是有符号类型 [MISRA2012-RULE-6_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-7_1.html">不得使用八进制常数 [MISRA2012-RULE-7_1-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-7_2.html">'u'或 'U'后缀应适用于以无符号类型表示的所有整数常量 [MISRA2012-RULE-7_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-7_3.html">小写字母 'l'不得用于字面后缀 [MISRA2012-RULE-7_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-7_4.html">除非对象的类型是指向 const 限定 char 的指针，否则不应将字符串字面量赋值给对象 [MISRA2012-RULE-7_4-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-8_10.html">应使用静态存储类声明内联函数 [MISRA2012-RULE-8_10-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-8_11.html">当声明具有外部链接的数组时，应明确指定其大小 [MISRA2012-RULE-8_11-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-8_12.html">在枚举器列表中，隐式指定的枚举常量的值应该是唯一的 [MISRA2012-RULE-8_12-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-8_13_a.html">如果指针不用于修改被寻址的对象，则应将函数原型中的指针参数声明为指向 const 的指针 [MISRA2012-RULE-8_13_a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-8_13_b.html">如果指针不用于修改被寻址的对象，则将参数类型声明为 typedef 以指向 const [MISRA2012-RULE-8_13_b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-8_14.html">不应使用限制类型限定符 [MISRA2012-RULE-8_14-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-8_1_a.html">无论何时声明或定义函数，都应明确说明其类型 [MISRA2012-RULE-8_1_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-8_1_b.html">无论何时声明或定义对象，都应明确说明其类型 [MISRA2012-RULE-8_1_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-8_2_a.html">应为函数原型声明中的所有参数指定标识符 [MISRA2012-RULE-8_2_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-8_2_b.html">函数类型应具有命名参数 [MISRA2012-RULE-8_2_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-8_2_c.html">函数类型应为原型形式 [MISRA2012-RULE-8_2_c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-8_3_a.html">如果多次声明对象或函数，则它们的类型应兼容 [MISRA2012-RULE-8_3_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-8_3_b.html">函数的声明和定义中使用的标识符应相同 [MISRA2012-RULE-8_3_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-8_4_a.html">当有外部链接的对象或函数被定义时，兼容的声明应是可见的 [MISRA2012-RULE-8_4_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-8_4_b.html">当有外部链接的对象或函数被定义时，兼容的声明应是可见的 [MISRA2012-RULE-8_4_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-8_5.html">外部对象或函数在编译单元中不得有多个非定义声明 [MISRA2012-RULE-8_5-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-8_6.html">有外部链接的标识符应该只有一个外部定义 [MISRA2012-RULE-8_6-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-8_7.html">如果仅在一个编译单元中引用函数和对象，则不应使用外部链接定义它们 [MISRA2012-RULE-8_7-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-8_8.html">静态存储类说明符应用于有内部链接对象和函数的所有声明中 [MISRA2012-RULE-8_8-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-8_9.html">如果对象的标识符仅出现在单个函数中，则应在块作用域中定义该对象 [MISRA2012-RULE-8_9-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-9_1.html">初始化之前避免使用 [MISRA2012-RULE-9_1-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-9_2.html">聚合体或联合体的初始化器应用括号括起来 [MISRA2012-RULE-9_2-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-9_3.html">数组不应部分初始化 [MISRA2012-RULE-9_3-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-9_4.html">对象的元素不得多次初始化 [MISRA2012-RULE-9_4-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRA2012-RULE-9_5.html">如果使用指定的构造器初始化数组对象，数组的大小应该显式指定 [MISRA2012-RULE-9_5-2]</a>
</li></ul>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012.html">MISRA C 2012 [MISRAC2012]</a></b>
<ul>
<li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_1.html">Dir 4.1 (必需) 应尽量减少运行时故障 [MISRAC2012-DIR_4_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_1-a.html">避免访问数组越界 [MISRAC2012-DIR_4_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_1-b.html">避免空指针引用 [MISRAC2012-DIR_4_1-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_1-c.html">避免除零错误 [MISRAC2012-DIR_4_1-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_1-d.html">避免由于定义不正确的格式限制导致的缓冲区溢出 [MISRAC2012-DIR_4_1-d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_1-e.html">避免由于读取非零终止字符串导致的溢出 [MISRAC2012-DIR_4_1-e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_1-f.html">避免在引用之后再检查空(null) [MISRAC2012-DIR_4_1-f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_1-g.html">避免读取缓冲区时导致的溢出 [MISRAC2012-DIR_4_1-g-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_1-h.html">避免写入缓冲区时导致的溢出 [MISRAC2012-DIR_4_1-h-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_1-i.html">只有指向数组或数组元素地址的指针才能进行指针运算 [MISRAC2012-DIR_4_1-i-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_1-j.html">&gt;, &gt;=, &lt;, &lt;= 不应用于指针类型，除非它们指向相同的数组 [MISRAC2012-DIR_4_1-j-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_10.html">Dir 4.10 (必需) 应采取预防措施,以防止头文件的内容被包含多次 [MISRAC2012-DIR_4_10]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_10-a.html">使用多个包含保护 [MISRAC2012-DIR_4_10-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_11.html">Dir 4.11 (必需) 应该检查传递给库函数的值的有效性 [MISRAC2012-DIR_4_11]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_11-a.html">验证传递给库函数的值 [MISRAC2012-DIR_4_11-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_12.html">Dir 4.12 (必需) 不应使用动态内存分配 [MISRAC2012-DIR_4_12]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_12-a.html">禁止使用动态内存分配 [MISRAC2012-DIR_4_12-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_13.html">Dir 4.13 (建议) 应该以适当的顺序调用为资源提供操作的函数 [MISRAC2012-DIR_4_13]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_13-a.html">确保资源已释放 [MISRAC2012-DIR_4_13-a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_13-b.html">不得使用已经释放掉的资源 [MISRAC2012-DIR_4_13-b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_13-c.html">不得使用无效的指针释放资源 [MISRAC2012-DIR_4_13-c-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_13-d.html">不要抛弃未释放的锁 [MISRAC2012-DIR_4_13-d-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_13-e.html">避免双重锁定 [MISRAC2012-DIR_4_13-e-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_14.html">Dir 4.14 (必需) 应检查从外部收到的值的有效性 [MISRAC2012-DIR_4_14]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_14-a.html">避免在数组索引中有受污染数据 [MISRAC2012-DIR_4_14-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_14-b.html">防止来自受污染数据的整数溢出/下溢 [MISRAC2012-DIR_4_14-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_14-c.html">避免来自受污染数据的缓冲区读取溢出 [MISRAC2012-DIR_4_14-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_14-d.html">避免来自受污染数据的缓冲区写入溢出 [MISRAC2012-DIR_4_14-d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_14-e.html">防止命令注入 [MISRAC2012-DIR_4_14-e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_14-f.html">防止文件名注入 [MISRAC2012-DIR_4_14-f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_14-g.html">防止 SQL 注入 [MISRAC2012-DIR_4_14-g-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_14-h.html">防止来自受污染数据的缓冲区溢出 [MISRAC2012-DIR_4_14-h-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_14-i.html">避免由于定义不正确的格式限制而导致受污染数据的缓冲区溢出 [MISRAC2012-DIR_4_14-i-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_14-j.html">防止环境注入 [MISRAC2012-DIR_4_14-j-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_14-k.html">避免在输出控制台打印受污染的数据 [MISRAC2012-DIR_4_14-k-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_14-l.html">从格式字符串中排除未经消毒的用户输入 [MISRAC2012-DIR_4_14-l-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_2.html">Dir 4.2 (建议) 所有汇编语言的使用都应记录下来 [MISRAC2012-DIR_4_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_2-a.html">所有汇编程序的使用应该被注释说明 [MISRAC2012-DIR_4_2-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_3.html">Dir 4.3 (必需) 汇编语言应封装和隔离 [MISRAC2012-DIR_4_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_3-a.html">汇编代码应该是封装且独立的 [MISRAC2012-DIR_4_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_4.html">Dir 4.4 (建议) 代码部分不应是 "添加注释" [MISRAC2012-DIR_4_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_4-a.html">代码段不应该被“注释掉” [MISRAC2012-DIR_4_4-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_5.html">Dir 4.5 (建议) 在具有重叠可见性的同一名称空间中,标识符应在字面上是无歧义的 [MISRAC2012-DIR_4_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_5-a.html">具有重叠可见性的同一命名空间中的标识符应该是排版明确的 [MISRAC2012-DIR_4_5-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_6.html">Dir 4.6 (建议) 表示大小和符号的 typedef 应用来代替基本的数字类型 [MISRAC2012-DIR_4_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_6-a.html">用 typedef 定义基本类型应该在名称中包含数字 [MISRAC2012-DIR_4_6-a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_6-b.html">typedefs 应该被用于替代基本类型 [MISRAC2012-DIR_4_6-b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_6-c.html">应该使用C99中stdint.h的typedefs而不是个人自己的声明 [MISRAC2012-DIR_4_6-c-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_7.html">Dir 4.7 (必需) 如果一个函数返回了错误信息,那么就要测试该错误信息 [MISRAC2012-DIR_4_7]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_7-a.html">持续检查非 void 函数的返回值 [MISRAC2012-DIR_4_7-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_7-b.html">始终检查非 void 函数的返回值 [MISRAC2012-DIR_4_7-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_8.html">Dir 4.8 (建议) 如果指向结构或联合的指针从未在编译单元中解引用,那么对象的实现就应该隐藏起来 [MISRAC2012-DIR_4_8]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_8-a.html">如果指向一个结构体或联合体的指针在一个编译单元内从未被间接引用，那么该对象的实现应该被隐藏起来 [MISRAC2012-DIR_4_8-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_9.html">Dir 4.9 (建议) 当可互换的时候,比起类函数宏, 应优先使用函数 [MISRAC2012-DIR_4_9]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-DIR_4_9-a.html">函数应该优先于宏函数的使用 [MISRAC2012-DIR_4_9-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_10_1.html">Rule 10.1 (必需) 操作对象应是适当的基本类型 [MISRAC2012-RULE_10_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_10_1-a.html">当操作数是布尔值时应该使用布尔类型的表达式 [MISRAC2012-RULE_10_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_10_1-b.html">本质为布尔类型的操作数不应该用在需要使用数值操作数的地方 [MISRAC2012-RULE_10_1-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_10_1-c.html">字符类型的操作数不应该用在需要数类型的地方 [MISRAC2012-RULE_10_1-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_10_1-d.html">在算术运算中不应该使用枚举类型 [MISRAC2012-RULE_10_1-d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_10_1-e.html">不要对有符号类型和枚举类型使用移位和位运算 [MISRAC2012-RULE_10_1-e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_10_1-f.html">本质上带符号或枚举类型的操作数不应用作移位操作符的右侧操作数 [MISRAC2012-RULE_10_1-f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_10_1-g.html">一元减运算符的操作数不应该是无符号类型 [MISRAC2012-RULE_10_1-g-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_10_2.html">Rule 10.2 (必需) 在加法和减法运算中,基本字符类型的表达式要使用得当 [MISRAC2012-RULE_10_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_10_2-a.html">字符类型表达式不能用于加减运算符 [MISRAC2012-RULE_10_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_10_3.html">Rule 10.3 (必需) 表达式的值不应赋给更窄的基本类型或不同的基本类型类别的对象 [MISRAC2012-RULE_10_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_10_3-a.html">表达式的值不能赋给更小类型的对象 [MISRAC2012-RULE_10_3-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_10_3-b.html">表达式的值不应赋给另一基本类型类别的对象 [MISRAC2012-RULE_10_3-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_10_4.html">Rule 10.4 (必需) 在执行的常见算术转换中,运算符的两个操作数应具有相同的基本类型类别 [MISRAC2012-RULE_10_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_10_4-a.html">通常算数运算符的两边的操作数应该是相同类型 [MISRAC2012-RULE_10_4-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_10_4-b.html">第二个和第三个三元操作符的操作数有相同的基本类型分类 [MISRAC2012-RULE_10_4-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_10_5.html">Rule 10.5 (建议) 表达式的值应转换为适当的基本类型 [MISRAC2012-RULE_10_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_10_5-a.html">不允许对枚举类型进行转换操作 [MISRAC2012-RULE_10_5-a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_10_5-b.html">不要从Boolean类型转换或转换到Boolean类型 [MISRAC2012-RULE_10_5-b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_10_5-c.html">不要在字符类型和浮点类型之间使用强制类型转换 [MISRAC2012-RULE_10_5-c-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_10_6.html">Rule 10.6 (必需) 复合表达式的值不应赋给具有更广泛的基本类型的对象 [MISRAC2012-RULE_10_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_10_6-a.html">复合表达式的值不应该赋值给宽数据类型的一个对象 [MISRAC2012-RULE_10_6-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_10_7.html">Rule 10.7 (必需) 在执行通常的算术转换中,如果一个复合表达式被用作运算符的一个操作数,那么另一个操作数不应具有更广泛的基本类型 [MISRAC2012-RULE_10_7]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_10_7-a.html">如果复合表达式作为一个操作数用于通常的算术运算并与比它位数宽的操作数进行运算时将报告违规 [MISRAC2012-RULE_10_7-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_10_7-b.html">如果复合表达式被用于条件运算符的操作数，那么其他操作数不应该有更宽的类型 [MISRAC2012-RULE_10_7-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_10_8.html">Rule 10.8 (必需) 复合表达式的值不应转换为不同的基本类型类别或更广泛的基本类型 [MISRAC2012-RULE_10_8]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_10_8-a.html">复合表达式的值不得传递给一个不同的基本类型类别或更广泛的基本类型 [MISRAC2012-RULE_10_8-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_11_1.html">Rule 11.1 (必需) 转换不能发生在函数指针和任何其他类型指针之间 [MISRAC2012-RULE_11_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_11_1-a.html">不得在指向函数的指针与指向函数的指针以外的任何类型之间执行转换 [MISRAC2012-RULE_11_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_11_1-b.html">函数类型的不兼容指针之间不能进行转换 [MISRAC2012-RULE_11_1-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_11_2.html">Rule 11.2 (必需) 转换不能发生在不完整类型指针和任何其他类型指针之间 [MISRAC2012-RULE_11_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_11_2-a.html">不应在指向不完整类型的指针与任何其他类型之间执行转换 [MISRAC2012-RULE_11_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_11_3.html">Rule 11.3 (必需) 不应在某类型对象指针和不同类型对象指针之间进行强制转换 [MISRAC2012-RULE_11_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_11_3-a.html">不得在指向对象类型的指针和指向不同对象类型的指针之间执行强制转换 [MISRAC2012-RULE_11_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_11_4.html">Rule 11.4 (建议) 转换不能发生在对象指针和整型之间 [MISRAC2012-RULE_11_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_11_4-a.html">不应再指向对象的指针和指向整数类型的指针之间转换 [MISRAC2012-RULE_11_4-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_11_5.html">Rule 11.5 (建议) 不应把 void 指针转换成对象指针 [MISRAC2012-RULE_11_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_11_5-a.html">不应该执行从指向 void 的指针到指向对象的指针的转换 [MISRAC2012-RULE_11_5-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_11_6.html">Rule 11.6 (必需) 不应在 void 指针和算术类型之间进行强制转换 [MISRAC2012-RULE_11_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_11_6-a.html">不能在指向 void 的指针和算术类型之间执行强制类型转换 [MISRAC2012-RULE_11_6-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_11_7.html">Rule 11.7 (必需) 不应在对象指针和非整数算术类型之间进行强制转换 [MISRAC2012-RULE_11_7]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_11_7-a.html">不应在指向对象的指针和非整数算术类型之间执行强制转换 [MISRAC2012-RULE_11_7-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_11_8.html">Rule 11.8 (必需) 强制转换不能从指针所指向的类型中移除任何 const 或者 volatile 限制符 [MISRAC2012-RULE_11_8]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_11_8-a.html">强制转换不得从指针或引用类型中删除任何“const”或“volatile”限定条件 [MISRAC2012-RULE_11_8-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_11_9.html">Rule 11.9 (必需) 宏指令 NULL 应是整数空指针常量的唯一允许形式 [MISRAC2012-RULE_11_9]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_11_9-a.html">字面量零 (0) 不得用作空指针常量 (null-pointer-constant) [MISRAC2012-RULE_11_9-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_11_9-b.html">用 NULL 来代替字面零 (0) 作为空指针常量 [MISRAC2012-RULE_11_9-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_12_1.html">Rule 12.1 (建议) 应该明确表达式中运算符的优先级 [MISRAC2012-RULE_12_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_12_1-a.html">除非表达式中的所有运算符都相同，否则使用圆括号 [MISRAC2012-RULE_12_1-a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_12_1-b.html">逻辑运算符 &amp;&amp; 或者 || 的操作数应该是基本表达式 [MISRAC2012-RULE_12_1-b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_12_1-c.html">'sizeof' 语句应该与括号一起使用 [MISRAC2012-RULE_12_1-c-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_12_2.html">Rule 12.2 (必需) 移位运算符的右手操作数应该位于零和某数之间,这个数小于左手操作数的基本类型的位宽 [MISRAC2012-RULE_12_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_12_2-a.html">一个移位操作符的右操作数应该位于 0 到 1 之间，小于左操作数底层类型的位宽 [MISRAC2012-RULE_12_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_12_3.html">Rule 12.3 (建议) 不应该使用逗号运算符 [MISRAC2012-RULE_12_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_12_3-a.html">不应该使用逗号运算符 [MISRAC2012-RULE_12_3-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_12_4.html">Rule 12.4 (建议) 常量表达式的求值不应该导致无符号整数自动换行 [MISRAC2012-RULE_12_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_12_4-a.html">'+'， '-'， '*' 运算符常量表达式中的整数溢出或下溢 [MISRAC2012-RULE_12_4-a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_12_4-b.html">'&lt;&lt;' 运算符常量表达式中的整数溢出或下溢 [MISRAC2012-RULE_12_4-b-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_12_5.html">Rule 12.5 (强制) sizeof 运算符不应有被声明为 "数组类型" 的函数参数的操作数 [MISRAC2012-RULE_12_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_12_5-a.html">运算符'sizeof'的操作数不能是声明为"array of type"的函数参数 [MISRAC2012-RULE_12_5-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_13_1.html">Rule 13.1 (必需) 初始化器列表不要包含持续性副作用 [MISRAC2012-RULE_13_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_13_1-a.html">初始化器列表不应该包含持久的副作用 [MISRAC2012-RULE_13_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_13_2.html">Rule 13.2 (必需) 在所有允许的求值顺序下,表达式的值及其持续性副作用应相同 [MISRAC2012-RULE_13_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_13_2-a.html">表达式的值应该在任何标准允许的赋值顺序下是一样的 [MISRAC2012-RULE_13_2-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_13_2-b.html">不要编写依赖于函数参数求值顺序的代码 [MISRAC2012-RULE_13_2-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_13_2-c.html">不要编写依赖于函数标志符和函数参数的求值顺序的代码 [MISRAC2012-RULE_13_2-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_13_2-d.html">涉及一个函数调用时，不要编写依赖表达式求值顺序的代码 [MISRAC2012-RULE_13_2-d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_13_2-e.html">在序列点之间，对象的存储值最多只能通过表达式的计算来修改一次 [MISRAC2012-RULE_13_2-e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_13_2-f.html">不要在两个相邻的序列点之间使用多个 volatile [MISRAC2012-RULE_13_2-f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_13_2-g.html">不要编写依赖于函数调用求值顺序的代码 [MISRAC2012-RULE_13_2-g-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_13_3.html">Rule 13.3 (建议) 包含递增(++)或递减(--)运算符的完整表达式除了有递增或递减运算符引起的副作用之外,应该就没有其他潜在的副作用 [MISRAC2012-RULE_13_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_13_3-a.html">包含递增(++)或递减(-)运算符的完整表达式应该没有其他潜在的副作用 [MISRAC2012-RULE_13_3-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_13_4.html">Rule 13.4 (建议) 不应使用赋值运算符的结果 [MISRAC2012-RULE_13_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_13_4-a.html">不得使用一个内置赋值运算符的结果 [MISRAC2012-RULE_13_4-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_13_5.html">Rule 13.5 (必需) 逻辑 &amp;&amp; 或 || 运算符的右手操作数不应包含持续性副作用 [MISRAC2012-RULE_13_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_13_5-a.html">逻辑&amp;&amp;或||运算符的右操作数不得含有副作用 [MISRAC2012-RULE_13_5-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_13_6.html">Rule 13.6 (强制) sizeof 运算符的操作数不应包含任何具有潜在副作用的表达式 [MISRAC2012-RULE_13_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_13_6-a.html">sizeof运算符的操作数不应包含任何有副作用的表达式 [MISRAC2012-RULE_13_6-a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_13_6-b.html">不应在sizeof运算符的操作数中访问由volatile左值指定的对象 [MISRAC2012-RULE_13_6-b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_13_6-c.html">函数调用不得是 sizeof 运算符的操作数 [MISRAC2012-RULE_13_6-c-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_1.html">Rule 14.1 (必需) 循环计数器不应该具有基本的浮动类型 [MISRAC2012-RULE_14_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_1-a.html">for循环的循环计数器不能是浮点类型 [MISRAC2012-RULE_14_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_1-b.html">在'while' 和 'do-while' 中的循环计数器不要使用浮点类型 [MISRAC2012-RULE_14_1-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_2.html">Rule 14.2 (必需) for循环应是格式规范的 [MISRAC2012-RULE_14_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_2-a.html">for循环中只能有一个循环计数器，并且不能再循环体中修改 [MISRAC2012-RULE_14_2-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_2-b.html">for循环的第一个判断条件应该是格式良好的 [MISRAC2012-RULE_14_2-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_2-c.html">for循环的第二部分应该格式良好 [MISRAC2012-RULE_14_2-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_2-d.html">for循环的第三部分应该是格式良好的 [MISRAC2012-RULE_14_2-d-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_3.html">Rule 14.3 (必需) 控制表达式应是有变化的 [MISRAC2012-RULE_14_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_3-a.html">不允许其结果是不变的布尔运算 [MISRAC2012-RULE_14_3-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_3-aa.html">不允许其结果是不变的布尔运算 [MISRAC2012-RULE_14_3-aa-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_3-ab.html">不允许其结果是不变的布尔运算 [MISRAC2012-RULE_14_3-ab-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_3-ac.html">避免始终计算为相同值的条件 [MISRAC2012-RULE_14_3-ac-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_3-ad.html">避免具有无法到达分支的开关语句 [MISRAC2012-RULE_14_3-ad-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_3-b.html">不允许其结果是不变的布尔运算 [MISRAC2012-RULE_14_3-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_3-c.html">不允许其结果是不变的布尔运算 [MISRAC2012-RULE_14_3-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_3-d.html">不允许其结果是不变的布尔运算 [MISRAC2012-RULE_14_3-d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_3-e.html">不允许其结果是不变的布尔运算 [MISRAC2012-RULE_14_3-e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_3-f.html">不允许其结果是不变的布尔运算 [MISRAC2012-RULE_14_3-f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_3-g.html">不允许其结果是不变的布尔运算 [MISRAC2012-RULE_14_3-g-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_3-h.html">不允许其结果是不变的布尔运算 [MISRAC2012-RULE_14_3-h-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_3-i.html">不允许其结果是不变的布尔运算 [MISRAC2012-RULE_14_3-i-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_3-j.html">不允许其结果是不变的布尔运算 [MISRAC2012-RULE_14_3-j-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_3-k.html">不允许其结果是不变的布尔运算 [MISRAC2012-RULE_14_3-k-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_3-l.html">不允许其结果是不变的布尔运算 [MISRAC2012-RULE_14_3-l-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_3-m.html">不允许其结果是不变的布尔运算 [MISRAC2012-RULE_14_3-m-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_3-n.html">包含枚举的条件始终为 'true' 或 'false' [MISRAC2012-RULE_14_3-n-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_3-o.html">不允许其结果是不变的布尔运算 [MISRAC2012-RULE_14_3-o-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_3-p.html">不允许其结果是不变的布尔运算 [MISRAC2012-RULE_14_3-p-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_3-q.html">不允许其结果是不变的布尔运算 [MISRAC2012-RULE_14_3-q-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_3-r.html">不允许其结果是不变的布尔运算 [MISRAC2012-RULE_14_3-r-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_3-s.html">不允许其结果是不变的布尔运算 [MISRAC2012-RULE_14_3-s-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_3-t.html">不允许其结果是不变的布尔运算 [MISRAC2012-RULE_14_3-t-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_3-u.html">不允许其结果是不变的布尔运算 [MISRAC2012-RULE_14_3-u-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_3-v.html">不允许其结果是不变的布尔运算 [MISRAC2012-RULE_14_3-v-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_3-w.html">不允许其结果是不变的布尔运算 [MISRAC2012-RULE_14_3-w-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_3-x.html">不允许其结果是不变的布尔运算 [MISRAC2012-RULE_14_3-x-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_3-y.html">不允许其结果是不变的布尔运算 [MISRAC2012-RULE_14_3-y-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_3-z.html">不允许其结果是不变的布尔运算 [MISRAC2012-RULE_14_3-z-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_4.html">Rule 14.4 (必需) if 语句的控制表达式和迭代语句的控制表达式应具有 Boolean 类型 [MISRAC2012-RULE_14_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_14_4-a.html">测试一个值是否为零应该是显式的，除非操作数实际上是布尔值 [MISRAC2012-RULE_14_4-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_15_1.html">Rule 15.1 (建议) 不应该使用 goto 语句 [MISRAC2012-RULE_15_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_15_1-a.html">不应该使用 goto 语句 [MISRAC2012-RULE_15_1-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_15_2.html">Rule 15.2 (必需) goto 语句会跳转到之后在相同函数中声明的标签 [MISRAC2012-RULE_15_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_15_2-a.html">goto 语句应该跳转到同一个函数体中位于 goto 语句后面声明的标签 [MISRAC2012-RULE_15_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_15_3.html">Rule 15.3 (必需) goto 语句引用的任何标签都应声明在同一个块中,或在包含goto语句的任何块中 [MISRAC2012-RULE_15_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_15_3-a.html">任何由 goto 语句引用的标签应该声明在同一个模块中，或者在一个包含 goto 语句的模块中 [MISRAC2012-RULE_15_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_15_4.html">Rule 15.4 (建议) 用于终止任何迭代语句的 break 或 goto 语句不应超过一个 [MISRAC2012-RULE_15_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_15_4-a.html">对任何循环语句，都应存在不止一个用于循环终止的 break 或 goto 语句 [MISRAC2012-RULE_15_4-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_15_5.html">Rule 15.5 (建议) 函数的末尾应有单一的退出点 [MISRAC2012-RULE_15_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_15_5-a.html">函数末端应只提供一个出口点 [MISRAC2012-RULE_15_5-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_15_6.html">Rule 15.6 (必需) 迭代语句或选择语句的主体应是复合语句 [MISRAC2012-RULE_15_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_15_6-a.html">'switch', 'while', 'do...while' 或 'for' 语句的主体应该是复合语句 [MISRAC2012-RULE_15_6-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_15_6-b.html">'if' 和 'else' 语句后应跟一个复合句 [MISRAC2012-RULE_15_6-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_15_7.html">Rule 15.7 (必需) 所有 if ... else if 结构应以 else 语句结束 [MISRAC2012-RULE_15_7]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_15_7-a.html">所有 'if...else-if' 结构应使用一个 'else' 子句终止 [MISRAC2012-RULE_15_7-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_16_1.html">Rule 16.1 (必需) 所有 switch 语句应是格式规范的 [MISRAC2012-RULE_16_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_16_1-a.html">switch 语句应该只包含 switch 标签和 switch 子句，不能包含其他代码 [MISRAC2012-RULE_16_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_16_1-b.html">只有当最紧密封闭的复合语句是 switch 语句主体的时才能使用 switch 标签 [MISRAC2012-RULE_16_1-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_16_1-c.html">无条件的 break 语句应该作为每一个非空 case 子句的结束 [MISRAC2012-RULE_16_1-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_16_1-d.html">无条件的 break 语句应作为所有非空 default 条件的结束 [MISRAC2012-RULE_16_1-d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_16_1-e.html">始终为 switch 语句提供一个 default 分支 [MISRAC2012-RULE_16_1-e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_16_1-f.html">'default' 标签在终止 'break' 之前应有声明或注释 [MISRAC2012-RULE_16_1-f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_16_1-g.html">'default' 标签（如果存在）应显示为 switch 语句的第一个或最后一个 switch 标签 [MISRAC2012-RULE_16_1-g-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_16_1-h.html">每一个 switch 语句应该含有至少两个 switch 子句 [MISRAC2012-RULE_16_1-h-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_16_2.html">Rule 16.2 (必需) switch 标签只能用在当前最紧密封闭的复合语句是 switch 语句的主体的时候 [MISRAC2012-RULE_16_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_16_2-a.html">只有当最紧密封闭的复合语句是 switch 语句主体的时才能使用 switch 标签 [MISRAC2012-RULE_16_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_16_3.html">Rule 16.3 (必需) 无条件的 break 语句应该终止每个 switch 子句 [MISRAC2012-RULE_16_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_16_3-a.html">无条件的 break 语句应该作为每一个非空 case 子句的结束 [MISRAC2012-RULE_16_3-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_16_3-b.html">无条件的 break 语句应作为所有非空 default 条件的结束 [MISRAC2012-RULE_16_3-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_16_4.html">Rule 16.4 (必需) 每个 switch 语句都应有 default 标签 [MISRAC2012-RULE_16_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_16_4-a.html">始终为 switch 语句提供一个 default 分支 [MISRAC2012-RULE_16_4-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_16_4-b.html">'default' 标签在终止 'break' 之前应有声明或注释 [MISRAC2012-RULE_16_4-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_16_5.html">Rule 16.5 (必需) default 标签应作为 switch 语句中的第一个或最后一个 switch 标签 [MISRAC2012-RULE_16_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_16_5-a.html">'default' 标签（如果存在）应显示为 switch 语句的第一个或最后一个 switch 标签 [MISRAC2012-RULE_16_5-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_16_6.html">Rule 16.6 (必需) 每个 switch 语句都应具有至少两个 switch 子句 [MISRAC2012-RULE_16_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_16_6-a.html">每一个 switch 语句应该含有至少两个 switch 子句 [MISRAC2012-RULE_16_6-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_16_7.html">Rule 16.7 (必需) switch 表达式不应具有基本的 Boolean 类型 [MISRAC2012-RULE_16_7]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_16_7-a.html">switch 表达式不应该出现一个实际为布尔的值 [MISRAC2012-RULE_16_7-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_16_7-b.html">switch 表达式不应该出现一个实际为布尔的值 [MISRAC2012-RULE_16_7-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_17_1.html">Rule 17.1 (必需) 不应使用 <stdarg.h> 的特性 [MISRAC2012-RULE_17_1]</stdarg.h></a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_17_1-a.html">不得使用 va_list, va_arg, va_start, va_end, va_copy 标识符 [MISRAC2012-RULE_17_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_17_1-b.html">不得使用 va_list, va_arg, va_start, va_end 标识符 [MISRAC2012-RULE_17_1-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_17_2.html">Rule 17.2 (必需) 函数不能调用其本身,不论是直接的还是间接的 [MISRAC2012-RULE_17_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_17_2-a.html">函数不应该直接或者间接地调用自己 [MISRAC2012-RULE_17_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_17_3.html">Rule 17.3 (强制) 函数不能隐式声明 [MISRAC2012-RULE_17_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_17_3-a.html">在函数调用时，函数总是有可见的原型 [MISRAC2012-RULE_17_3-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_17_4.html">Rule 17.4 (强制) 所有 non-void 返回类型函数的出口路径都应具有带表达式的显式返回语句 [MISRAC2012-RULE_17_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_17_4-a.html">非 void 返回类型的函数的所有退出路径应该有一个明确的包含表达式的返回语句 [MISRAC2012-RULE_17_4-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_17_5.html">Rule 17.5 (建议) 与声明为数组类型的参数对应的函数参数应该有适当数量的元素 [MISRAC2012-RULE_17_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_17_5-a.html">函数参数对应的数组类型参数应该包含合适数量的元素 [MISRAC2012-RULE_17_5-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_17_6.html">Rule 17.6 (强制) 数组参数的声明不应在 [ ] 之间包含静态关键字 [MISRAC2012-RULE_17_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_17_6-a.html">数组参数的声明不得在 [ ] 之间包含 'static' 关键字 [MISRAC2012-RULE_17_6-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_17_7.html">Rule 17.7 (必需) 应使用具有 non-void 返回类型的函数的返回值 [MISRAC2012-RULE_17_7]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_17_7-a.html">应该使用具有非 void 返回类型的函数返回值 [MISRAC2012-RULE_17_7-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_17_7-b.html">不得使用一个非 void 返回类型函数返回的值 [MISRAC2012-RULE_17_7-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_17_8.html">Rule 17.8 (建议) 不应修改函数参数 [MISRAC2012-RULE_17_8]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_17_8-a.html">不应该修改函数参数 [MISRAC2012-RULE_17_8-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_18_1.html">Rule 18.1 (必需) 从指针操作数上计算出来的指针应处理与那个指针操作数相同数组的元素 [MISRAC2012-RULE_18_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_18_1-a.html">避免访问数组越界 [MISRAC2012-RULE_18_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_18_1-b.html">避免访问数组和指针越界 [MISRAC2012-RULE_18_1-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_18_1-c.html">一个指针操作数和使用这个操作数的指针算法所产生的任何指针都应该处理相同数组的元素 [MISRAC2012-RULE_18_1-c-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_18_2.html">Rule 18.2 (必需) 指针之间的减法只适用于处理相同数组元素的指针 [MISRAC2012-RULE_18_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_18_2-a.html">只有指向数组或数组元素地址的指针才能进行指针运算 [MISRAC2012-RULE_18_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_18_3.html">Rule 18.3 (必需) 关系运算符 &gt;, &gt;=, &lt; and &lt;= 不应用于指针类型的对象,除非它们指向同一个对象 [MISRAC2012-RULE_18_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_18_3-a.html">&gt;, &gt;=, &lt;, &lt;= 不应用于指针类型，除非它们指向相同的数组 [MISRAC2012-RULE_18_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_18_4.html">Rule 18.4 (建议) +, -, += 和 -= 运算符不应用于指针类型的表达式 [MISRAC2012-RULE_18_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_18_4-a.html">不要将+, -, += 和 -= 类型操作符应用于指针类型表达式 [MISRAC2012-RULE_18_4-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_18_5.html">Rule 18.5 (建议) 声明应该包含不超过两层的指针嵌套 [MISRAC2012-RULE_18_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_18_5-a.html">对象的声明应该包含不超过 2 层的指针嵌套 [MISRAC2012-RULE_18_5-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_18_6.html">Rule 18.6 (必需) 具有自动存储功能对象的地址不应复制到在第一个对象停止存在后仍然存在的另一个对象上 [MISRAC2012-RULE_18_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_18_6-a.html">不得从函数中返回具有自动存储的对象的地址 [MISRAC2012-RULE_18_6-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_18_6-b.html">自动存储对象的地址不应分配给在第一个对象不再存在后可能持久存在的另一个对象 [MISRAC2012-RULE_18_6-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_18_7.html">Rule 18.7 (必需) 不应声明灵活的数组成员 [MISRAC2012-RULE_18_7]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_18_7-a.html">不得声明灵活的数组成员 [MISRAC2012-RULE_18_7-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_18_8.html">Rule 18.8 (必需) 不应使用可变长度数组类型 [MISRAC2012-RULE_18_8]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_18_8-a.html">不得使用可变长数组类型 [MISRAC2012-RULE_18_8-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_19_1.html">Rule 19.1 (强制) 一个对象不应被分配或复制到一个重叠的对象上 [MISRAC2012-RULE_19_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_19_1-a.html">不应该将结构体自身的一个成员变量赋给另一个成员变量 [MISRAC2012-RULE_19_1-a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_19_1-b.html">结构体的每个成员不应该赋值给自己的其他成员变量 [MISRAC2012-RULE_19_1-b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_19_1-c.html">不应将对象分配或复制到重叠的对象 [MISRAC2012-RULE_19_1-c-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_19_2.html">Rule 19.2 (建议) 不应该使用 union 关键字 [MISRAC2012-RULE_19_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_19_2-a.html">不得使用联合体关键字 [MISRAC2012-RULE_19_2-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_1_1.html">Rule 1.1 (必需) 程序不应包含 Standard C 的语法和约束的违规,也不应超过实现的编译限制 [MISRAC2012-RULE_1_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_1_1-a.html">程序不应突破施加的标准编译限制 (c90) [MISRAC2012-RULE_1_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_1_1-b.html">程序不应突破施加的标准编译限制 (c99) [MISRAC2012-RULE_1_1-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_1_1-c.html">程序不应突破施加的标准编译限制 (c90) [MISRAC2012-RULE_1_1-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_1_1-d.html">程序不应突破施加的标准编译限制 (c99) [MISRAC2012-RULE_1_1-d-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_1_3.html">Rule 1.3 (必需) 不得出现未定义的或未指定的行为 [MISRAC2012-RULE_1_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_1_3-a.html">避免除零错误 [MISRAC2012-RULE_1_3-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_1_3-b.html">避免在初始化之前使用 [MISRAC2012-RULE_1_3-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_1_3-c.html">不得使用已经释放掉的资源 [MISRAC2012-RULE_1_3-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_1_3-d.html">避免读取缓冲区时导致的溢出 [MISRAC2012-RULE_1_3-d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_1_3-e.html">避免写入缓冲区时导致的溢出 [MISRAC2012-RULE_1_3-e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_1_3-f.html">表达式的值应该在任何标准允许的赋值顺序下是一样的 [MISRAC2012-RULE_1_3-f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_1_3-g.html">不要编写依赖于函数参数求值顺序的代码 [MISRAC2012-RULE_1_3-g-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_1_3-h.html">不要编写依赖于函数标志符和函数参数的求值顺序的代码 [MISRAC2012-RULE_1_3-h-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_1_3-i.html">涉及一个函数调用时，不要编写依赖表达式求值顺序的代码 [MISRAC2012-RULE_1_3-i-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_1_3-j.html">在序列点之间，对象的存储值最多只能通过表达式的计算来修改一次 [MISRAC2012-RULE_1_3-j-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_1_3-k.html">不要在两个相邻的序列点之间使用多个 volatile [MISRAC2012-RULE_1_3-k-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_1_3-l.html">不要编写依赖于函数调用求值顺序的代码 [MISRAC2012-RULE_1_3-l-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_1_3-m.html">不得从函数中返回具有自动存储的对象的地址 [MISRAC2012-RULE_1_3-m-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_1_3-n.html">自动存储对象的地址不应分配给在第一个对象不再存在后可能持久存在的另一个对象 [MISRAC2012-RULE_1_3-n-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_1_3-o.html">右移位操作符的左操作数不能是负数 [MISRAC2012-RULE_1_3-o-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_20_1.html">Rule 20.1 (建议) #include 指令前应该只有预处理指令或注释 [MISRAC2012-RULE_20_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_20_1-a.html">#include 之前只允许有预处理命令和注释 [MISRAC2012-RULE_20_1-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_20_10.html">Rule 20.10 (建议) 不应该使用 # 和 ## 预处理器运算符 [MISRAC2012-RULE_20_10]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_20_10-a.html">禁止使用预处理操作符 # 和 ## [MISRAC2012-RULE_20_10-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_20_11.html">Rule 20.11 (必需) 紧跟在 # 运算符后面的宏参数不应该紧跟在 ## 运算符后 [MISRAC2012-RULE_20_11]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_20_11-a.html">一个紧跟在#操作符的宏参数不应该在其后紧跟或在其前加上##操作符 [MISRAC2012-RULE_20_11-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_20_12.html">Rule 20.12 (必需)作为 # 或 ## 运算符的操作数使用的宏参数只能作为这些运算符的操作数使用,其本身要进行进一步的宏替换 [MISRAC2012-RULE_20_12]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_20_12-a.html">一个被用作 # 或者 ## 操作符的操作数的宏参数，并且它本身受制于进一步的宏替换，那么它应该只能被用作这些操作符的操作数 [MISRAC2012-RULE_20_12-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_20_13.html">Rule 20.13 (必需) 第一个令牌为 # 的行应是有效的预处理指令 [MISRAC2012-RULE_20_13]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_20_13-a.html">预处理指令即使被预处理器排除也必须有语法意义 [MISRAC2012-RULE_20_13-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_20_14.html">Rule 20.14 (必需) 所有 #else, #elif 和 #endif 预处理器指令应该与它们相关的 #if, #ifdef 或 #ifndef 指令放在同一个文件里 [MISRAC2012-RULE_20_14]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_20_14-a.html">在同一个文件中 #else, #elif 和 #endif 必须对应有 #if 或 #ifdef 预处理指令 [MISRAC2012-RULE_20_14-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_20_2.html">Rule 20.2 (必需) ', " 或 \ 字符 和  /* 或 // 字符序列不应出现在一个头文件名中 [MISRAC2012-RULE_20_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_20_2-a.html">字符 ', ", /* 或 // 不得出现在头文件的名称中 [MISRAC2012-RULE_20_2-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_20_2-b.html">字符 \ 不得出现在头文件的名称中 [MISRAC2012-RULE_20_2-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_20_3.html">Rule 20.3 (必需) #include指令后面应该跟着 <filename> 或 "filename" 序列 [MISRAC2012-RULE_20_3]</filename></a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_20_3-a.html">#include 指令后面应当添加 &lt;filename&gt; 或是 "filename" [MISRAC2012-RULE_20_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_20_4.html">Rule 20.4 (必需) 宏不能与关键字同名 [MISRAC2012-RULE_20_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_20_4-a.html">C90中规定宏不应该与关键字定义为相同名称 [MISRAC2012-RULE_20_4-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_20_4-b.html">C99中规定宏不应该与关键字定义为相同名称 [MISRAC2012-RULE_20_4-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_20_5.html">Rule 20.5 (建议) 不应该使用 #undef [MISRAC2012-RULE_20_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_20_5-a.html">禁止使用 #undef [MISRAC2012-RULE_20_5-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_20_6.html">Rule 20.6 (必需) 看起来像预处理指令的令牌不应出现在宏参数中 [MISRAC2012-RULE_20_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_20_6-a.html">类似函数的宏的参数不应该包含类似预处理命令的标识 [MISRAC2012-RULE_20_6-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_20_7.html">Rule 20.7 (必需) 宏参数展开产生的表达式应括在括号中 [MISRAC2012-RULE_20_7]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_20_7-a.html">在函数式宏定义中，每个参数的实例应该被括号括起来，除非它被用于 # 或 ## 操作符 [MISRAC2012-RULE_20_7-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_20_8.html">Rule 20.8 (必需) #if 或 #elif 预处理指令的控制表达式应取值为 0 或 1 [MISRAC2012-RULE_20_8]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_20_8-a.html">一个# if或# elif预处理指令的控制表达式将值为0或1 [MISRAC2012-RULE_20_8-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_20_9.html">Rule 20.9 (必需) 在 #if 或 #elif 预处理指令的控制表达式中使用的所有标识符都应该在计算前进行 #define'd [MISRAC2012-RULE_20_9]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_20_9-b.html">不要使用在编译单元中未定义的预编译器指令 #if 和 #elif &nbsp;宏 [MISRAC2012-RULE_20_9-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_1.html">Rule 21.1 (必需) #define 和 #undef 不应用于存储标识符或宏的名称 [MISRAC2012-RULE_21_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_1-a.html">不要使用以下划线开头的带有#define 或 #undef 名称的标识符 [MISRAC2012-RULE_21_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_1-b.html">在标准程序库中的保留标识符，宏以及函数不应该被定义，重定义或取消定义（C90代码 [MISRAC2012-RULE_21_1-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_1-c.html">标准库中的保留标识符、宏和函数不应被定义、重新定义或取消定义（C99代码） [MISRAC2012-RULE_21_1-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_1-d.html">不要#define也不要#undef '已定义'的标识 [MISRAC2012-RULE_21_1-d-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_10.html">Rule 21.10 (必需) 不要使用标准库的时间和日期函数 [MISRAC2012-RULE_21_10]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_10-a.html">避免使用标准 C 库中与时间有关的函数 [MISRAC2012-RULE_21_10-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_11.html">Rule 21.11 (必需) 不要使用标准头文件 <tgmath.h> [MISRAC2012-RULE_21_11]</tgmath.h></a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_11-a.html">不得使用标准头文件 &lt;tgmath.h&gt; [MISRAC2012-RULE_21_11-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_12.html">Rule 21.12 (建议) 不应使用 <fenv.h> 的异常处理特性 [MISRAC2012-RULE_21_12]</fenv.h></a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_12-a.html">不得使用 &lt;fenv.h&gt; 中的异常处理功能 [MISRAC2012-RULE_21_12-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_13.html">Rule 21.13 (强制) 在 <ctype.h> 中传递给函数的任何值都应表示为无符号字符或 EOF 值 [MISRAC2012-RULE_21_13]</ctype.h></a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_13-a.html">不要传递不正确的值给 ctype.h 库函数 [MISRAC2012-RULE_21_13-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_14.html">Rule 21.14 (必需) Standard Library 函数 memcmp 不能用于比较空终止字符串 [MISRAC2012-RULE_21_14]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_14-a.html">标准库函数 memcmp 不应该用于比较 null 终止字符串 [MISRAC2012-RULE_21_14-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_15.html">Rule 21.15 (必需) Standard Library 函数 memcpy, memmove 和 memcmp 的指针参数应是 兼容类型的限定或非限定版本指针 [MISRAC2012-RULE_21_15]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_15-a.html">标准库函数 'memcmp', 'memmove' and 'memcmp' 的指针参数应该指向兼容的类型 [MISRAC2012-RULE_21_15-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_16.html">Rule 21.16 (必需) Standard Library 函数 memcmp 的指针参数应是指针类型,有符号类型,无符号类型, Boolean 类型或枚举类型中的一个 [MISRAC2012-RULE_21_16]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_16-a.html">传入标准库函数 'memcmp' 的指针参数不能指向指针类型、无符号类型、有符号类型、布尔类型或枚举类型 [MISRAC2012-RULE_21_16-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_17.html">Rule 21.17 (强制) 在 <string.h> 中,使用字符串处理函数不会导致其指针参数引用对象的访问越界 [MISRAC2012-RULE_21_17]</string.h></a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_17-a.html">避免由于读取非零终止字符串导致的溢出 [MISRAC2012-RULE_21_17-a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_17-b.html">避免写入缓冲区时导致的溢出 [MISRAC2012-RULE_21_17-b-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_18.html">Rule 21.18 (强制) 传递给 <string.h> 中的任意函数的 size_t 参数应具有合适的值 [MISRAC2012-RULE_21_18]</string.h></a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_18-a.html">传递给 string.h 中的任何函数的 size_t 参数应该具有正确的值 [MISRAC2012-RULE_21_18-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_19.html">Rule 21.19（强制）标准库函数localeconv，getenv，setlocale或strerror返回的指针只能用作指向 const 限定类型的指针 [MISRAC2012-RULE_21_19]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_19-a.html">由标准库函数 'localeconv', 'getenv', 'setlocale' 或, 'strerror' 返回的指针只能被用于指向常量类型 [MISRAC2012-RULE_21_19-a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_19-b.html">由结构体 'lconv' 的成员指向的字符串不应该被修改 [MISRAC2012-RULE_21_19-b-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_2.html">Rule 21.2 (必需) 不要声明已存储标识符或宏的名称 [MISRAC2012-RULE_21_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_2-a.html">标准库宏、对象和函数的名称不应该被重用 [MISRAC2012-RULE_21_2-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_2-b.html">不应该重复使用标准库中的宏，对象和函数(C90) [MISRAC2012-RULE_21_2-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_2-c.html">标准库宏，对象和函数的名称不得重复使用（C99） [MISRAC2012-RULE_21_2-c-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_20.html">Rule 21.20（强制）标准库函数 asctime，ctime，gmtime，localtime，localeconv，getenv，setlocale 或 strerror 返回的指针在后续调用同一函数后不得使用 [MISRAC2012-RULE_21_20]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_20-a.html">某些标准库函数返回的指针不应该在随后调用相同或相关函数中使用 [MISRAC2012-RULE_21_20-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_3.html">Rule 21.3 (必需) 不要使用 <stdlib.h> 的内存分配和分配功能 [MISRAC2012-RULE_21_3]</stdlib.h></a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_3-a.html">禁止使用动态内存分配 [MISRAC2012-RULE_21_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_4.html">Rule 21.4 (必需) 不要使用标准的头文件 <setjmp.h> [MISRAC2012-RULE_21_4]</setjmp.h></a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_4-a.html">不使用 setjmp 宏和 longjmp 函数 [MISRAC2012-RULE_21_4-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_4-b.html">不要使用标准头文件 &lt;setjmp.h&gt; [MISRAC2012-RULE_21_4-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_5.html">Rule 21.5 (必需) 不要使用标准的头文件 <signal.h> [MISRAC2012-RULE_21_5]</signal.h></a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_5-a.html">禁止使用标准库文件 &lt;signal.h&gt; 中的处理函数 [MISRAC2012-RULE_21_5-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_5-b.html">禁止使用信号处理文件 &lt;signal.h&gt; 中的处理函数 [MISRAC2012-RULE_21_5-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_6.html">Rule 21.6 (必需) 不要使用标准库的输入/输出函数 [MISRAC2012-RULE_21_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_6-a.html">不得使用标准的库的 input/output 函数 [MISRAC2012-RULE_21_6-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_7.html">Rule 21.7 (必需) 不要使用 <stdlib.h> 的 atof, atoi, atol 和 atoll 函数 [MISRAC2012-RULE_21_7]</stdlib.h></a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_7-a.html">不得使用库stdlib.h中的库函数atof，atoi和atol [MISRAC2012-RULE_21_7-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_8.html">Rule 21.8 (必需) 不要使用 <stdlib.h> 的库函数 abort, exit, getenv 和 system [MISRAC2012-RULE_21_8]</stdlib.h></a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_8-a.html">不得使用 'stdlib.h' 或 'cstdlib' 库中的 'abort()' 函数 [MISRAC2012-RULE_21_8-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_8-b.html">不得使用 'stdlib.h' &nbsp;或 'cstdlib' 库中的 'exit()' 函数 [MISRAC2012-RULE_21_8-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_8-c.html">不得使用 'stdlib.h' 或 'cstdlib' 库中的 'system()' 函数 [MISRAC2012-RULE_21_8-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_8-d.html">不得使用 'stdlib.h' 或 'cstdlib' 库中的 'getenv()' 函数 [MISRAC2012-RULE_21_8-d-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_9.html">Rule 21.9 (必需) 不要使用 <stdlib.h> 的库函数 bsearch 和 qsort [MISRAC2012-RULE_21_9]</stdlib.h></a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_21_9-a.html">不得使用在&lt;stdlib.h&gt;中的 bsearch 和 qsort 库函数 [MISRAC2012-RULE_21_9-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_22_1.html">Rule 22.1（必需）应明确发布通过标准库函数动态获得的所有资源 [MISRAC2012-RULE_22_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_22_1-a.html">确保资源已释放 [MISRAC2012-RULE_22_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_22_10.html">Rule 22.10（必需）只有在要调用的最后一个函数是 errno-setting-function 时才会测试 errno 的值 [MISRAC2012-RULE_22_10]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_22_10-a.html">正确使用 errno 值 [MISRAC2012-RULE_22_10-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_22_2.html">Rule 22.2（强制）只有通过 a 分配的内存块才能被释放 [MISRAC2012-RULE_22_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_22_2-a.html">不得使用已经释放掉的资源 [MISRAC2012-RULE_22_2-a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_22_2-b.html">不得使用无效的指针释放资源 [MISRAC2012-RULE_22_2-b-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_22_3.html">Rule 22.3（必需）同一文件不应在不同的流上同时打开以进行读写访问 [MISRAC2012-RULE_22_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_22_3-a.html">同一个文件不能在不同的流上同时打开用于读取和写入访问 [MISRAC2012-RULE_22_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_22_4.html">Rule 22.4（强制）不得试图写入以只读方式打开的流 [MISRAC2012-RULE_22_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_22_4-a.html">避免写入以只读方式打开的流 [MISRAC2012-RULE_22_4-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_22_5.html">Rule 22.5（强制）指向 FILE 对象的指针不得解除引用 [MISRAC2012-RULE_22_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_22_5-a.html">指针指向了不能引用的文件对象 [MISRAC2012-RULE_22_5-a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_22_5-b.html">指向文件对象的指针不应该被库函数引用 [MISRAC2012-RULE_22_5-b-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_22_6.html">Rule 22.6（强制）不应在关联的流关闭后使用指向 FILE 的指针的值 [MISRAC2012-RULE_22_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_22_6-a.html">不得使用已经释放掉的资源 [MISRAC2012-RULE_22_6-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_22_7.html">Rule 22.7（必需）宏 EOF 只能与任何能够返回 EOF 的标准库函数的未修改返回值进行比较 [MISRAC2012-RULE_22_7]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_22_7-a.html">应该将宏 EOF 与标准库函数中未修改的返回值进行比较 [MISRAC2012-RULE_22_7-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_22_8.html">Rule 22.8（必需）在调用 errno-setting-function 之前，errno 的值应设置为零 [MISRAC2012-RULE_22_8]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_22_8-a.html">正确使用 errno 值 [MISRAC2012-RULE_22_8-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_22_9.html">Rule 22.9（必需）在调用 errno-setting-function 之后，应对 errno 的值进行零测试 [MISRAC2012-RULE_22_9]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_22_9-a.html">正确使用 errno 值 [MISRAC2012-RULE_22_9-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_2_1.html">Rule 2.1 (必需) 项目不应包含不可到达的代码 [MISRAC2012-RULE_2_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_2_1-a.html">在 "else" 语句块中不应存在执行不到的代码 [MISRAC2012-RULE_2_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_2_1-b.html">在 'return', 'break', 'continue', 和 'goto' 语句之后不应存在执行不到的代码 [MISRAC2012-RULE_2_1-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_2_1-c.html">在 "if/else/while/for" 语句块中不应存在执行不到的代码 [MISRAC2012-RULE_2_1-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_2_1-d.html">在 switch 语句中不应存在执行不到的代码 [MISRAC2012-RULE_2_1-d-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_2_1-e.html">在 'for' 循环中不应存在执行不到的代码 [MISRAC2012-RULE_2_1-e-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_2_1-f.html">在 'if' 或 'switch' 语句后不应存在不可访问的代码 [MISRAC2012-RULE_2_1-f-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_2_1-g.html">在 while/for/do...while 循环内的 "if" 或 "switch" 语句后不应存在执行不到的代码 [MISRAC2012-RULE_2_1-g-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_2_2.html">Rule 2.2 (必需) 不应有死码 [MISRAC2012-RULE_2_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_2_2-a.html">所有非 null 语句应该至少有一个执行或者导致控制流变化的附加作用 [MISRAC2012-RULE_2_2-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_2_2-b.html">避免未使用的值 [MISRAC2012-RULE_2_2-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_2_3.html">Rule 2.3 (建议) 项目不应包含未使用的类型声明 [MISRAC2012-RULE_2_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_2_3-a.html">函数中不应该包含无用的类型声明 [MISRAC2012-RULE_2_3-a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_2_3-b.html">源文件中不能包含未使用的类型声明 [MISRAC2012-RULE_2_3-b-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_2_4.html">Rule 2.4 (建议) 项目不应包含未使用的标签声明 [MISRAC2012-RULE_2_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_2_4-a.html">函数不应该包含无用的局部标签声明 [MISRAC2012-RULE_2_4-a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_2_4-b.html">源文件中不应该包含未使用的标签声明 [MISRAC2012-RULE_2_4-b-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_2_5.html">Rule 2.5 (建议) 项目不应包含未使用的宏声明 [MISRAC2012-RULE_2_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_2_5-a.html">源文件中不应该包含无用的宏声明 [MISRAC2012-RULE_2_5-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_2_6.html">Rule 2.6 (建议) 函数不应包含未使用的标签声明 [MISRAC2012-RULE_2_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_2_6-a.html">函数不应该包含未使用的标签声明 [MISRAC2012-RULE_2_6-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_2_7.html">Rule 2.7 (建议) 函数中不应有未使用的参数 [MISRAC2012-RULE_2_7]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_2_7-a.html">在函数中不应该有未使用的参数 [MISRAC2012-RULE_2_7-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_3_1.html">Rule 3.1 (必需) 字符序列 /* 和 // 不应在注释中使用 [MISRAC2012-RULE_3_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_3_1-a.html">禁止在 C 语言风格的注释中使用 /* 字符序列 [MISRAC2012-RULE_3_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_3_1-b.html">字符序列 // 不得被用于 C 语言风格的注释中 [MISRAC2012-RULE_3_1-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_3_1-c.html">字符序列 /* 不得被用于 C++ 语言风格的注释中 [MISRAC2012-RULE_3_1-c-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_3_2.html">Rule 3.2 (必需) 行拼接不应使用在 // 注释中 [MISRAC2012-RULE_3_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_3_2-a.html">不得在 // 注释中使用行合并 [MISRAC2012-RULE_3_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_4_1.html">Rule 4.1 (必需) 应终止八进制和十六进制转义序列 [MISRAC2012-RULE_4_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_4_1-a.html">八进制和十六进制转义序列将被终止 [MISRAC2012-RULE_4_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_4_2.html">Rule 4.2 (建议) 不应使用三字母词 [MISRAC2012-RULE_4_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_4_2-a.html">禁止使用三字母词 [MISRAC2012-RULE_4_2-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_5_1.html">Rule 5.1 (必需) 外部标识符应是不同的 [MISRAC2012-RULE_5_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_5_1-a.html">外部标识符必须是独有的 [MISRAC2012-RULE_5_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_5_2.html">Rule 5.2 (必需) 在同一作用域和名称空间中声明的标识符应是不同的 [MISRAC2012-RULE_5_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_5_2-a.html">在文件范围和命名空间中声明的不同标识符应该区分开来 (c90) [MISRAC2012-RULE_5_2-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_5_2-b.html">在文件范围和命名空间中声明的不同标识符应该区分开来 (c99) [MISRAC2012-RULE_5_2-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_5_2-c.html">在同样的块范围和命名空间中的标识符必须不相同 (c90) [MISRAC2012-RULE_5_2-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_5_2-d.html">在同样的块范围和命名空间中的标识符必须不相同 (c99) [MISRAC2012-RULE_5_2-d-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_5_3.html">Rule 5.3 (必需) 在内部作用域内声明的标识符不得隐藏在外部作用域内声明的标识符 [MISRAC2012-RULE_5_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_5_3-a.html">在局部或者函数原型体范围内声明的标识符不应该隐藏一个在全局或者命名空间范围内声明的标识符 [MISRAC2012-RULE_5_3-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_5_3-b.html">在内层的局部范围内声明的标识符不应该隐藏在外层的局部范围内声明的标识符 [MISRAC2012-RULE_5_3-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_5_4.html">Rule 5.4 (必需) 宏标识符应是不同的 [MISRAC2012-RULE_5_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_5_4-a.html">宏命名应该与参数区分开来（c90) [MISRAC2012-RULE_5_4-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_5_4-b.html">宏命名需要与它的参数名区分开来（c99) [MISRAC2012-RULE_5_4-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_5_4-c.html">宏的命名需要与当前定义的其他宏的命名区分开来（c90） [MISRAC2012-RULE_5_4-c-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_5_4-d.html">宏的名称应该有别于其他当前定义的宏的名称(c99) [MISRAC2012-RULE_5_4-d-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_5_5.html">Rule 5.5 (必需) 标识符应与宏名称不同 [MISRAC2012-RULE_5_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_5_5-a.html">在预处理之前的宏命名应该与预处理之后的标识符区分开来 [MISRAC2012-RULE_5_5-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_5_5-b.html">在预处理之前的宏命名应该与预处理之后的标识符区分开来 [MISRAC2012-RULE_5_5-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_5_6.html">Rule 5.6 (必需) typedef 名称应是唯一的标识符 [MISRAC2012-RULE_5_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_5_6-a.html">不能重用 typedef 名称 [MISRAC2012-RULE_5_6-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_5_6-b.html">不能将 typedef 的名称重用在另一个 typedef 名称 [MISRAC2012-RULE_5_6-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_5_7.html">Rule 5.7 (必需) 标签名称应是唯一标识符 [MISRAC2012-RULE_5_7]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_5_7-a.html">在程序中标记(tag)的名称不得重用于其它目的 [MISRAC2012-RULE_5_7-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_5_7-b.html">标记(tag)的名称不得被重用于定义一个不同的标号 [MISRAC2012-RULE_5_7-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_5_8.html">Rule 5.8 (必需) 定义具有外部链接的对象或函数的标识符应该是唯一的 [MISRAC2012-RULE_5_8]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_5_8-a.html">定义带有外部链接的对象或函数的标识符必须是唯一的 [MISRAC2012-RULE_5_8-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_5_9.html">Rule 5.9 (建议) 定义具有内部链接的对象或函数的标识符应该是唯一的 [MISRAC2012-RULE_5_9]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_5_9-a.html">禁止重用静态存储周期的对象或函数的标识符 [MISRAC2012-RULE_5_9-a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_5_9-b.html">禁止重用静态存储周期的对象或函数的标识符 [MISRAC2012-RULE_5_9-b-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_6_1.html">Rule 6.1 (必需) 位字段只能用适当的类型声明 [MISRAC2012-RULE_6_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_6_1-a.html">只能将位域定义为有符号的整型或无符号的整型 [MISRAC2012-RULE_6_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_6_2.html">Rule 6.2 (必需) 位字段只能用适当的类型声明 [MISRAC2012-RULE_6_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_6_2-a.html">具有带符号的整数类型且已命名的位域应该有超过一位的长度 [MISRAC2012-RULE_6_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_7_1.html">Rule 7.1 (必需) 不能使用八进制常数 [MISRAC2012-RULE_7_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_7_1-a.html">不应该使用八进制常数（除零外） [MISRAC2012-RULE_7_1-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_7_2.html">Rule 7.2 (必需)  "u" 或者 "U" 后缀应该应用于以无符号类型表示的所有整数常量 [MISRAC2012-RULE_7_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_7_2-a.html">无符号类型的所有常量应该使用 'U' 后缀 [MISRAC2012-RULE_7_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_7_3.html">Rule 7.3 (必需) 小写字母 "l"不得使用文字后缀 [MISRAC2012-RULE_7_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_7_3-a.html">使用大写 'L' 而非小写 'l' 来指定长整型 [MISRAC2012-RULE_7_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_7_4.html">Rule 7.4 (必需) 除非对象的类型是 "指向 const 限定字符的指针",否则不能将字符串文字赋值给对象 [MISRAC2012-RULE_7_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_7_4-a.html">字符串文字不应被修改 [MISRAC2012-RULE_7_4-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_1.html">Rule 8.1 (必需) 类型应明确指定 [MISRAC2012-RULE_8_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_1-a.html">声明或定义某个函数时，必须显式地规定其类型 [MISRAC2012-RULE_8_1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_1-b.html">声明或定义某个对象时，必须显式地规定其类型 [MISRAC2012-RULE_8_1-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_10.html">Rule 8.10 (必需) 内联函数应用静态存储类声明 [MISRAC2012-RULE_8_10]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_10-a.html">内联函数应该声明为静态存储类 [MISRAC2012-RULE_8_10-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_11.html">Rule 8.11 (建议) 当声明具有外部链接的数组时,应该明确地指定其大小 [MISRAC2012-RULE_8_11]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_11-a.html">当数组声明具有外部链接，其大小应该显式地说明或者在初始化时隐性地定义 [MISRAC2012-RULE_8_11-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_12.html">Rule 8.12 (必需) 在枚举数列表中,隐式指定的枚举常数的值应是唯一的 [MISRAC2012-RULE_8_12]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_12-a.html">在一个列举列表内，含蓄指定列举常数的值应该是唯一的 [MISRAC2012-RULE_8_12-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_13.html">Rule 8.13 (建议) 只要可能,指针应指向 const 限定的类型 [MISRAC2012-RULE_8_13]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_13-a.html">如果函数参数中指针参数在函数中不用来修改地址对象，则应声明为 const 类型 [MISRAC2012-RULE_8_13-a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_13-b.html">如果指针不用于修改指向地址的对象则声明参数的类型为 typedef 的 const 指针 [MISRAC2012-RULE_8_13-b-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_14.html">Rule 8.14 (必需) 不得使用限制类型的限定词 [MISRAC2012-RULE_8_14]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_14-a.html">不得使用严格的类型限定符 [MISRAC2012-RULE_8_14-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_2.html">Rule 8.2 (必需) 函数类型应采用原型形式,并具有指定的参数 [MISRAC2012-RULE_8_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_2-a.html">在函数原型声明中应该为所有参数提供标识符 [MISRAC2012-RULE_8_2-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_2-b.html">函数类型应该包含具体名称的参数 [MISRAC2012-RULE_8_2-b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_2-c.html">函数类型应当为原型形式 [MISRAC2012-RULE_8_2-c-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_3.html">Rule 8.3 (必需) 对象或函数的所有声明都应使用相同的名称和类型限定符 [MISRAC2012-RULE_8_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_3-a.html">如果对象或者函数被声明了一次以上，那么他们的类型应该是兼容的 [MISRAC2012-RULE_8_3-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_3-b.html">禁止函数声明中使用的标识符与实际定义中的标识符不一致 [MISRAC2012-RULE_8_3-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_4.html">Rule 8.4 (必需) 当定义具有外部链接的对象或函数时,兼容的声明应该是可见的 [MISRAC2012-RULE_8_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_4-a.html">当一个有外部联系的对象或函数被定义，则一个声明应该为可见的 [MISRAC2012-RULE_8_4-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_4-b.html">如果对象或者函数被声明了一次以上，那么他们的类型应该是兼容的 [MISRAC2012-RULE_8_4-b-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_5.html">Rule 8.5 (必需) 外部对象或函数只能在一个文件中声明一次 [MISRAC2012-RULE_8_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_5-a.html">在转换单元中外部对象或函数不得有多个non-defining声明 [MISRAC2012-RULE_8_5-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_6.html">Rule 8.6 (必需) 带有外部链接的标识符应只有一个外部定义 [MISRAC2012-RULE_8_6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_6-a.html">External链接的标识符应该只能有一个外部定义 [MISRAC2012-RULE_8_6-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_7.html">Rule 8.7 (建议) 如果只在一个编译单元中引用函数和对象,则不应用外部链接来定义它们 [MISRAC2012-RULE_8_7]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_7-a.html">如果函数和对象不止在一个编译单元被引用，那么久不应该使用external方式定义 [MISRAC2012-RULE_8_7-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_8.html">Rule 8.8 (必需) 静态存储类说明符应使用在具有内部链接的对象和函数的所有声明中 [MISRAC2012-RULE_8_8]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_8-a.html">静态存储类说明符应该用于具有内部链接的对象和函数的定义和声明 [MISRAC2012-RULE_8_8-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_9.html">Rule 8.9 (建议) 如果对象的标识符只出现在单个函数中,则应该在块的范围内定义对象 [MISRAC2012-RULE_8_9]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_8_9-a.html">如果对象只在一个单独的函数中访问那么应定义其在代码块范围 [MISRAC2012-RULE_8_9-a-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_9_1.html">Rule 9.1 (强制) 在设置之前不得读取具有自动存储持续时间的对象的值 [MISRAC2012-RULE_9_1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_9_1-a.html">避免在初始化之前使用 [MISRAC2012-RULE_9_1-a-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_9_2.html">Rule 9.2 (必需) 聚合或联合的初始化器应该用大括号括起来 [MISRAC2012-RULE_9_2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_9_2-a.html">聚合体和共同体的初始化对象应该用大括号括起来 [MISRAC2012-RULE_9_2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_9_3.html">Rule 9.3 (必需) 不应部分地初始化数组 [MISRAC2012-RULE_9_3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_9_3-a.html">数组不应该部分初始化 [MISRAC2012-RULE_9_3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_9_4.html">Rule 9.4 (必需) 对象的元素不能被初始化多次 [MISRAC2012-RULE_9_4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_9_4-a.html">对象的一个元素不能被初始化超过一次 [MISRAC2012-RULE_9_4-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_9_5.html">Rule 9.5 (必需) 如果使用指定的初始化器初始化数组对象,那么数组的大小应明确地指定 [MISRAC2012-RULE_9_5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MISRAC2012-RULE_9_5-a.html">指定的用来初始化数组对象的初始化器应明确指定数组对象的大小 [MISRAC2012-RULE_9_5-a-2]</a>
</li></ul>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM.html">内存和资源管理 [MRM]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-01.html">由于函数参数的评估顺序尚未定义，禁止在函数参数列表中进行资源分配 [MRM-01-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-02.html">不要在一条语句中分配多个资源 [MRM-02-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-04.html">所有的类应该包含赋值操作符或适当的注释 [MRM-04-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-05.html">所有的类必须包含拷贝构造函数或适当的注释 [MRM-05-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-06.html">在对相应的 new/malloc 以及 delete/free 的调用中应使用相同的形式 [MRM-06-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-07.html">不能对非 POD 使用 memcpy 或 memcmp [MRM-07-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-08.html">禁止对含有构造函数的对象调用 malloc/realloc [MRM-08-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-09.html">始终将一个新值赋给指向已释放内存的表达式 [MRM-09-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-10.html">始终将一个新值赋给指向已释放内存的全局或成员变量 [MRM-10-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-11.html">总是为指向释放内存的参数或局部变量分配新值 [MRM-11-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-12.html">在编写 new 和 delete 函数时应该遵守规范 [MRM-12-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-13.html">在编写 new 函数时应该固守常规 [MRM-13-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-14.html">如果一个类定义了 new 操作符的任何重载，就应该提供 plain, in-place, 和 non-throwing 所有三种标准形式的 new 操作符重载 [MRM-14-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-15.html">如果一个类定义了 new[] 操作符的任何重载，就应该提供 plain, in-place, 和 non-throwing 所有三种标准形式的 new[] 操作符重载 [MRM-15-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-16.html">如果一个类定义了 new[] 操作符的任何重载，就应该提供 plain, in-place, 和 non-throwing 所有三种标准形式的 new[] 操作符重载 [MRM-16-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-17.html">如果一个类定义了 delete[] 操作符的任何重载，就应该提供 plain, in-place, 和 non-throwing 所有三种标准形式的 delete[] 操作符重载 [MRM-17-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-18.html">不要分配内存后期望其他人稍后去释放 [MRM-18-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-19.html">不要分配内存后期望其他人稍后去释放 [MRM-19-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-20.html">不要分配内存后期望其他人稍后去释放它 [MRM-20-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-21.html">使用对象来管理资源 [MRM-21-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-22.html">使用对象来管理资源 [MRM-22-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-23.html">禁止返回函数范围内的new运算符初始化的解引用本地指针 [MRM-23-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-25.html">以独立语句将 newed 对象置入智能指针 [MRM-25-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-26.html">如果写了 new 操作符应该对应写 delete 操作符 [MRM-26-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-27.html">如果写了 new[] 操作符应该对应写 delete[] 操作符 [MRM-27-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-28.html">始终同时提供 new 和 delete 操作符 [MRM-28-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-29.html">始终同时提供 new[] 和 delete[] 操作符 [MRM-29-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-30.html">使用声明进行内存分配，而不是 new 或者 malloc [MRM-30-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-31.html">被释放的内存在任何情况下都不应该被访问 [MRM-31-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-31_b.html">不应该手动调用析构函数 [MRM-31_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-32.html">避免隐藏全局new运算符 [MRM-32-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-33.html">在析构函数中对指针成员调用delete [MRM-33-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-34.html">检查 new 的返回值 [MRM-34-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-35.html">释放非数组内存时 delete 不能使用括号([]) [MRM-35-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-36.html">释放数组内存时 delete 必须使用空括号([]) [MRM-36-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-37.html">为动态分配内存的类声明一个复制赋值运算符 [MRM-37-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-38.html">为动态分配内存的类声明拷贝构造函数 [MRM-38-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-39.html">在调用fopen函数的附近提供文件打开错误的错误处理机制 [MRM-39-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-40.html">拷贝和析构函数必须一致 [MRM-40-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-40_a.html">声明复制构造函数时应声明复制赋值运算符（反之亦然） [MRM-40_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-40_b.html">拷贝构造函数和拷贝赋值操作符应该具有相同的 public/protected/private 权限 [MRM-40_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-40_c.html">如果存在非平凡拷贝构造函数或拷贝赋值操作符，应声明一个析构函数 [MRM-40_c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-40_d.html">复制构造函数和复制赋值运算符都应该为具有非平凡析构函数的类声明 [MRM-40_d-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-41.html">拷贝构造函数应复制所有的数据成员以及基类成员 [MRM-41-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-42.html">在析构函数中调用 fclose() 函数来关闭用于打开文件的指针成员 [MRM-42-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-43.html">赋值运算符必须对基类型中的成员进行赋值 [MRM-43-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-45.html">不要在指针类型上使用 sizeof 操作符来指定通过 'malloc'， 'calloc' 或 'realloc' 函数分配的内存大小 [MRM-45-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-46.html">不要使用 calloc, malloc, realloc 和 free 函数 [MRM-46-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-47.html">包含至少一个非静态成员变量的类应该声明赋值操作符或包含适当的注释 [MRM-47-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-48.html">包含至少一个非静态成员变量的类应该声明拷贝构造函数或包含适当的注释 [MRM-48-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-49.html">应为包含指向数据项或非平凡析构函数的指针的类声明一个拷贝构造函数和一个拷贝赋值操作符 [MRM-49-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-50.html">私有的拷贝构造函数和拷贝赋值运算符要同时声明 [MRM-50-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-51.html">不要对指向一个void类型的指针使用'delete' [MRM-51-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-52.html">使用 RAII 防止资源泄漏 [MRM-52-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-53.html">当分配失败时，用户定义的'new'操作符应该抛出'std::bad_alloc'异常 [MRM-53-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-54.html">避免对过度对齐类型使用默认运算符 'new' [MRM-54-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-55.html">不要传递存储容量不足或者没有对正在构造的对象进行适当的对齐以配置 'new' 的指针 [MRM-55-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-55_b.html">当一个对象数组传递给配置 'new' 的定位函数时,应该会有开销 [MRM-55_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-56.html">拷贝赋值运算符不应有可能会影响复制对象的作用 [MRM-56-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/MRM-57.html">移动赋值运算符不应具有可能影响移动对象的副作用 [MRM-57-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING.html">命名规范 [NAMING]</a></b>
<ul>
<li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN.html">匈牙利记法 [NAMING-HN]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-01.html">应该使用匈牙利命名法的数组变量和参数 [NAMING-HN-01-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-02.html">应该使用匈牙利命名法的布尔类型 [NAMING-HN-02-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-03.html">布尔型指针,数组,或引用类型的匈牙利命名法 [NAMING-HN-03-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-04.html">字节类型的匈牙利命名法 [NAMING-HN-04-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-05.html">字节指针、数组或引用类型应使用匈牙利命名法 [NAMING-HN-05-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-06.html">字符(char)类型应该使用匈牙利命名法 [NAMING-HN-06-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-07.html">字符类型数组的匈牙利命名法 [NAMING-HN-07-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-08.html">指针,数组或字符类型数组的引用的匈牙利命名法 [NAMING-HN-08-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-09.html">char类型指针、数组或引用类型应该用匈牙利符号 [NAMING-HN-09-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-10.html">char类型指针或引用类型应使用匈牙利命名法 [NAMING-HN-10-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-11.html">常量参数的匈牙利命名法 [NAMING-HN-11-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-12.html">双精度浮点类型的匈牙利命名法 [NAMING-HN-12-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-13.html">双精度浮点指针，数组或引用类型应该使用匈牙利命名法 [NAMING-HN-13-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-14.html">双字（dword）类型应该用匈牙利符号 [NAMING-HN-14-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-15.html">双字指针,数组,或引用类型的匈牙利命名法 [NAMING-HN-15-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-16.html">动态分配的数组的匈牙利命名法 [NAMING-HN-16-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-17.html">浮点类型应该使用匈牙利命名法 [NAMING-HN-17-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-18.html">浮点指针,数组,或引用类型的匈牙利命名法 [NAMING-HN-18-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-19.html">类声明的匈牙利命名法 [NAMING-HN-19-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-20.html">结构体声明的匈牙利命名法 [NAMING-HN-20-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-21.html">ifstream 类型的变量和参数应该使用匈牙利命名法 [NAMING-HN-21-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-22.html">整数(int)类型应该使用匈牙利命名法 [NAMING-HN-22-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-23.html">整数指针,数组,或引用类型的匈牙利命名法 [NAMING-HN-23-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-24.html">输入流类型的参数和变量的匈牙利命名法 [NAMING-HN-24-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-25.html">长整型（long int）应该使用匈牙利命名法 [NAMING-HN-25-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-26.html">长双精度浮点类型的匈牙利命名法 [NAMING-HN-26-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-27.html">长双精度浮点指针,数组,或引用类型的匈牙利命名法 [NAMING-HN-27-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-28.html">长整型指针,数组或引用类型的匈牙利命名法 [NAMING-HN-28-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-29.html">成员变量应该使用匈牙利命名法 [NAMING-HN-29-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-30.html">整数(int)类型应该使用匈牙利命名法 [NAMING-HN-30-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-31.html">整型指针,数组,或引用类型的匈牙利命名法 [NAMING-HN-31-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-32.html">输出文件流类型的参数和变量的匈牙利命名法 [NAMING-HN-32-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-33.html">ostream 类型的参数和变量应该使用匈牙利命名法 [NAMING-HN-33-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-34.html">指针应该使用匈牙利命名法 [NAMING-HN-34-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-35.html">引用参数的匈牙利命名法 [NAMING-HN-35-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-36.html">短整型的匈牙利命名法 [NAMING-HN-36-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-37.html">短整型指针，数组或引用类型应该使用匈牙利命名法 [NAMING-HN-37-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-38.html">静态变量的匈牙利命名法 [NAMING-HN-38-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-39.html">字符串类型的匈牙利命名法 [NAMING-HN-39-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-40.html">字符串指针,数组,或引用类型的匈牙利命名法 [NAMING-HN-40-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-41.html">无符号类型应该使用匈牙利命名法 [NAMING-HN-41-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-42.html">void 指针类型应该使用匈牙利命名法 [NAMING-HN-42-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-43.html">字类型的匈牙利命名法 [NAMING-HN-43-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-HN-44.html">字指针,数组,或引用类型的匈牙利命名法 [NAMING-HN-44-3]</a>
</li></ul>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-01.html">所有使用 "#define" 定义的常量必须使用大写 [NAMING-01-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-02.html">在枚举列表中，列表成员(元素)应该是大写的，列表中的名称或标记应该是小写的 [NAMING-02-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-03.html">为文件名使用小写字母 [NAMING-03-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-04.html">带有全局前缀的名字仅能用作全局变量 [NAMING-04-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-05.html">局部变量名应以小写字母开头 [NAMING-05-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-06.html">全局变量名应以小写字母开头 [NAMING-06-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-07.html">成员变量名应以小写字母开头 [NAMING-07-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-08.html">所有布尔类型变量必须以字母 'b' 开头 [NAMING-08-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-09.html">类，结构，联合，枚举和自定义类型(typedef)的名字必须以大写字母开头 [NAMING-09-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-10.html">抽象数据类型，结构体，自定义类型(typedef)，枚举类型的名字必须以大写字母开头 [NAMING-10-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-11.html">枚举类型名称应以大写字母开头并以后缀 '_t' 结尾 [NAMING-11-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-12.html">结构类型名称应以大写字母开头并以后缀 '_t' 结尾 [NAMING-12-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-13.html">常量名以小写字母 'c' 开头' [NAMING-13-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-14.html">类的数据成员名以 'its' 开头 [NAMING-14-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-15.html">双精类型变量名以小写字母 'd' 开头 [NAMING-15-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-16.html">浮点类型变量名以小写字母 'f' 开头 [NAMING-16-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-17.html">所有函数名字以大写字母开头 [NAMING-17-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-18.html">全局变量名以 'the' 开头 [NAMING-18-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-19.html">所有整型变量以小写字母 'i' 开头 [NAMING-19-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-20.html">以 'is' 开头的函数必须返回布尔值 [NAMING-20-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-21.html">所有长整型变量名以 'li' 开头 [NAMING-21-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-22.html">指针类型变量名以字母 'p' 为前缀 [NAMING-22-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-23.html">所有短整型变量以字母 'si' 开头 [NAMING-23-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-24.html">所有有符号字符变量以小写字母 'c' 开头 [NAMING-24-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-25.html">所有有尾字符串的变量名以 'sz' 开头 [NAMING-25-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-26.html">所有无符号字符类型变量名以 'uc' 开头 [NAMING-26-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-27.html">所有无符号整型变量以 'ui' 开头 [NAMING-27-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-28.html">结构和联合的成员名字使用小写字母 [NAMING-28-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-29.html">所有自定义类型的名字应以 "_t" 结尾 [NAMING-29-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-30.html">确保在 C 语言中实现文件始终具有文件扩展名 ".c" [NAMING-30-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-31.html">不要使用字母的大小写区分数据类型 [NAMING-31-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-32.html">对应类的包含文件应采用 &lt;类名&gt; 加扩展名的格式 [NAMING-32-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-33.html">标识符的名字不能以一个下划线 (`_') 或两个下划线 (`__') 开头 [NAMING-33-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-34.html">全局函数名必须以小写字母开头 [NAMING-34-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-35.html">成员函数名必须以小写字母开头 [NAMING-35-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-36.html">函数声明中的参数名必须与函数定义中的参数名字一致 [NAMING-36-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-37.html">确保在 C++ 中包含文件始终具有扩展名 ".hh" [NAMING-37-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-38.html">确保在 C++ 中实现文件始终具有文件扩展名 ".cc" [NAMING-38-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-39.html">内联定义文件的扩展名必须为 ".icc" [NAMING-39-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-40.html">类，结构，命名空间，枚举或自定义类型(typedef)的名字中，只有第一个字母可以大写 [NAMING-40-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-41.html">确保头文件应该始终具有扩展名 '.h' [NAMING-41-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-42.html">常量和枚举(enum)类型的标识符必须是小写 [NAMING-42-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-43.html">源文件的扩展名必须为 ".cpp" 或者".h" [NAMING-43-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-44.html">在函数和变量名中包含的字母应该全部由小写字母组成 [NAMING-44-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-45.html">不能使用大小写字母，下划线区分标识符，也不能使用容易与数字混淆的字母做为标识符名字 [NAMING-45-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-46.html">字符 ', ", /* 或 // 不得出现在头文件的名称中 [NAMING-46-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-47.html">不同的标识符应该是书写明确的 [NAMING-47-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-48.html">字符 \ 不得出现在头文件的名称中 [NAMING-48-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-49.html">C++ 的实现文件应该总是具有扩展名 ".cpp" [NAMING-49-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-50.html">具有重叠可见性的同一命名空间中的标识符应该是排版明确的 [NAMING-50-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-51.html">用户定义的文字操作符的后缀应该以下划线和一个或多个字母开头 [NAMING-51-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-52.html">通用字符名称仅应在字符或字符串文本内使用 [NAMING-52-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/NAMING-53.html">头文件的文件扩展名应该是: ".h", ".hpp" 或 ".hxx" [NAMING-53-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP.html">面向对象 [OOP]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-01.html">在基类中避免使用公共(public)拷贝构造函数和赋值运算符 [OOP-01-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-02.html">避免使用切片，基类中应该使用克隆而非拷贝 [OOP-02-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-03.html">类不能多次继承其它类，除非是虚拟继承 [OOP-03-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-04.html">不要从多于一个基类中派生出相同名字的函数 [OOP-04-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-05.html">禁止使用多重继承 [OOP-05-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-06.html">对于多重继承使用虚公共基类 [OOP-06-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-07.html">要小心使用不是抽象接口的类的多重继承 [OOP-07-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-07_a.html">多重继承应该限制为之多1个受保护的实现 [OOP-07_a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-07_b.html">多重继承不应该使用任何public实现 [OOP-07_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-08.html">禁止构造函数直接访问全局数据 [OOP-08-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-09.html">避免在析构函数中使用全局对象 [OOP-09-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-10.html">避免在成员函数中使用全局数据 [OOP-10-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-11.html">避免使用友元(friend)机制 [OOP-11-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-12.html">受保护(Protected)的成员函数不得返回指向私有类数据的非 const 句柄(指针或引用) [OOP-12-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-13.html">禁止使用不同的默认参数值来重定义继承的虚拟函数 [OOP-13-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-14.html">使用组合 composition 而非使用私有继承 [OOP-14-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-16.html">避免从构造函数调用虚函数 [OOP-16-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-16_b.html">避免从析构函数调用虚函数 [OOP-16_b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-17.html">使用命名空间(using)声明来重新定义重载的函数 [OOP-17-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-18.html">避免 "public" 数据成员 [OOP-18-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-19.html">避免 'protected' 数据成员 [OOP-19-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-20.html">避免从衍生类到基类的显式类型转换 [OOP-20-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-21.html">如果子类型实现了虚拟函数，则应使用虚拟关键词 [OOP-21-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-22.html">在具有虚函数的基类中定义虚拟析构函数 [OOP-22-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-23.html">如果类中含有虚拟函数，那么它也应该包含虚拟析构函数 [OOP-23-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-24.html">在基类中将析构函数设置为虚拟的 [OOP-24-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-25.html">避免把虚函数声明为内联函数 [OOP-25-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-26.html">禁止把指向派生类中对象的指针转化为指向虚基类的对象的指针 [OOP-26-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-27.html">为带有引用成员或常量成员的类声明拷贝赋值操作符 [OOP-27-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-28.html">避免向下转换继承层级结构 [OOP-28-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-29.html">指向抽象类的指针不能被转换为指向继承于该类的子类的指针 [OOP-29-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-30.html">未在类中声明复制构造函数以及拷贝赋值运算符为私有，而在特殊设计的基类型中进行声明 [OOP-30-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-31.html">将基类型的析构函数设置为共有且虚拟的，或保护及非虚拟的 [OOP-31-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-32.html">禁止对继承的非虚拟函数进行重定义 [OOP-32-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-33.html">禁止对含有模板参数的继承非虚拟函数进行重定义 [OOP-33-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-34.html">在operator=中检查对self的赋值 [OOP-34-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-35.html">向下的强制转换(基类到衍生类的转换)是不允许的 [OOP-35-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-36.html">公共成员函数不应该返回指向私有的/受保护的类数据的非常量句柄 [OOP-36-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-37.html">不使用继承的时候，最好使用复合关系 [OOP-37-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-38.html">如果调用了某个类的析构函数并且该类含有虚拟函数，那么该类也应该含有虚拟析构函数 [OOP-38-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-39.html">有状态的虚拟类应该在每个访问该类的衍生类中进行显式地声明 [OOP-39-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-39_b.html">有状态的虚拟类应该在每个访问该类的衍生类中进行显式地声明 [OOP-39_b-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-40.html">层次结构应该基于抽象类 [OOP-40-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-41.html">在同一层次结构中，基类不能同时具有虚拟及非虚拟的属性 [OOP-41-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-42.html">在抽象类中拷贝赋值运算符应该被声明为 protected 或 private [OOP-42-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-43.html">虚拟函数仅能被自身声明为纯虚拟的纯虚拟函数进行覆盖 [OOP-43-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-44.html">在继承层次结构中，其每条路径中的每个虚拟函数应该有多个定义 [OOP-44-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-45.html">具有单一基本类型参数可调用的构造函数应该显式地声明 [OOP-45-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-46.html">拷贝构造函数应仅对其基类型及该类型的非静态成员进行初始化 [OOP-46-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-47.html">类不能从虚拟基类型中衍生 [OOP-47-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-48.html">非 POD 类型的成员数据应该为 &nbsp;private 类型 [OOP-48-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-49.html">禁止对多态类型进行从基类型到衍生类的强制类型转换 [OOP-49-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-50.html">指向虚拟基类型的指针只能通过dynamic_cast的方式转换为指向其衍生类的指针 [OOP-50-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-51.html">使用命名空间而不是类或只包含静态的功能结构体 [OOP-51-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-52.html">执行类的指针不能被转换成指向另一个类的指针类型除非该类继承自另一个类 [OOP-52-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-53.html">派生类里声明的成员函数不应该隐藏基类中声明的函数 [OOP-53-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-54.html">不要增加重写或隐藏方法的可访问性 [OOP-54-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-55.html">非 POD 类型应定义为类 [OOP-55-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-56.html">用户定义的赋值操作符不应是 virtual 的 [OOP-56-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OOP-57.html">struct 应该只包含公共数据成员，不应该是基或继承 [OOP-57-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT.html">最优化 [OPT]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-01.html">尽可能地声明局部化的变量 [OPT-01-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-02.html">避免使用不必要的局部变量 [OPT-02-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-03.html">消除未使用的参数 [OPT-03-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-04.html">规范使用 ++ 和 --。尽量使用前缀形式 [OPT-04-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-05.html">消除未使用的私有成员变量 [OPT-05-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-06.html">避免使用不必要的局部变量 [OPT-06-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-07.html">尽量使用 "a @= b" 的形式，而不应使用 "a = a @ b"，其中 "@" 可以是 +, -, *, /, % [OPT-07-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-08.html">尽量使用 "a @= b" 的形式，而不应使用 "a = a @ b"，其中 "@" 可以是 &amp;, |, ^, &lt;&lt;, &gt;&gt; [OPT-08-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-09.html">删除不必要的 '== true' [OPT-09-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-10.html">不要在 "if", "for", "while", 和 "do while" 语句中声明变量 [OPT-10-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-11.html">如果一个文件级的静态变量仅在一个函数中被使用/引用，就应该只在该函数内部包含此变量 [OPT-11-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-12.html">如果一个文件级的静态变量仅在一个类中被使用/引用，就应该只在该类内部包含此变量 [OPT-12-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-13.html">按照降序顺序声明成员变量 [OPT-13-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-14.html">使用引用而非值传递对象 [OPT-14-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-15.html">使用重载以避免隐式类型转换 [OPT-15-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-16.html">不应内联包含递归、循环或虚函数调用的全局函数 [OPT-16-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-17.html">避免使用内联构造函数和析构函数 [OPT-17-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-18.html">含有递归、循环的成员函数不应定义为内联的 [OPT-18-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-19.html">使用 op= 而非单独的操作符 [OPT-19-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-20.html">尽可能推迟变量定义 [OPT-20-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-21.html">任何一个 switch 语句都至少有一个非空 case 子句 [OPT-21-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-22.html">不允许使用无用的 case 语句 [OPT-22-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-23.html">短小且简单的 accessor/mutator 语句应该为内联函数 [OPT-23-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-24.html">应该内联普通的转发函数 [OPT-24-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-25.html">应只将有 1 个或 2 个语句的函数考虑为内联函数的候选函数 [OPT-25-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-26.html">如果变量不能被初始化为有意义的值就不应引入 [OPT-26-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-27.html">应尽量减少 accessor/mutator 函数的数目 [OPT-27-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-28.html">'strlen' 函数不应该用来检查字符串是否为 NULL/非NULL [OPT-28-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-29.html">不允许冗余显式转换为同一类型 [OPT-29-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-30.html">每个定义的具有内部链接的函数应该至少被使用一次 [OPT-30-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-31.html">非虚函数中不应存在未使用的参数（命名或未命名） [OPT-31-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-32.html">所有具有 viod 返回类型的非空函数应该具有外部作用 [OPT-32-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-32_b.html">具有 void 返回值类型的函数不能为空 [OPT-32_b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-33.html">考虑通过引用而不是值来返回对象 [OPT-33-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-35.html">不要将变量赋值给它自己 [OPT-35-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-36.html">不要在变量的初始化器里使用它 [OPT-36-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-37.html">函数不应该包含未使用的标签声明 [OPT-37-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-38.html">在函数中不应该有未使用的参数 [OPT-38-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-39.html">每一个 switch 语句应该含有至少两个 switch 子句 [OPT-39-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-40_a.html">if-else-if 链的两个分支具有相同的代码（预处理之后） [OPT-40_a-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-40_b.html">在switch语句的不同子句中使用了相同的代码（预处理之后） [OPT-40_b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-41.html">文件应该只包含(include)具有编译该文件所需的声明和定义的头文件 [OPT-41-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OPT-42.html">在虚函数中不应有未使用的命名参数 [OPT-42-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OWASP2017.html">OWASP Top 10 最关键的 Web 应用程序安全风险 (2017) [OWASP2017]</a></b>
<ul>
<li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OWASP2017-A1.html">OWASP A1 注入 [OWASP2017-A1]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OWASP2017-A1-a.html">避免将未经验证的二进制数据传递给日志方法 [OWASP2017-A1-a-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OWASP2017-A1-b.html">防止命令注入 [OWASP2017-A1-b-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OWASP2017-A1-c.html">避免在输出控制台打印受污染的数据 [OWASP2017-A1-c-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OWASP2017-A1-d.html">防止环境注入 [OWASP2017-A1-d-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OWASP2017-A1-e.html">从格式字符串中排除未经消毒的用户输入 [OWASP2017-A1-e-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OWASP2017-A1-f.html">防止 SQL 注入 [OWASP2017-A1-f-1]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OWASP2017-A10.html">OWASP A10 记录&amp;监控不足风险 [OWASP2017-A10]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OWASP2017-A10-a.html">所有的异常应该重新抛出，或者用标准的日志记录器进行记录 [OWASP2017-A10-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OWASP2017-A2.html">OWASP A2 失效的身份验证 [OWASP2017-A2]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OWASP2017-A2-a.html">不使用弱加密功能 [OWASP2017-A2-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OWASP2017-A3.html">OWASP A3 敏感数据暴露 [OWASP2017-A3]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OWASP2017-A3-a.html">在伪随机数生成器中指定适当的种子 [OWASP2017-A3-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OWASP2017-A4.html">OWASP A4 XML 外部实体 (XXE) [OWASP2017-A4]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OWASP2017-A4-a.html">在 libxerces-c 中禁用解析 XML 外部实体(XXE) [OWASP2017-A4-a-2]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OWASP2017-A5.html">OWASP A5 失效的访问控制 [OWASP2017-A5]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OWASP2017-A5-a.html">防止文件名注入 [OWASP2017-A5-a-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OWASP2017-A5-b.html">在放弃特权时遵守正确的撤销命令 [OWASP2017-A5-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OWASP2017-A5-c.html">确保成功地放弃特权 [OWASP2017-A5-c-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OWASP2017-A6.html">OWASP A6 安全配置错误 [OWASP2017-A6]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OWASP2017-A6-a.html">如果在一个 try-catch 语句或函数 try-block 中为派生类及其部分或全部基类提供多个处理程序，则应将派生程度最高的处理程序排序为派生程度最高的基类 [OWASP2017-A6-a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OWASP2017-A6-b.html">不要让 'catch' 块为空 [OWASP2017-A6-b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/OWASP2017-A6-c.html">正确使用 errno 值 [OWASP2017-A6-c-2]</a>
</li></ul>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PARSER.html">解析器诊断 [PARSER]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PARSER-REMARK.html">解析器标记 [PARSER-REMARK-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PARSER-WARNING.html">解析器警告 [PARSER-WARNING-4]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB.html">潜在的缺陷 [PB]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-01.html">不要使用解引用指针类型的表达式 [PB-01-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-02.html">不要在 a(b), a[b] 和类型转换语句内部使用赋值 [PB-02-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-03.html">不允许在三元运算符中使用混合类型 [PB-03-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-05.html">函数的返回值必须与声明的返回类型一致 [PB-05-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-06.html">赋值运算符应该具有兼容类型的操作数 [PB-06-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-07.html">不给不兼容类型的变量赋函数返回值 [PB-07-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-08.html">不允许将有符号常量赋值给无符号整型变量 [PB-08-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-09.html">操作符不能使用引用返回值 [PB-09-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-10.html">不要多形性地对待数组 [PB-10-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-11.html">函数声明的形参类型和实参类型必须匹配 [PB-11-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-12.html">不要将有符号字符强制转换成无符号整型 [PB-12-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-13.html">不要释放空指针 [PB-13-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-14.html">不正确的 EOS(串尾)定义 [PB-14-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-15.html">不能将两个整数相除之后的结果赋给浮点类型 [PB-15-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-15_b.html">避免无意地丢弃整数除法的余数 [PB-15_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-16.html">避免将越界数值赋值给字符类型 [PB-16-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-17.html">避免将越界数值赋值给无符号字符类型 [PB-17-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-18.html">避免在指针和数字类型上重载类方法。 [PB-18-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-19.html">不应创建带有局部静态数据的内联非成员函数 [PB-19-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-20.html">避免切片函数参数/返回值 [PB-20-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-21.html">提供正确的字符串终止符 [PB-21-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-22.html">不能在 a(b),a[b] 和类型转换中使用自增或自减表达式 [PB-22-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-23.html">如果类中含有非静态指针并且没有声明过拷贝构造函数，就应使用引用传递类对象 [PB-23-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-24.html">构造函数的定义中不能包含特定的缺省参数，这些参数可能产生与隐性声明的复制构造函数完全一样的签名 [PB-24-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-25.html">不要使用无符号算术 [PB-25-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-26.html">public 和 protected 的方法不应被类的构造函数调用 [PB-26-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-27.html">字符串文字不应被修改 [PB-27-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-28.html">下列的字符序列不得出现在头文件名中： ', \, /*, //, 或 " [PB-28-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-29.html">右移位操作符的左操作数不能是负数 [PB-29-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-30.html">多于一个枚举('enum')类型应该用作 switch 的条件或 case 语句的标签 [PB-30-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-31.html">不要在常量上调用 'sizeof' [PB-31-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-32.html">不要在指针类型上调用'sizeof' [PB-32-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-33.html">避免使用枚举类型隐式类型转换 [PB-33-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-33_b.html">在涉及枚举类型的比较中避免隐式类型转换 [PB-33_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-34.html">'memcpy'/'strncpy'/'memmove' 的第三个参数不应该依赖于第二个参数 [PB-34-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-35.html">赋值操作符不得使用在没有括号的条件中 [PB-35-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-36.html">对象的动态类型不能够从它的构造函数和析构函数的函数体中使用 [PB-36-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-37.html">不得使用库 &lt;cstring&gt; 的无界函数 [PB-37-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-38.html">窄字符串和宽字符串不应该串联在一起 [PB-38-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-38_b.html">不应连接具有不同编码前缀的字符串文字 [PB-38_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-39.html">函数不得返回一个引用或指针给通过引用或 常数引用传递的参数 [PB-39-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-39_b.html">函数不应返回对 const 引用传递的指针或参数的引用 [PB-39_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-41.html">作为函数实参传递的数组类型标识符不得退化为一个指针 [PB-41-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-41_b.html">不要将具有数组类型的表达式传递给一个具有指针或者数组类型参数的函数 [PB-41_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-42.html">对象不能赋值给一个重叠的对象 [PB-42-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-43.html">一个类的所有构造函数应该显式地为它的所有直接基类和所有虚基类调用一个构造函数 [PB-43-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-44.html">注册为'std::atexit()'或'std::at_quick_exit()'的函数的执行不应该通过异常退出 [PB-44-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-45.html">在调用字符串格式化函数时，格式字符串中的'%s'和'%c'格式说明符及其对应的参数不应该不匹配 [PB-45-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-46.html">在调用字符串格式化函数时，格式字符串中的'%f'格式说明符及其对应的参数之间不应存在不匹配 [PB-46-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-47.html">在调用字符串格式化函数时，字符串中的“%i”和“%d”格式说明符及其对应的参数不应该不匹配 [PB-47-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-48.html">在调用字符串格式化函数时，格式字符串中的'%u'格式说明符及其对应的参数之间不应存在不匹配 [PB-48-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-49.html">在调用字符串格式化函数时，格式字符串中的'%p'格式说明符及其对应的参数之间不应存在不匹配 [PB-49-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-50.html">格式字符串中的格式说明符的数量和调用字符串格式化函数时相应的参数的数量应该相等 [PB-50-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-51.html">指针运算不得用于指向非数组类型变量的指针 [PB-51-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-52.html">避免在指针和数值类型上重载全局函数 [PB-52-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-53.html">避免在指针和数值类型上重载命名空间函数 [PB-53-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-54.html">映射过程中不要从不完整类映射，或者映射到不完整类 [PB-54-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-55.html">不要在删除点上时删除类不完整的对象 [PB-55-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-56.html">避免从有符号类型到无符号类型的隐式变换 [PB-56-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-57.html">指向派生类对象数组的指针不应转换为基类指针 [PB-57-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-58.html">在一个列举列表内，含蓄指定列举常数的值应该是唯一的 [PB-58-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-59.html">字符串数组初始化时缺失逗号 [PB-59-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-60.html">可疑的 malloc 参数 [PB-60-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-61.html">不得在新分配的内存上执行指针算术运算 [PB-61-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-62.html">避免参数顺序不正确的函数调用 [PB-62-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-63.html">函数地址不应与零相比较 [PB-63-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-64.html">字符串比较的返回值仅和0比较 [PB-64-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-65.html">避免在将结果赋给更大整数类型的变量的表达式中可能出现的整数溢出 [PB-65-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-65_b.html">避免在将结果与更广泛的整数类型的表达式进行比较的表达式中可能出现的整数溢出 [PB-65_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-66_a.html">'+'， '-'， '*' 运算符常量表达式中的整数溢出或下溢 [PB-66_a-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-66_b.html">'&lt;&lt;' 运算符常量表达式中的整数溢出或下溢 [PB-66_b-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-67.html">在if-else语句的两个分支(预处理后)有相同的代码 [PB-67-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-68.html">由于只有零或非零常量的枚举，布尔条件总是计算为相同的值 [PB-68-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-69.html">对象的一个元素不能被初始化超过一次 [PB-69-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-70.html">带有枚举底层类型的表达式只能具有与枚举的枚举数相对应的值 [PB-70-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-71.html">不要复制包含柔性数组成员的结构的实例 [PB-71-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-72.html">不要使用错误的参数类型调用va_arg [PB-72-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-73.html">对常量无符号整数表达式的求值不应该导致循环 [PB-73-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-74.html">不要从迭代器中添加或减去一个值大于1的常量 [PB-74-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-75.html">不得使用 'stdlib.h' 或 'cstdlib' 库中的 'abort()' 函数 [PB-75-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-75_b.html">不得使用 'stdlib.h' &nbsp;或 'cstdlib' 库中的 'exit()' 函数 [PB-75_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-75_c.html">不得使用 'stdlib.h' 或 'cstdlib' 库中的 'quick_exit()' 和 '_Exit()' 函数 [PB-75_c-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-76.html">不能使用 C 风格的字符串 [PB-76-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PB-77.html">表达式语句不能只显式调用临时对象的构造函数 [PB-77-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PFO.html">物理文件组织 [PFO]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PFO-01.html">在头文件中不能定义具有链接属性的实体 [PFO-01-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PFO-02.html">使用多个包含保护 [PFO-02-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PFO-03.html">一个包含文件中只能带有一个类定义 [PFO-03-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PFO-04.html">每个实现文件都应该声明一个描述文件的局部常量字符串 [PFO-04-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PFO-05.html">带有 '.c' 扩展名的文件不能包含其它带有 '.c' 扩展名的文件 [PFO-05-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PFO-06.html">禁止在带有 '.icc' 扩展名的文件中包含其它文件 [PFO-06-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PFO-07.html">使用基于头文件名的多重包含保护机制 [PFO-07-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PFO-08.html">使用某种机制以防止文件的多重包含，例如，包含保护或者使用 "#pragma once" 预处理指令 [PFO-08-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PFO-09.html">"#pragma once"预处理指令不能使用在源代码文件中 [PFO-09-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PORT.html">可移植性 [PORT]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PORT-01.html">使用大写 'L' 而非小写 'l' 来指定长整型 [PORT-01-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PORT-02.html">如果将整型操作的结果赋值给 long，其中至少一个整型必须强制转换成 long [PORT-02-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PORT-03.html">不能在结构体中使用硬编码的数值作为偏移量 [PORT-03-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PORT-04.html">不要使用十六进制常数 '0xffffffff' 作为一个错误标识符 [PORT-04-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PORT-05.html">指向 long 的指针不能强制转换成指向int型的指针 [PORT-05-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PORT-06.html">不能将长整型赋值给整型 [PORT-06-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PORT-07.html">不能在函数调用中将 long 类型强制转换后传递给整型 [PORT-07-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PORT-08.html">将常量赋值给 long 时，应在数字结尾加上大写字母L [PORT-08-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PORT-10.html">不能使用整数直接初始化长整型 [PORT-10-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PORT-11.html">不能将整型指针强制类型转化成 long 指针 [PORT-11-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PORT-12.html">不能将 32 位乘法运算的数值赋值给 long 类型 [PORT-12-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PORT-13.html">整型 int 类型必须声明为无符号整型或者有符号整型 [PORT-13-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PORT-14.html">避免在赋值操作中从"短"("shorter")的类型转换成"长"("longer")的类型 [PORT-14-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PORT-15.html">不能将 "短"("shorter") 类型强制转换成 "长"("longer") 类型 [PORT-15-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PORT-16.html">避免在函数调用中从"短"("shorter")的类型转换成"长"("longer")的类型 [PORT-16-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PORT-17.html">不能直接使用 'i64' 或者 'L' 后缀 [PORT-17-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PORT-19.html">不要在表达式中将长类型操作符强制转换成整型，将表达式的结果进行强制转换 [PORT-19-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PORT-20.html">不能直接声明 long 类型的变量 [PORT-20-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PORT-21.html">不能将 long 变量赋值给 double [PORT-21-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PORT-22.html">使用整型数组而非使用 long 类型的大数组 [PORT-22-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PORT-23.html">使用整型数组而非使用动态分配的 long 类型的大数组 [PORT-23-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PORT-24.html">不能使用指向bool,char,short,int和float类型的指针的大数组 [PORT-24-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PORT-25.html">用户指定的标识符(内部或者外部的)不能多于 64 个字符 [PORT-25-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PORT-26.html">算法中不应假设由访问标识符分隔的非静态数据成员的分配顺序 [PORT-26-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PORT-27.html">避免隐式转换为一种更窄的类型 [PORT-27-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PORT-28.html">避免将常数值转换为一个窄类型 [PORT-28-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PORT-29.html">指向结构体的指针不应该传递给向文件写入数据的函数 [PORT-29-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PORT-30.html">不要跨越执行边界抛出异常 [PORT-30-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PORT-31.html">不要跨越执行边界传递非标准布局类型的对象 [PORT-31-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PORT-32.html">不应使用 long double 型 [PORT-32-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PORT-33.html">不应使用 wchar_t 类型 [PORT-33-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PREPROC.html">预处理 [PREPROC]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PREPROC-01.html">避免使用宏 [PREPROC-01-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PREPROC-02.html">不应在 include 语句中使用宏 [PREPROC-02-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PREPROC-03.html">不能重定义原始类型 [PREPROC-03-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PREPROC-04.html">不能只定义一部分语句 [PREPROC-04-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PREPROC-05.html">在宏函数中，应使用括号将乘法和除法操作括起来 [PREPROC-05-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PREPROC-06.html">不允许在 #include 语句中带有相对路径名 [PREPROC-06-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PREPROC-07.html">不正确的 'NULL' 定义 [PREPROC-07-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PREPROC-08.html">仅可以在包含头文件(*.h)时使用 #include 预处理指令 [PREPROC-08-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PREPROC-09.html">#include 指令只能使用 &lt;filename.h&gt; 符号来包含头文件 [PREPROC-09-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PREPROC-10.html">#ifndef 和 #endif 预处理指令将仅用于防止重复地包含相同的头文件 [PREPROC-10-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PREPROC-11.html">只有下列预处理器指令才能被使用: #ifndef, #define, #endif, #include [PREPROC-11-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PREPROC-12.html">C++ 宏应该只能用于包含保护(include guards)，类型修饰符，或存储类限定符 [PREPROC-12-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PREPROC-13.html">宏不应该包含标记(token)粘贴，变量参数列表，也不包括递归宏调用 [PREPROC-13-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PREPROC-14.html">所有宏必须扩展到完整的句法单位 [PREPROC-14-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PREPROC-15.html">指针解引用操作不应该被隐藏在宏定义中 [PREPROC-15-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PREPROC-16.html">一个紧跟在#操作符的宏参数不应该在其后紧跟或在其前加上##操作符 [PREPROC-16-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PREPROC-17.html">一个被用作 # 或者 ## 操作符的操作数的宏参数，并且它本身受制于进一步的宏替换，那么它应该只能被用作这些操作符的操作数 [PREPROC-17-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PREPROC-18.html">不应该包含标准输入/输出库 stdio.h [PREPROC-18-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PREPROC-19.html">一个# if或# elif预处理指令的控制表达式将值为0或1 [PREPROC-19-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PREPROC-20.html">将 #include 指令中的文件名与文件系统上的文件名匹配 [PREPROC-20-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PREPROC-21.html">避免产生通用字符名称的占位符串联 [PREPROC-21-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PREPROC-22.html">不应使用 #error 指令 [PREPROC-22-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PREPROC-23.html">不应使用 #pragma 指令 [PREPROC-23-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/PREPROC-24.html">除 #ifdef 和 #ifndef 预处理器指令和 defined() 操作符外，预处理指令中的所有宏标识符都应在使用前定义 [PREPROC-24-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/QT.html">Qt 最佳实践 [QT]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/QT-01.html">每个QObject子类都应该包含一个Q_OBJECT宏 [QT-01-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/QT-02.html">QObject 不得多次继承 [QT-02-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/QT-03.html">只能将一个信号连接到一个槽或一个信号连接到另一个信号 [QT-03-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/QT-04.html">SIGNAL 和 SLOT 宏中的方法必须存在 [QT-04-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/QT-05.html">用关键字 "emit" 标记信号发射( signal emission )，以区分信号发射和普通方法调用 [QT-05-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/QT-06.html">不要为 QThreads 设置 Idle 或 Critical 优先级。只使用 High/Low/Med [QT-06-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/QT-07.html">不要通过调用 QThread::terminate() 来强制线程终止 [QT-07-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/QT-08.html">如果在函数中对互斥使用锁，则释放同一函数中的锁 [QT-08-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/QT-09.html">在QMutexLocker上不调用new [QT-09-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/QT-10.html">为任何具有指针的Qt继承对象声明一个复制构造函数和操作符= [QT-10-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/QT-11.html">不要在小部件上使用setWindowFlags函数 [QT-11-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/QT-12.html">不要直接设置由 Qt 内核设置的特定 Widget 属性 [QT-12-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/QT-13.html">不要在赋值中混合 const 和非 const 迭代器 [QT-13-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/QT-14.html">如果使用 Q_DECLARE_FLAGS ，那么就必须使用 Q_DECLARE_OPERATORS_FOR_FLAGS [QT-14-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/QT-15.html">Q_DECLARE_OPERATORS_FOR_FLAGS 必须位于全局命名空间中，Q_DECLARE_FLAGS 必须位于枚举的命名空间中 [QT-15-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/QT-16.html">Q_PROPERTY 的 getter 和 setter 函数必须存在，且类型必须匹配 [QT-16-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/QT-17.html">枚举类型的属性必须使用Q_ENUMS [QT-17-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/QT-18.html">不应该在Qt对象上调用Non-const函数 [QT-18-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY.html">安全性 [SECURITY]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-01.html">避免使用标准 C 库中与时间有关的函数 [SECURITY-01-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-02.html">避免使用标准 C 库中随机数的函数 [SECURITY-02-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-02_b.html">不要使用rand()函数来生成伪随机数 [SECURITY-02_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-03.html">限制使用系统属性（环境变量） [SECURITY-03-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-04.html">谨慎使用以确保 LoadLibrary() 加载正确的库 [SECURITY-04-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-05.html">避免调用只有一个参数而不是字符串常量的函数 printf/wprintf [SECURITY-05-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-06.html">避免使用 MFC 库中的时间函数 [SECURITY-06-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-07.html">不要使用不安全的 C 函数来写未检查范围的缓冲区 [SECURITY-07-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-08.html">当第二个参数是变量时，避免使用只有两个参数的函数 fprintf/fwprintf [SECURITY-08-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-09.html">避免使用标准库中 'string' 类中的 data() 函数 [SECURITY-09-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-10.html">避免使用 'vfork()' 函数 [SECURITY-10-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-11.html">避免使用可能受到 shell 元字符影响的不安全 shell 函数 [SECURITY-11-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-12.html">避免使用可能导致缓冲区溢出的不安全字符串函数 [SECURITY-12-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-13.html">避免使用不安全的不检查界限的字符串函数 [SECURITY-13-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-14.html">不要在不指定可变大小的格式字符串的情况下使用 scanf 和 fscanf 函数 [SECURITY-14-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-15.html">不要将应用程序错误导致的潜在敏感信息打印到异常消息中 [SECURITY-15-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-16.html">绝不使用 gets() 函数 [SECURITY-16-1]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-17.html">避免将非常量参数或变量传递给 exec [SECURITY-17-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-18.html">避免将动态生成的字符串传递给 exec [SECURITY-18-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-19.html">不允许使用容易发生争用的函数 [SECURITY-19-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-20.html">避免将用户的输入作为参数传递给方法 [SECURITY-20-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-21.html">不能将 'syslog' 函数用于日志记录目的 [SECURITY-21-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-22.html">不要使用 mbstowcs() 函数 [SECURITY-22-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-23.html">警惕使用那些返回当前目录或窗口目录的函数 [SECURITY-23-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-24.html">避免使用InitializeCriticalSection [SECURITY-24-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-25.html">避免使用对线程不安全(thread-unsafe)的函数 [SECURITY-25-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-26.html">不要在源代码中使用 'setuid' [SECURITY-26-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-27.html">不要使用 chmod(), chown(), chgrp() [SECURITY-27-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-28.html">出于安全考虑，不应该使用标准随机数生成器来生成随机性 [SECURITY-28-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-29.html">不能使用已经废弃的 C 程序 ulimit() [SECURITY-29-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-30.html">避免在程序代码中使用 'getpw' 函数 [SECURITY-30-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-31.html">不要使用 'cuserid' 函数 [SECURITY-31-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-32.html">避免使用已经废弃的 C 程序 'usleep' [SECURITY-32-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-33.html">禁止使用那些不能正确处理非空结束的字符串的函数 [SECURITY-33-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-34.html">避免使用环境变量 [SECURITY-34-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-35.html">不要相信任何可能被攻击者设置的命令行值 [SECURITY-35-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-36.html">禁止使用来自不信任用户的未经过滤的数据作为格式化参数 [SECURITY-36-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-37.html">不使用弱加密功能 [SECURITY-37-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-38.html">不可信数据用作循环边界 [SECURITY-38-2]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-39.html">使用安全的临时文件名称函数 [SECURITY-39-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-40.html">在调用 'mkstemp' 之前调用 'umask' [SECURITY-40-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-41.html">如果你调用 'chroot' 请调用 'chdir' [SECURITY-41-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-42.html">如果文件是使用 'open' 或 'openat' 系统调用创建的，则指定访问权限位 [SECURITY-42-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-43.html">不应该使用 'PTHREAD_CANCEL_ASYNCHRONOUS'参数来调用函数'pthread_setcanceltype()' [SECURITY-43-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-44.html">在放弃特权时遵守正确的撤销命令 [SECURITY-44-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-45.html">确保成功地放弃特权 [SECURITY-45-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-46.html">不应将指向结构的指针传递给可将数据复制到用户空间的函数 [SECURITY-46-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-47.html">检查shift操作符的右手操作数时，请使用正确的整数精度 [SECURITY-47-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-48.html">不要调用 'stdlib.h' 或 'cstdlib' 库中参数不为 '0'（空指针）的 'system()' 函数 [SECURITY-48-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-48_b.html">不得使用 'stdlib.h' 或 'cstdlib' 库中的 'system()' 函数 [SECURITY-48_b-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-49.html">使用带有唯一条件变量的“cnd_signal()”函数 [SECURITY-49-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-50.html">当多个线程在等待同一个条件变量时，不要使用'notify_one()'函数 [SECURITY-50-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-51.html">不要使用 'char' 缓冲区来存储来自 'std::cin' 的输入 [SECURITY-51-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/SECURITY-52.html">不得使用 'stdlib.h' 或 'cstdlib' 库中的 'getenv()' 函数 [SECURITY-52-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL.html">STL 最佳实践 [STL]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-01.html">选择使用类的封装，而不是编写与容器无关的代码 [STL-01-5]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-02.html">要使复制有效、正确且不会产生切片问题，应该创建指针容器而不是对象容器 [STL-02-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-03.html">调用 empty 而不要判断 size() 是否为 0 [STL-03-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-04.html">避免在显式的循环中递归调用插入操作 [STL-04-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-05.html">几乎所有的复制是通过调用成员函数而不是插入迭代器来确定目的范围 [STL-05-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-06.html">当用作函数参数时，应使用 istream_iterator 名字而不是匿名的 istream_iterator 对象 [STL-06-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-07.html">容器中如果有新创建的指针，切记删除容器之前先删除指针 [STL-07-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-08.html">禁止创建 auto_ptrs 的容器 [STL-08-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-09.html">避免对 list 和标准关联容器使用 remove 算法 [STL-09-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-10.html">对于动态分配的数组最好使用 vector 或 string [STL-10-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-11.html">使用 vector&lt;char&gt; 而非 string [STL-11-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-12.html">使用 reserve 来避免不必要的重复分配 [STL-12-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-13.html">每一个 vector 和 string 在被传递给 C 函数之前，应该对它们是否为空做一个检查 [STL-13-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-14.html">避免使用 vector&lt;bool&gt; [STL-14-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-15.html">对存放指针的关联容器指定比较方式 [STL-15-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-16.html">禁止对关联容器使用判定相等数值为 true 的比较函数 [STL-16-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-17.html">禁止对关联容器使用判定相等数值为真的比较函数 [STL-17-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-18.html">使用 iterator 而不是 const iterator,reverse_iterator,或 const_reverse_iterator [STL-18-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-19.html">使用 distance 和 advance 将容器的 const_iterators 转换为 iterators [STL-19-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-20.html">出于删除目的时，应谨慎使用 reverse_iterator 的基迭代器 [STL-20-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-21.html">逐字符输入时，使用 istreambuf 的迭代器 [STL-21-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-22.html">确保目标范围足够大 [STL-22-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-23.html">如果进行删除操作，采取类似 remove 的算法 [STL-23-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-24.html">避免对存放动态内存指针的容器使用 remove 或类似的算法（即remove_if和unique） [STL-24-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-25.html">如果你传递一个已排序的值域给某个算法，而同时该值域进行一个比较函数操作时，应确保这个比较函数传递的值域是跟用于排序的值域是相同的 [STL-25-4]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-26.html">正确执行 copy_if 的前提是不应该在谓词前返回带有 not1 的 remove_copy_if [STL-26-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-27.html">如果 accumulate() 用于包含浮点指针值的容器，必须使用浮点数值初始化 [STL-27-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-28.html">按传递值来设计 functor 类 [STL-28-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-29.html">使谓词常量成为纯函数 [STL-29-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-30.html">每一个 functor 类应该有且只有一个 operator()，并且其参数和返回值类型应该通过 unary_function 或 binary_function 来指定 [STL-30-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-31.html">将函数传递给 STL 构件时，必须使用 ptr_fun,mem_fun,或者 mem_fun_ref [STL-31-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-32.html">确保 less&lt;T&gt; 与操作符 &lt; 语义一致 [STL-32-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-33.html">尽量采用算法调用而不是手写循环 [STL-33-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-34.html">最好采用成员函数而不是采用同名算法 [STL-34-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-35.html">不能简单的将某个非零的常量转换为真，将零转换为假 [STL-35-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-36.html">不要使用一个不是真实范围的迭代器范围 [STL-36-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-37.html">使用向量(vector)或者字符串代替数组 [STL-37-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-38.html">使用 != 代替 &lt; 来比较迭代器 [STL-38-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-39.html">将特征类（Traits）与重载关联使用 [STL-39-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-40.html">调用 swap 时，使用 using 声明 std::swap，然后调用 swap 不需要命名空间限定 [STL-40-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-41.html">不能声明非成员作为 std::swap 的重载 [STL-41-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/STL-42.html">Swap 的成员版本应该禁止抛出异常 [STL-42-3]</a>
</li></ul>
</li><li><b><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/TEMPL.html">模板 [TEMPL]</a></b>
<ul>
<li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/TEMPL-01.html">从模板中分离出参数无关的代码 [TEMPL-01-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/TEMPL-02.html">需要类型转换时在模板内定义非成员函数 [TEMPL-02-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/TEMPL-03.html">不要重载模板类中的函数 [TEMPL-03-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/TEMPL-04.html">在全局模板函数中使用 'typename' 去标识嵌套依赖类型名 [TEMPL-04-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/TEMPL-05.html">在模板类中使用 'typename' 去标识嵌套依赖类型名 [TEMPL-05-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/TEMPL-06.html">在模板类中，不要改变默认的虚函数参数 [TEMPL-06-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/TEMPL-07.html">当存在一个包含单个泛型参数的模板构造函数时，拷贝构造函数应该被声明 [TEMPL-07-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/TEMPL-08.html">函数调用的可行函数集合应该要么不包括函数特化，要么只包括函数特化 [TEMPL-08-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/TEMPL-09.html">重载函数模板不应该明确专用 [TEMPL-09-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/TEMPL-10.html">模板所有的部分和显式专门化都应在与其主模板声明相同的文件中声明 [TEMPL-10-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/TEMPL-11.html">存在一个包含泛型参数的模板赋值运算符时，拷贝赋值运算符应该被声明 [TEMPL-11-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/TEMPL-12.html">在含有依赖基础的类模板中，任何可能在这个依赖类中被发现的名称都应该引用使用限定标识（qualified-id）或 -&gt; [TEMPL-12-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/TEMPL-13.html">不要在关联的命名空间中声明非成员通用函数 [TEMPL-13-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/TEMPL-14.html">函数应解析为先前在编译单元中声明的函数 [TEMPL-14-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/TEMPL-15.html">声明 'extern' 一个显式实例化的模板 [TEMPL-15-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/TEMPL-16.html">模板专门化应声明在与主模板或用户定义类型相同的文件中，为其声明专门化 [TEMPL-16-3]</a>
</li><li><a href="file:///D:/tmp/Administrator/parasoft/xtest/gendoc/TEMPL-17.html">如果返回类型前面带有 'typename' 关键字，使用尾随返回类型语法 [TEMPL-17-3]</a>
</li></ul>
</li></ul>

</font></body></html>